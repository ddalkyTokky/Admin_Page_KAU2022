
/**
 * Client
**/

import * as runtime from './runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Accounts
 * 
 */
export type Accounts = {
  id: number
  phone: string | null
  verifyToken: number | null
  createdAt: Date
  updatedAt: Date
  profile: Prisma.JsonValue | null
  isAdmin: boolean | null
  email: string | null
  password: string | null
  name: string | null
  isVerify: boolean | null
  isApprove: boolean | null
  ServiceKey: string | null
}

/**
 * Model Alerts
 * 
 */
export type Alerts = {
  id: bigint
  title: string | null
  type: string
  category: string
  AccountId: number | null
  ReferenceId: number
  isRead: boolean | null
  createdAt: Date
  updatedAt: Date
  data: Prisma.JsonValue | null
}

/**
 * Model Careers
 * 
 */
export type Careers = {
  id: number
  AccountId: number | null
  title: string | null
  startDate: Date | null
  endDate: Date | null
  content: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Coupons
 * 
 */
export type Coupons = {
  id: number
  name: string | null
  code: string | null
  quantity: number | null
  maxRetry: number | null
  unit: string | null
  value: number | null
  startedAt: Date | null
  endedAt: Date | null
  createdAt: Date
  extra: Prisma.JsonValue | null
  updatedAt: Date
}

/**
 * Model CustomerTaskDetails
 * 
 */
export type CustomerTaskDetails = {
  id: number
  AccountId: number | null
  CustomerId: number | null
  type: string | null
  address: string | null
  villageName: string | null
  category: string | null
  etc: string | null
  geometry: Prisma.JsonValue | null
  x: string | null
  y: string | null
  area: Prisma.Decimal | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Customers
 * 
 */
export type Customers = {
  id: number
  name: string | null
  email: string | null
  phone: string | null
  crops: string[]
  AccountId: number | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Discounts
 * 
 */
export type Discounts = {
  id: number
  name: string | null
  price: number | null
  createdAt: Date
  updatedAt: Date
  AccountId: number | null
  OrderId: number | null
  CouponId: number | null
  ProductId: number | null
  filters: Prisma.JsonValue | null
}

/**
 * Model Events
 * 
 */
export type Events = {
  id: bigint
  table: string
  action: string | null
  createdBy: number | null
  data: Prisma.JsonValue | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Geos
 * 
 */
export type Geos = {
  id: number
  address: string | null
  geometry: Prisma.JsonValue | null
  x: string | null
  y: string | null
  pnu: string | null
  area: Prisma.Decimal | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Lands
 * 
 */
export type Lands = {
  id: bigint
  AccountId: number
  is_active: boolean | null
  type: string | null
  villageName: string | null
  status: string | null
  geometry: Prisma.JsonValue | null
  x: string | null
  y: string | null
  area: Prisma.Decimal | null
  extra: Prisma.JsonValue | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Notices
 * 
 */
export type Notices = {
  id: number
  startDate: Date | null
  endDate: Date | null
  imageURL: string | null
  externalURL: string | null
  order: number | null
  active: boolean | null
  deletedDate: Date | null
  createdAt: Date
  updatedAt: Date
  name: string | null
}

/**
 * Model Notifications
 * 
 */
export type Notifications = {
  id: bigint
  AccountId: number
  fcmToken: string
  sendedAt: Date | null
  isSuccess: boolean | null
  failReason: string | null
  eventCode: string
  sendCode: string
  reservationCode: string
  sendCycleCode: string
  title: string
  message: string
  image: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model OrderHistories
 * 
 */
export type OrderHistories = {
  id: number
  name: string | null
  payment: string | null
  paymentMethod: string | null
  externalUid: string | null
  customerUid: string | null
  merchantUid: string | null
  reqAmount: number | null
  paidAmount: number | null
  status: string | null
  extra: Prisma.JsonValue | null
  AccountId: number | null
  ProductId: number | null
  OrderId: number | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Orders
 * 
 */
export type Orders = {
  id: number
  name: string | null
  payment: string | null
  paymentMethod: string | null
  externalUid: string | null
  customerUid: string | null
  merchantUid: string | null
  reqAmount: number | null
  paidAmount: number | null
  status: string | null
  extra: Prisma.JsonValue | null
  AccountId: number | null
  ProductId: number | null
  createdAt: Date
  updatedAt: Date
  expiredAt: Date | null
  isSubscribe: boolean | null
  issuedAt: Date | null
}

/**
 * Model Permissions
 * 
 */
export type Permissions = {
  id: number
  resource: string
  key: enum_Permissions_key
  resourceId: number
  AccountId: number | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model PostAccounts
 * 
 */
export type PostAccounts = {
  id: number
  AccountId: number | null
  PostId: number | null
  type: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Posts
 * 
 */
export type Posts = {
  id: number
  category: string | null
  type: string[]
  content: string | null
  unit: string | null
  price: number | null
  location: string[]
  area: Prisma.Decimal | null
  title: string | null
  createdAt: Date
  updatedAt: Date
  startDate: Date | null
  endDate: Date | null
  status: string | null
  viewCount: number | null
  AccountId: number | null
  contactName: string | null
  contactPhone: string | null
  contactEmail: string | null
  qualifications: string[]
}

/**
 * Model Products
 * 
 */
export type Products = {
  id: number
  name: string | null
  description: string | null
  price: number | null
  duration: number | null
  filters: Prisma.JsonValue | null
  isActive: boolean | null
  createdAt: Date
  updatedAt: Date
  isSubscribe: boolean | null
}

/**
 * Model Reports
 * 
 */
export type Reports = {
  id: number
  name: string | null
  isActive: boolean | null
  isPrivate: boolean | null
  password: string | null
  createdAt: Date
  updatedAt: Date
  TaskId: number | null
  AccountId: number | null
}

/**
 * Model SequelizeMeta
 * 
 */
export type SequelizeMeta = {
  name: string
}

/**
 * Model Services
 * 
 */
export type Services = {
  key: string
  description: string | null
  isActive: boolean | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Statistics
 * 
 */
export type Statistics = {
  id: number
  AgentId: number | null
  TeamId: number | null
  TaskId: number | null
  dailyWorkload: Prisma.Decimal | null
  completedByOwner: Prisma.Decimal | null
  completedBySelf: Prisma.Decimal | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Subscribes
 * 
 */
export type Subscribes = {
  id: number
  AccountId: number
  fcmToken: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TaskDetailResources
 * 
 */
export type TaskDetailResources = {
  id: number
  content: string | null
  type: string | null
  createdAt: Date
  updatedAt: Date
  TaskDetailId: number | null
  AccountId: number | null
  group: string | null
}

/**
 * Model TaskDetails
 * 
 */
export type TaskDetails = {
  id: number
  AccountId: number | null
  TaskId: number | null
  type: string | null
  address: string | null
  villageName: string | null
  pushUser: string | null
  category: string | null
  etc: string | null
  status: string | null
  geometry: Prisma.JsonValue | null
  createdAt: Date
  updatedAt: Date
  assignedDays: number | null
  assignedUser: string | null
  TeamId: number | null
  y: string | null
  x: string | null
  area: Prisma.Decimal | null
  pushPhone: string | null
  startedAt: Date | null
  endedAt: Date | null
  memo: string | null
  extra: Prisma.JsonValue | null
}

/**
 * Model TaskGroups
 * 
 */
export type TaskGroups = {
  id: number
  path: string | null
  name: string | null
  status: string | null
  AccountId: number | null
  createdAt: Date
  updatedAt: Date
  area: Prisma.Decimal | null
  createType: string | null
  extra: Prisma.JsonValue | null
}

/**
 * Model Tasks
 * 
 */
export type Tasks = {
  id: number
  name: string | null
  status: string | null
  AccountId: number | null
  createdAt: Date
  updatedAt: Date
  workingDays: number | null
  workingTeamsCnt: number | null
  TaskGroupId: number | null
  startDate: Date | null
  endDate: Date | null
  area: Prisma.Decimal | null
  isPaid: boolean | null
  createType: string | null
  extra: Prisma.JsonValue | null
  real_area: Prisma.Decimal | null
}

/**
 * Model TeamAgents
 * 
 */
export type TeamAgents = {
  AgentId: number
  TeamId: number
  isActive: boolean | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Teams
 * 
 */
export type Teams = {
  id: number
  name: string | null
  AccountId: number | null
  AgentId: number | null
  TaskId: number | null
  createdAt: Date
  updatedAt: Date
  status: string | null
  area: Prisma.Decimal | null
  alias: string | null
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const enum_Permissions_key: {
  read: 'read',
  create: 'create',
  update: 'update',
  delete: 'delete'
};

export type enum_Permissions_key = (typeof enum_Permissions_key)[keyof typeof enum_Permissions_key]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.accounts.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.accounts.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.accounts`: Exposes CRUD operations for the **Accounts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.accounts.findMany()
    * ```
    */
  get accounts(): Prisma.AccountsDelegate<GlobalReject>;

  /**
   * `prisma.alerts`: Exposes CRUD operations for the **Alerts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alerts
    * const alerts = await prisma.alerts.findMany()
    * ```
    */
  get alerts(): Prisma.AlertsDelegate<GlobalReject>;

  /**
   * `prisma.careers`: Exposes CRUD operations for the **Careers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Careers
    * const careers = await prisma.careers.findMany()
    * ```
    */
  get careers(): Prisma.CareersDelegate<GlobalReject>;

  /**
   * `prisma.coupons`: Exposes CRUD operations for the **Coupons** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coupons
    * const coupons = await prisma.coupons.findMany()
    * ```
    */
  get coupons(): Prisma.CouponsDelegate<GlobalReject>;

  /**
   * `prisma.customerTaskDetails`: Exposes CRUD operations for the **CustomerTaskDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerTaskDetails
    * const customerTaskDetails = await prisma.customerTaskDetails.findMany()
    * ```
    */
  get customerTaskDetails(): Prisma.CustomerTaskDetailsDelegate<GlobalReject>;

  /**
   * `prisma.customers`: Exposes CRUD operations for the **Customers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customers.findMany()
    * ```
    */
  get customers(): Prisma.CustomersDelegate<GlobalReject>;

  /**
   * `prisma.discounts`: Exposes CRUD operations for the **Discounts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Discounts
    * const discounts = await prisma.discounts.findMany()
    * ```
    */
  get discounts(): Prisma.DiscountsDelegate<GlobalReject>;

  /**
   * `prisma.events`: Exposes CRUD operations for the **Events** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.events.findMany()
    * ```
    */
  get events(): Prisma.EventsDelegate<GlobalReject>;

  /**
   * `prisma.geos`: Exposes CRUD operations for the **Geos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Geos
    * const geos = await prisma.geos.findMany()
    * ```
    */
  get geos(): Prisma.GeosDelegate<GlobalReject>;

  /**
   * `prisma.lands`: Exposes CRUD operations for the **Lands** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lands
    * const lands = await prisma.lands.findMany()
    * ```
    */
  get lands(): Prisma.LandsDelegate<GlobalReject>;

  /**
   * `prisma.notices`: Exposes CRUD operations for the **Notices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notices
    * const notices = await prisma.notices.findMany()
    * ```
    */
  get notices(): Prisma.NoticesDelegate<GlobalReject>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **Notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.NotificationsDelegate<GlobalReject>;

  /**
   * `prisma.orderHistories`: Exposes CRUD operations for the **OrderHistories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderHistories
    * const orderHistories = await prisma.orderHistories.findMany()
    * ```
    */
  get orderHistories(): Prisma.OrderHistoriesDelegate<GlobalReject>;

  /**
   * `prisma.orders`: Exposes CRUD operations for the **Orders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.orders.findMany()
    * ```
    */
  get orders(): Prisma.OrdersDelegate<GlobalReject>;

  /**
   * `prisma.permissions`: Exposes CRUD operations for the **Permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permissions.findMany()
    * ```
    */
  get permissions(): Prisma.PermissionsDelegate<GlobalReject>;

  /**
   * `prisma.postAccounts`: Exposes CRUD operations for the **PostAccounts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostAccounts
    * const postAccounts = await prisma.postAccounts.findMany()
    * ```
    */
  get postAccounts(): Prisma.PostAccountsDelegate<GlobalReject>;

  /**
   * `prisma.posts`: Exposes CRUD operations for the **Posts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.posts.findMany()
    * ```
    */
  get posts(): Prisma.PostsDelegate<GlobalReject>;

  /**
   * `prisma.products`: Exposes CRUD operations for the **Products** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.products.findMany()
    * ```
    */
  get products(): Prisma.ProductsDelegate<GlobalReject>;

  /**
   * `prisma.reports`: Exposes CRUD operations for the **Reports** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.reports.findMany()
    * ```
    */
  get reports(): Prisma.ReportsDelegate<GlobalReject>;

  /**
   * `prisma.sequelizeMeta`: Exposes CRUD operations for the **SequelizeMeta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SequelizeMetas
    * const sequelizeMetas = await prisma.sequelizeMeta.findMany()
    * ```
    */
  get sequelizeMeta(): Prisma.SequelizeMetaDelegate<GlobalReject>;

  /**
   * `prisma.services`: Exposes CRUD operations for the **Services** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.services.findMany()
    * ```
    */
  get services(): Prisma.ServicesDelegate<GlobalReject>;

  /**
   * `prisma.statistics`: Exposes CRUD operations for the **Statistics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Statistics
    * const statistics = await prisma.statistics.findMany()
    * ```
    */
  get statistics(): Prisma.StatisticsDelegate<GlobalReject>;

  /**
   * `prisma.subscribes`: Exposes CRUD operations for the **Subscribes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscribes
    * const subscribes = await prisma.subscribes.findMany()
    * ```
    */
  get subscribes(): Prisma.SubscribesDelegate<GlobalReject>;

  /**
   * `prisma.taskDetailResources`: Exposes CRUD operations for the **TaskDetailResources** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskDetailResources
    * const taskDetailResources = await prisma.taskDetailResources.findMany()
    * ```
    */
  get taskDetailResources(): Prisma.TaskDetailResourcesDelegate<GlobalReject>;

  /**
   * `prisma.taskDetails`: Exposes CRUD operations for the **TaskDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskDetails
    * const taskDetails = await prisma.taskDetails.findMany()
    * ```
    */
  get taskDetails(): Prisma.TaskDetailsDelegate<GlobalReject>;

  /**
   * `prisma.taskGroups`: Exposes CRUD operations for the **TaskGroups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskGroups
    * const taskGroups = await prisma.taskGroups.findMany()
    * ```
    */
  get taskGroups(): Prisma.TaskGroupsDelegate<GlobalReject>;

  /**
   * `prisma.tasks`: Exposes CRUD operations for the **Tasks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.tasks.findMany()
    * ```
    */
  get tasks(): Prisma.TasksDelegate<GlobalReject>;

  /**
   * `prisma.teamAgents`: Exposes CRUD operations for the **TeamAgents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamAgents
    * const teamAgents = await prisma.teamAgents.findMany()
    * ```
    */
  get teamAgents(): Prisma.TeamAgentsDelegate<GlobalReject>;

  /**
   * `prisma.teams`: Exposes CRUD operations for the **Teams** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.teams.findMany()
    * ```
    */
  get teams(): Prisma.TeamsDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export import Metrics = runtime.Metrics
  export import Metric = runtime.Metric
  export import MetricHistogram = runtime.MetricHistogram
  export import MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
   * Extensions
   */
  export type Extension = runtime.Extension 

  /**
   * Prisma Client JS version: 4.5.0
   * Query Engine version: 0362da9eebca54d94c8ef5edd3b2e90af99ba452
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export import FieldRef = runtime.FieldRef

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Accounts: 'Accounts',
    Alerts: 'Alerts',
    Careers: 'Careers',
    Coupons: 'Coupons',
    CustomerTaskDetails: 'CustomerTaskDetails',
    Customers: 'Customers',
    Discounts: 'Discounts',
    Events: 'Events',
    Geos: 'Geos',
    Lands: 'Lands',
    Notices: 'Notices',
    Notifications: 'Notifications',
    OrderHistories: 'OrderHistories',
    Orders: 'Orders',
    Permissions: 'Permissions',
    PostAccounts: 'PostAccounts',
    Posts: 'Posts',
    Products: 'Products',
    Reports: 'Reports',
    SequelizeMeta: 'SequelizeMeta',
    Services: 'Services',
    Statistics: 'Statistics',
    Subscribes: 'Subscribes',
    TaskDetailResources: 'TaskDetailResources',
    TaskDetails: 'TaskDetails',
    TaskGroups: 'TaskGroups',
    Tasks: 'Tasks',
    TeamAgents: 'TeamAgents',
    Teams: 'Teams'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AccountsCountOutputType
   */


  export type AccountsCountOutputType = {
    Alerts: number
    Careers: number
    CustomerTaskDetails: number
    Customers: number
    Discounts: number
    Lands: number
    Notifications: number
    OrderHistories: number
    Orders: number
    Permissions: number
    PostAccounts: number
    Posts: number
    Reports: number
    Statistics: number
    Subscribes: number
    TaskDetailResources: number
    TaskDetails: number
    TaskGroups: number
    Tasks: number
    TeamAgents: number
    Teams_AccountsToTeams_AccountId: number
    Teams_AccountsToTeams_AgentId: number
  }

  export type AccountsCountOutputTypeSelect = {
    Alerts?: boolean
    Careers?: boolean
    CustomerTaskDetails?: boolean
    Customers?: boolean
    Discounts?: boolean
    Lands?: boolean
    Notifications?: boolean
    OrderHistories?: boolean
    Orders?: boolean
    Permissions?: boolean
    PostAccounts?: boolean
    Posts?: boolean
    Reports?: boolean
    Statistics?: boolean
    Subscribes?: boolean
    TaskDetailResources?: boolean
    TaskDetails?: boolean
    TaskGroups?: boolean
    Tasks?: boolean
    TeamAgents?: boolean
    Teams_AccountsToTeams_AccountId?: boolean
    Teams_AccountsToTeams_AgentId?: boolean
  }

  export type AccountsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | AccountsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? AccountsCountOutputType
    : S extends undefined
    ? never
    : S extends AccountsCountOutputTypeArgs
    ?'include' extends U
    ? AccountsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof AccountsCountOutputType ? AccountsCountOutputType[P] : never
  } 
    : AccountsCountOutputType
  : AccountsCountOutputType




  // Custom InputTypes

  /**
   * AccountsCountOutputType without action
   */
  export type AccountsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AccountsCountOutputType
     * 
    **/
    select?: AccountsCountOutputTypeSelect | null
  }



  /**
   * Count Type CouponsCountOutputType
   */


  export type CouponsCountOutputType = {
    Discounts: number
  }

  export type CouponsCountOutputTypeSelect = {
    Discounts?: boolean
  }

  export type CouponsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CouponsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CouponsCountOutputType
    : S extends undefined
    ? never
    : S extends CouponsCountOutputTypeArgs
    ?'include' extends U
    ? CouponsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CouponsCountOutputType ? CouponsCountOutputType[P] : never
  } 
    : CouponsCountOutputType
  : CouponsCountOutputType




  // Custom InputTypes

  /**
   * CouponsCountOutputType without action
   */
  export type CouponsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CouponsCountOutputType
     * 
    **/
    select?: CouponsCountOutputTypeSelect | null
  }



  /**
   * Count Type CustomersCountOutputType
   */


  export type CustomersCountOutputType = {
    CustomerTaskDetails: number
  }

  export type CustomersCountOutputTypeSelect = {
    CustomerTaskDetails?: boolean
  }

  export type CustomersCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CustomersCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CustomersCountOutputType
    : S extends undefined
    ? never
    : S extends CustomersCountOutputTypeArgs
    ?'include' extends U
    ? CustomersCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CustomersCountOutputType ? CustomersCountOutputType[P] : never
  } 
    : CustomersCountOutputType
  : CustomersCountOutputType




  // Custom InputTypes

  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CustomersCountOutputType
     * 
    **/
    select?: CustomersCountOutputTypeSelect | null
  }



  /**
   * Count Type OrdersCountOutputType
   */


  export type OrdersCountOutputType = {
    Discounts: number
    OrderHistories: number
  }

  export type OrdersCountOutputTypeSelect = {
    Discounts?: boolean
    OrderHistories?: boolean
  }

  export type OrdersCountOutputTypeGetPayload<
    S extends boolean | null | undefined | OrdersCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? OrdersCountOutputType
    : S extends undefined
    ? never
    : S extends OrdersCountOutputTypeArgs
    ?'include' extends U
    ? OrdersCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof OrdersCountOutputType ? OrdersCountOutputType[P] : never
  } 
    : OrdersCountOutputType
  : OrdersCountOutputType




  // Custom InputTypes

  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OrdersCountOutputType
     * 
    **/
    select?: OrdersCountOutputTypeSelect | null
  }



  /**
   * Count Type PostsCountOutputType
   */


  export type PostsCountOutputType = {
    PostAccounts: number
  }

  export type PostsCountOutputTypeSelect = {
    PostAccounts?: boolean
  }

  export type PostsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PostsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PostsCountOutputType
    : S extends undefined
    ? never
    : S extends PostsCountOutputTypeArgs
    ?'include' extends U
    ? PostsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PostsCountOutputType ? PostsCountOutputType[P] : never
  } 
    : PostsCountOutputType
  : PostsCountOutputType




  // Custom InputTypes

  /**
   * PostsCountOutputType without action
   */
  export type PostsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PostsCountOutputType
     * 
    **/
    select?: PostsCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductsCountOutputType
   */


  export type ProductsCountOutputType = {
    Discounts: number
    OrderHistories: number
    Orders: number
  }

  export type ProductsCountOutputTypeSelect = {
    Discounts?: boolean
    OrderHistories?: boolean
    Orders?: boolean
  }

  export type ProductsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProductsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProductsCountOutputType
    : S extends undefined
    ? never
    : S extends ProductsCountOutputTypeArgs
    ?'include' extends U
    ? ProductsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ProductsCountOutputType ? ProductsCountOutputType[P] : never
  } 
    : ProductsCountOutputType
  : ProductsCountOutputType




  // Custom InputTypes

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductsCountOutputType
     * 
    **/
    select?: ProductsCountOutputTypeSelect | null
  }



  /**
   * Count Type ServicesCountOutputType
   */


  export type ServicesCountOutputType = {
    Accounts: number
  }

  export type ServicesCountOutputTypeSelect = {
    Accounts?: boolean
  }

  export type ServicesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ServicesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ServicesCountOutputType
    : S extends undefined
    ? never
    : S extends ServicesCountOutputTypeArgs
    ?'include' extends U
    ? ServicesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ServicesCountOutputType ? ServicesCountOutputType[P] : never
  } 
    : ServicesCountOutputType
  : ServicesCountOutputType




  // Custom InputTypes

  /**
   * ServicesCountOutputType without action
   */
  export type ServicesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ServicesCountOutputType
     * 
    **/
    select?: ServicesCountOutputTypeSelect | null
  }



  /**
   * Count Type TaskDetailsCountOutputType
   */


  export type TaskDetailsCountOutputType = {
    TaskDetailResources: number
  }

  export type TaskDetailsCountOutputTypeSelect = {
    TaskDetailResources?: boolean
  }

  export type TaskDetailsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | TaskDetailsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? TaskDetailsCountOutputType
    : S extends undefined
    ? never
    : S extends TaskDetailsCountOutputTypeArgs
    ?'include' extends U
    ? TaskDetailsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof TaskDetailsCountOutputType ? TaskDetailsCountOutputType[P] : never
  } 
    : TaskDetailsCountOutputType
  : TaskDetailsCountOutputType




  // Custom InputTypes

  /**
   * TaskDetailsCountOutputType without action
   */
  export type TaskDetailsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TaskDetailsCountOutputType
     * 
    **/
    select?: TaskDetailsCountOutputTypeSelect | null
  }



  /**
   * Count Type TaskGroupsCountOutputType
   */


  export type TaskGroupsCountOutputType = {
    Tasks: number
  }

  export type TaskGroupsCountOutputTypeSelect = {
    Tasks?: boolean
  }

  export type TaskGroupsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | TaskGroupsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? TaskGroupsCountOutputType
    : S extends undefined
    ? never
    : S extends TaskGroupsCountOutputTypeArgs
    ?'include' extends U
    ? TaskGroupsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof TaskGroupsCountOutputType ? TaskGroupsCountOutputType[P] : never
  } 
    : TaskGroupsCountOutputType
  : TaskGroupsCountOutputType




  // Custom InputTypes

  /**
   * TaskGroupsCountOutputType without action
   */
  export type TaskGroupsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TaskGroupsCountOutputType
     * 
    **/
    select?: TaskGroupsCountOutputTypeSelect | null
  }



  /**
   * Count Type TasksCountOutputType
   */


  export type TasksCountOutputType = {
    Reports: number
    Statistics: number
    TaskDetails: number
    Teams: number
  }

  export type TasksCountOutputTypeSelect = {
    Reports?: boolean
    Statistics?: boolean
    TaskDetails?: boolean
    Teams?: boolean
  }

  export type TasksCountOutputTypeGetPayload<
    S extends boolean | null | undefined | TasksCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? TasksCountOutputType
    : S extends undefined
    ? never
    : S extends TasksCountOutputTypeArgs
    ?'include' extends U
    ? TasksCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof TasksCountOutputType ? TasksCountOutputType[P] : never
  } 
    : TasksCountOutputType
  : TasksCountOutputType




  // Custom InputTypes

  /**
   * TasksCountOutputType without action
   */
  export type TasksCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TasksCountOutputType
     * 
    **/
    select?: TasksCountOutputTypeSelect | null
  }



  /**
   * Count Type TeamsCountOutputType
   */


  export type TeamsCountOutputType = {
    Statistics: number
    TaskDetails: number
    TeamAgents: number
  }

  export type TeamsCountOutputTypeSelect = {
    Statistics?: boolean
    TaskDetails?: boolean
    TeamAgents?: boolean
  }

  export type TeamsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | TeamsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? TeamsCountOutputType
    : S extends undefined
    ? never
    : S extends TeamsCountOutputTypeArgs
    ?'include' extends U
    ? TeamsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof TeamsCountOutputType ? TeamsCountOutputType[P] : never
  } 
    : TeamsCountOutputType
  : TeamsCountOutputType




  // Custom InputTypes

  /**
   * TeamsCountOutputType without action
   */
  export type TeamsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TeamsCountOutputType
     * 
    **/
    select?: TeamsCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Accounts
   */


  export type AggregateAccounts = {
    _count: AccountsCountAggregateOutputType | null
    _avg: AccountsAvgAggregateOutputType | null
    _sum: AccountsSumAggregateOutputType | null
    _min: AccountsMinAggregateOutputType | null
    _max: AccountsMaxAggregateOutputType | null
  }

  export type AccountsAvgAggregateOutputType = {
    id: number | null
    verifyToken: number | null
  }

  export type AccountsSumAggregateOutputType = {
    id: number | null
    verifyToken: number | null
  }

  export type AccountsMinAggregateOutputType = {
    id: number | null
    phone: string | null
    verifyToken: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isAdmin: boolean | null
    email: string | null
    password: string | null
    name: string | null
    isVerify: boolean | null
    isApprove: boolean | null
    ServiceKey: string | null
  }

  export type AccountsMaxAggregateOutputType = {
    id: number | null
    phone: string | null
    verifyToken: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isAdmin: boolean | null
    email: string | null
    password: string | null
    name: string | null
    isVerify: boolean | null
    isApprove: boolean | null
    ServiceKey: string | null
  }

  export type AccountsCountAggregateOutputType = {
    id: number
    phone: number
    verifyToken: number
    createdAt: number
    updatedAt: number
    profile: number
    isAdmin: number
    email: number
    password: number
    name: number
    isVerify: number
    isApprove: number
    ServiceKey: number
    _all: number
  }


  export type AccountsAvgAggregateInputType = {
    id?: true
    verifyToken?: true
  }

  export type AccountsSumAggregateInputType = {
    id?: true
    verifyToken?: true
  }

  export type AccountsMinAggregateInputType = {
    id?: true
    phone?: true
    verifyToken?: true
    createdAt?: true
    updatedAt?: true
    isAdmin?: true
    email?: true
    password?: true
    name?: true
    isVerify?: true
    isApprove?: true
    ServiceKey?: true
  }

  export type AccountsMaxAggregateInputType = {
    id?: true
    phone?: true
    verifyToken?: true
    createdAt?: true
    updatedAt?: true
    isAdmin?: true
    email?: true
    password?: true
    name?: true
    isVerify?: true
    isApprove?: true
    ServiceKey?: true
  }

  export type AccountsCountAggregateInputType = {
    id?: true
    phone?: true
    verifyToken?: true
    createdAt?: true
    updatedAt?: true
    profile?: true
    isAdmin?: true
    email?: true
    password?: true
    name?: true
    isVerify?: true
    isApprove?: true
    ServiceKey?: true
    _all?: true
  }

  export type AccountsAggregateArgs = {
    /**
     * Filter which Accounts to aggregate.
     * 
    **/
    where?: AccountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AccountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountsMaxAggregateInputType
  }

  export type GetAccountsAggregateType<T extends AccountsAggregateArgs> = {
        [P in keyof T & keyof AggregateAccounts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccounts[P]>
      : GetScalarType<T[P], AggregateAccounts[P]>
  }




  export type AccountsGroupByArgs = {
    where?: AccountsWhereInput
    orderBy?: Enumerable<AccountsOrderByWithAggregationInput>
    by: Array<AccountsScalarFieldEnum>
    having?: AccountsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountsCountAggregateInputType | true
    _avg?: AccountsAvgAggregateInputType
    _sum?: AccountsSumAggregateInputType
    _min?: AccountsMinAggregateInputType
    _max?: AccountsMaxAggregateInputType
  }


  export type AccountsGroupByOutputType = {
    id: number
    phone: string | null
    verifyToken: number | null
    createdAt: Date
    updatedAt: Date
    profile: JsonValue | null
    isAdmin: boolean | null
    email: string | null
    password: string | null
    name: string | null
    isVerify: boolean | null
    isApprove: boolean | null
    ServiceKey: string | null
    _count: AccountsCountAggregateOutputType | null
    _avg: AccountsAvgAggregateOutputType | null
    _sum: AccountsSumAggregateOutputType | null
    _min: AccountsMinAggregateOutputType | null
    _max: AccountsMaxAggregateOutputType | null
  }

  type GetAccountsGroupByPayload<T extends AccountsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AccountsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountsGroupByOutputType[P]>
            : GetScalarType<T[P], AccountsGroupByOutputType[P]>
        }
      >
    >


  export type AccountsSelect = {
    id?: boolean
    phone?: boolean
    verifyToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean
    isAdmin?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    isVerify?: boolean
    isApprove?: boolean
    ServiceKey?: boolean
    Services?: boolean | ServicesArgs
    Alerts?: boolean | AlertsFindManyArgs
    Careers?: boolean | CareersFindManyArgs
    CustomerTaskDetails?: boolean | CustomerTaskDetailsFindManyArgs
    Customers?: boolean | CustomersFindManyArgs
    Discounts?: boolean | DiscountsFindManyArgs
    Lands?: boolean | LandsFindManyArgs
    Notifications?: boolean | NotificationsFindManyArgs
    OrderHistories?: boolean | OrderHistoriesFindManyArgs
    Orders?: boolean | OrdersFindManyArgs
    Permissions?: boolean | PermissionsFindManyArgs
    PostAccounts?: boolean | PostAccountsFindManyArgs
    Posts?: boolean | PostsFindManyArgs
    Reports?: boolean | ReportsFindManyArgs
    Statistics?: boolean | StatisticsFindManyArgs
    Subscribes?: boolean | SubscribesFindManyArgs
    TaskDetailResources?: boolean | TaskDetailResourcesFindManyArgs
    TaskDetails?: boolean | TaskDetailsFindManyArgs
    TaskGroups?: boolean | TaskGroupsFindManyArgs
    Tasks?: boolean | TasksFindManyArgs
    TeamAgents?: boolean | TeamAgentsFindManyArgs
    Teams_AccountsToTeams_AccountId?: boolean | TeamsFindManyArgs
    Teams_AccountsToTeams_AgentId?: boolean | TeamsFindManyArgs
    _count?: boolean | AccountsCountOutputTypeArgs
  }

  export type AccountsInclude = {
    Services?: boolean | ServicesArgs
    Alerts?: boolean | AlertsFindManyArgs
    Careers?: boolean | CareersFindManyArgs
    CustomerTaskDetails?: boolean | CustomerTaskDetailsFindManyArgs
    Customers?: boolean | CustomersFindManyArgs
    Discounts?: boolean | DiscountsFindManyArgs
    Lands?: boolean | LandsFindManyArgs
    Notifications?: boolean | NotificationsFindManyArgs
    OrderHistories?: boolean | OrderHistoriesFindManyArgs
    Orders?: boolean | OrdersFindManyArgs
    Permissions?: boolean | PermissionsFindManyArgs
    PostAccounts?: boolean | PostAccountsFindManyArgs
    Posts?: boolean | PostsFindManyArgs
    Reports?: boolean | ReportsFindManyArgs
    Statistics?: boolean | StatisticsFindManyArgs
    Subscribes?: boolean | SubscribesFindManyArgs
    TaskDetailResources?: boolean | TaskDetailResourcesFindManyArgs
    TaskDetails?: boolean | TaskDetailsFindManyArgs
    TaskGroups?: boolean | TaskGroupsFindManyArgs
    Tasks?: boolean | TasksFindManyArgs
    TeamAgents?: boolean | TeamAgentsFindManyArgs
    Teams_AccountsToTeams_AccountId?: boolean | TeamsFindManyArgs
    Teams_AccountsToTeams_AgentId?: boolean | TeamsFindManyArgs
    _count?: boolean | AccountsCountOutputTypeArgs
  }

  export type AccountsGetPayload<
    S extends boolean | null | undefined | AccountsArgs,
    U = keyof S
      > = S extends true
        ? Accounts
    : S extends undefined
    ? never
    : S extends AccountsArgs | AccountsFindManyArgs
    ?'include' extends U
    ? Accounts  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Services' ? ServicesGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'Alerts' ? Array < AlertsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Careers' ? Array < CareersGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'CustomerTaskDetails' ? Array < CustomerTaskDetailsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Customers' ? Array < CustomersGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Discounts' ? Array < DiscountsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Lands' ? Array < LandsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Notifications' ? Array < NotificationsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'OrderHistories' ? Array < OrderHistoriesGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Orders' ? Array < OrdersGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Permissions' ? Array < PermissionsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'PostAccounts' ? Array < PostAccountsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Posts' ? Array < PostsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Reports' ? Array < ReportsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Statistics' ? Array < StatisticsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Subscribes' ? Array < SubscribesGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'TaskDetailResources' ? Array < TaskDetailResourcesGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'TaskDetails' ? Array < TaskDetailsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'TaskGroups' ? Array < TaskGroupsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Tasks' ? Array < TasksGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'TeamAgents' ? Array < TeamAgentsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Teams_AccountsToTeams_AccountId' ? Array < TeamsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Teams_AccountsToTeams_AgentId' ? Array < TeamsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? AccountsCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Services' ? ServicesGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'Alerts' ? Array < AlertsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Careers' ? Array < CareersGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'CustomerTaskDetails' ? Array < CustomerTaskDetailsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Customers' ? Array < CustomersGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Discounts' ? Array < DiscountsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Lands' ? Array < LandsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Notifications' ? Array < NotificationsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'OrderHistories' ? Array < OrderHistoriesGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Orders' ? Array < OrdersGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Permissions' ? Array < PermissionsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'PostAccounts' ? Array < PostAccountsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Posts' ? Array < PostsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Reports' ? Array < ReportsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Statistics' ? Array < StatisticsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Subscribes' ? Array < SubscribesGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'TaskDetailResources' ? Array < TaskDetailResourcesGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'TaskDetails' ? Array < TaskDetailsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'TaskGroups' ? Array < TaskGroupsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Tasks' ? Array < TasksGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'TeamAgents' ? Array < TeamAgentsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Teams_AccountsToTeams_AccountId' ? Array < TeamsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Teams_AccountsToTeams_AgentId' ? Array < TeamsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? AccountsCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Accounts ? Accounts[P] : never
  } 
    : Accounts
  : Accounts


  type AccountsCountArgs = Merge<
    Omit<AccountsFindManyArgs, 'select' | 'include'> & {
      select?: AccountsCountAggregateInputType | true
    }
  >

  export interface AccountsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Accounts that matches the filter.
     * @param {AccountsFindUniqueArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AccountsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Accounts'> extends True ? CheckSelect<T, Prisma__AccountsClient<Accounts>, Prisma__AccountsClient<AccountsGetPayload<T>>> : CheckSelect<T, Prisma__AccountsClient<Accounts | null, null>, Prisma__AccountsClient<AccountsGetPayload<T> | null, null>>

    /**
     * Find the first Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountsFindFirstArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AccountsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Accounts'> extends True ? CheckSelect<T, Prisma__AccountsClient<Accounts>, Prisma__AccountsClient<AccountsGetPayload<T>>> : CheckSelect<T, Prisma__AccountsClient<Accounts | null, null>, Prisma__AccountsClient<AccountsGetPayload<T> | null, null>>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.accounts.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.accounts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountsWithIdOnly = await prisma.accounts.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountsFindManyArgs>(
      args?: SelectSubset<T, AccountsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Accounts>>, PrismaPromise<Array<AccountsGetPayload<T>>>>

    /**
     * Create a Accounts.
     * @param {AccountsCreateArgs} args - Arguments to create a Accounts.
     * @example
     * // Create one Accounts
     * const Accounts = await prisma.accounts.create({
     *   data: {
     *     // ... data to create a Accounts
     *   }
     * })
     * 
    **/
    create<T extends AccountsCreateArgs>(
      args: SelectSubset<T, AccountsCreateArgs>
    ): CheckSelect<T, Prisma__AccountsClient<Accounts>, Prisma__AccountsClient<AccountsGetPayload<T>>>

    /**
     * Create many Accounts.
     *     @param {AccountsCreateManyArgs} args - Arguments to create many Accounts.
     *     @example
     *     // Create many Accounts
     *     const accounts = await prisma.accounts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountsCreateManyArgs>(
      args?: SelectSubset<T, AccountsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Accounts.
     * @param {AccountsDeleteArgs} args - Arguments to delete one Accounts.
     * @example
     * // Delete one Accounts
     * const Accounts = await prisma.accounts.delete({
     *   where: {
     *     // ... filter to delete one Accounts
     *   }
     * })
     * 
    **/
    delete<T extends AccountsDeleteArgs>(
      args: SelectSubset<T, AccountsDeleteArgs>
    ): CheckSelect<T, Prisma__AccountsClient<Accounts>, Prisma__AccountsClient<AccountsGetPayload<T>>>

    /**
     * Update one Accounts.
     * @param {AccountsUpdateArgs} args - Arguments to update one Accounts.
     * @example
     * // Update one Accounts
     * const accounts = await prisma.accounts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountsUpdateArgs>(
      args: SelectSubset<T, AccountsUpdateArgs>
    ): CheckSelect<T, Prisma__AccountsClient<Accounts>, Prisma__AccountsClient<AccountsGetPayload<T>>>

    /**
     * Delete zero or more Accounts.
     * @param {AccountsDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.accounts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountsDeleteManyArgs>(
      args?: SelectSubset<T, AccountsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const accounts = await prisma.accounts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountsUpdateManyArgs>(
      args: SelectSubset<T, AccountsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Accounts.
     * @param {AccountsUpsertArgs} args - Arguments to update or create a Accounts.
     * @example
     * // Update or create a Accounts
     * const accounts = await prisma.accounts.upsert({
     *   create: {
     *     // ... data to create a Accounts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Accounts we want to update
     *   }
     * })
    **/
    upsert<T extends AccountsUpsertArgs>(
      args: SelectSubset<T, AccountsUpsertArgs>
    ): CheckSelect<T, Prisma__AccountsClient<Accounts>, Prisma__AccountsClient<AccountsGetPayload<T>>>

    /**
     * Find one Accounts that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {AccountsFindUniqueOrThrowArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AccountsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountsClient<Accounts>, Prisma__AccountsClient<AccountsGetPayload<T>>>

    /**
     * Find the first Accounts that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountsFindFirstOrThrowArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AccountsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountsClient<Accounts>, Prisma__AccountsClient<AccountsGetPayload<T>>>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountsCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.accounts.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountsCountArgs>(
      args?: Subset<T, AccountsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountsAggregateArgs>(args: Subset<T, AccountsAggregateArgs>): PrismaPromise<GetAccountsAggregateType<T>>

    /**
     * Group by Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountsGroupByArgs['orderBy'] }
        : { orderBy?: AccountsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Accounts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AccountsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Services<T extends ServicesArgs = {}>(args?: Subset<T, ServicesArgs>): CheckSelect<T, Prisma__ServicesClient<Services | Null>, Prisma__ServicesClient<ServicesGetPayload<T> | Null>>;

    Alerts<T extends AlertsFindManyArgs = {}>(args?: Subset<T, AlertsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Alerts>| Null>, PrismaPromise<Array<AlertsGetPayload<T>>| Null>>;

    Careers<T extends CareersFindManyArgs = {}>(args?: Subset<T, CareersFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Careers>| Null>, PrismaPromise<Array<CareersGetPayload<T>>| Null>>;

    CustomerTaskDetails<T extends CustomerTaskDetailsFindManyArgs = {}>(args?: Subset<T, CustomerTaskDetailsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CustomerTaskDetails>| Null>, PrismaPromise<Array<CustomerTaskDetailsGetPayload<T>>| Null>>;

    Customers<T extends CustomersFindManyArgs = {}>(args?: Subset<T, CustomersFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Customers>| Null>, PrismaPromise<Array<CustomersGetPayload<T>>| Null>>;

    Discounts<T extends DiscountsFindManyArgs = {}>(args?: Subset<T, DiscountsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Discounts>| Null>, PrismaPromise<Array<DiscountsGetPayload<T>>| Null>>;

    Lands<T extends LandsFindManyArgs = {}>(args?: Subset<T, LandsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Lands>| Null>, PrismaPromise<Array<LandsGetPayload<T>>| Null>>;

    Notifications<T extends NotificationsFindManyArgs = {}>(args?: Subset<T, NotificationsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Notifications>| Null>, PrismaPromise<Array<NotificationsGetPayload<T>>| Null>>;

    OrderHistories<T extends OrderHistoriesFindManyArgs = {}>(args?: Subset<T, OrderHistoriesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OrderHistories>| Null>, PrismaPromise<Array<OrderHistoriesGetPayload<T>>| Null>>;

    Orders<T extends OrdersFindManyArgs = {}>(args?: Subset<T, OrdersFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Orders>| Null>, PrismaPromise<Array<OrdersGetPayload<T>>| Null>>;

    Permissions<T extends PermissionsFindManyArgs = {}>(args?: Subset<T, PermissionsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Permissions>| Null>, PrismaPromise<Array<PermissionsGetPayload<T>>| Null>>;

    PostAccounts<T extends PostAccountsFindManyArgs = {}>(args?: Subset<T, PostAccountsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PostAccounts>| Null>, PrismaPromise<Array<PostAccountsGetPayload<T>>| Null>>;

    Posts<T extends PostsFindManyArgs = {}>(args?: Subset<T, PostsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Posts>| Null>, PrismaPromise<Array<PostsGetPayload<T>>| Null>>;

    Reports<T extends ReportsFindManyArgs = {}>(args?: Subset<T, ReportsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Reports>| Null>, PrismaPromise<Array<ReportsGetPayload<T>>| Null>>;

    Statistics<T extends StatisticsFindManyArgs = {}>(args?: Subset<T, StatisticsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Statistics>| Null>, PrismaPromise<Array<StatisticsGetPayload<T>>| Null>>;

    Subscribes<T extends SubscribesFindManyArgs = {}>(args?: Subset<T, SubscribesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Subscribes>| Null>, PrismaPromise<Array<SubscribesGetPayload<T>>| Null>>;

    TaskDetailResources<T extends TaskDetailResourcesFindManyArgs = {}>(args?: Subset<T, TaskDetailResourcesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<TaskDetailResources>| Null>, PrismaPromise<Array<TaskDetailResourcesGetPayload<T>>| Null>>;

    TaskDetails<T extends TaskDetailsFindManyArgs = {}>(args?: Subset<T, TaskDetailsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<TaskDetails>| Null>, PrismaPromise<Array<TaskDetailsGetPayload<T>>| Null>>;

    TaskGroups<T extends TaskGroupsFindManyArgs = {}>(args?: Subset<T, TaskGroupsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<TaskGroups>| Null>, PrismaPromise<Array<TaskGroupsGetPayload<T>>| Null>>;

    Tasks<T extends TasksFindManyArgs = {}>(args?: Subset<T, TasksFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Tasks>| Null>, PrismaPromise<Array<TasksGetPayload<T>>| Null>>;

    TeamAgents<T extends TeamAgentsFindManyArgs = {}>(args?: Subset<T, TeamAgentsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<TeamAgents>| Null>, PrismaPromise<Array<TeamAgentsGetPayload<T>>| Null>>;

    Teams_AccountsToTeams_AccountId<T extends TeamsFindManyArgs = {}>(args?: Subset<T, TeamsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Teams>| Null>, PrismaPromise<Array<TeamsGetPayload<T>>| Null>>;

    Teams_AccountsToTeams_AgentId<T extends TeamsFindManyArgs = {}>(args?: Subset<T, TeamsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Teams>| Null>, PrismaPromise<Array<TeamsGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Accounts base type for findUnique actions
   */
  export type AccountsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Accounts
     * 
    **/
    select?: AccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountsInclude | null
    /**
     * Filter, which Accounts to fetch.
     * 
    **/
    where: AccountsWhereUniqueInput
  }

  /**
   * Accounts: findUnique
   */
  export interface AccountsFindUniqueArgs extends AccountsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Accounts base type for findFirst actions
   */
  export type AccountsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Accounts
     * 
    **/
    select?: AccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountsInclude | null
    /**
     * Filter, which Accounts to fetch.
     * 
    **/
    where?: AccountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     * 
    **/
    cursor?: AccountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     * 
    **/
    distinct?: Enumerable<AccountsScalarFieldEnum>
  }

  /**
   * Accounts: findFirst
   */
  export interface AccountsFindFirstArgs extends AccountsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Accounts findMany
   */
  export type AccountsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Accounts
     * 
    **/
    select?: AccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountsInclude | null
    /**
     * Filter, which Accounts to fetch.
     * 
    **/
    where?: AccountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     * 
    **/
    cursor?: AccountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AccountsScalarFieldEnum>
  }


  /**
   * Accounts create
   */
  export type AccountsCreateArgs = {
    /**
     * Select specific fields to fetch from the Accounts
     * 
    **/
    select?: AccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountsInclude | null
    /**
     * The data needed to create a Accounts.
     * 
    **/
    data: XOR<AccountsCreateInput, AccountsUncheckedCreateInput>
  }


  /**
   * Accounts createMany
   */
  export type AccountsCreateManyArgs = {
    /**
     * The data used to create many Accounts.
     * 
    **/
    data: Enumerable<AccountsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Accounts update
   */
  export type AccountsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Accounts
     * 
    **/
    select?: AccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountsInclude | null
    /**
     * The data needed to update a Accounts.
     * 
    **/
    data: XOR<AccountsUpdateInput, AccountsUncheckedUpdateInput>
    /**
     * Choose, which Accounts to update.
     * 
    **/
    where: AccountsWhereUniqueInput
  }


  /**
   * Accounts updateMany
   */
  export type AccountsUpdateManyArgs = {
    /**
     * The data used to update Accounts.
     * 
    **/
    data: XOR<AccountsUpdateManyMutationInput, AccountsUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     * 
    **/
    where?: AccountsWhereInput
  }


  /**
   * Accounts upsert
   */
  export type AccountsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Accounts
     * 
    **/
    select?: AccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountsInclude | null
    /**
     * The filter to search for the Accounts to update in case it exists.
     * 
    **/
    where: AccountsWhereUniqueInput
    /**
     * In case the Accounts found by the `where` argument doesn't exist, create a new Accounts with this data.
     * 
    **/
    create: XOR<AccountsCreateInput, AccountsUncheckedCreateInput>
    /**
     * In case the Accounts was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AccountsUpdateInput, AccountsUncheckedUpdateInput>
  }


  /**
   * Accounts delete
   */
  export type AccountsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Accounts
     * 
    **/
    select?: AccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountsInclude | null
    /**
     * Filter which Accounts to delete.
     * 
    **/
    where: AccountsWhereUniqueInput
  }


  /**
   * Accounts deleteMany
   */
  export type AccountsDeleteManyArgs = {
    /**
     * Filter which Accounts to delete
     * 
    **/
    where?: AccountsWhereInput
  }


  /**
   * Accounts: findUniqueOrThrow
   */
  export type AccountsFindUniqueOrThrowArgs = AccountsFindUniqueArgsBase
      

  /**
   * Accounts: findFirstOrThrow
   */
  export type AccountsFindFirstOrThrowArgs = AccountsFindFirstArgsBase
      

  /**
   * Accounts without action
   */
  export type AccountsArgs = {
    /**
     * Select specific fields to fetch from the Accounts
     * 
    **/
    select?: AccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountsInclude | null
  }



  /**
   * Model Alerts
   */


  export type AggregateAlerts = {
    _count: AlertsCountAggregateOutputType | null
    _avg: AlertsAvgAggregateOutputType | null
    _sum: AlertsSumAggregateOutputType | null
    _min: AlertsMinAggregateOutputType | null
    _max: AlertsMaxAggregateOutputType | null
  }

  export type AlertsAvgAggregateOutputType = {
    id: number | null
    AccountId: number | null
    ReferenceId: number | null
  }

  export type AlertsSumAggregateOutputType = {
    id: bigint | null
    AccountId: number | null
    ReferenceId: number | null
  }

  export type AlertsMinAggregateOutputType = {
    id: bigint | null
    title: string | null
    type: string | null
    category: string | null
    AccountId: number | null
    ReferenceId: number | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlertsMaxAggregateOutputType = {
    id: bigint | null
    title: string | null
    type: string | null
    category: string | null
    AccountId: number | null
    ReferenceId: number | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlertsCountAggregateOutputType = {
    id: number
    title: number
    type: number
    category: number
    AccountId: number
    ReferenceId: number
    isRead: number
    createdAt: number
    updatedAt: number
    data: number
    _all: number
  }


  export type AlertsAvgAggregateInputType = {
    id?: true
    AccountId?: true
    ReferenceId?: true
  }

  export type AlertsSumAggregateInputType = {
    id?: true
    AccountId?: true
    ReferenceId?: true
  }

  export type AlertsMinAggregateInputType = {
    id?: true
    title?: true
    type?: true
    category?: true
    AccountId?: true
    ReferenceId?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlertsMaxAggregateInputType = {
    id?: true
    title?: true
    type?: true
    category?: true
    AccountId?: true
    ReferenceId?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlertsCountAggregateInputType = {
    id?: true
    title?: true
    type?: true
    category?: true
    AccountId?: true
    ReferenceId?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    data?: true
    _all?: true
  }

  export type AlertsAggregateArgs = {
    /**
     * Filter which Alerts to aggregate.
     * 
    **/
    where?: AlertsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     * 
    **/
    orderBy?: Enumerable<AlertsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AlertsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alerts
    **/
    _count?: true | AlertsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlertsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlertsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertsMaxAggregateInputType
  }

  export type GetAlertsAggregateType<T extends AlertsAggregateArgs> = {
        [P in keyof T & keyof AggregateAlerts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlerts[P]>
      : GetScalarType<T[P], AggregateAlerts[P]>
  }




  export type AlertsGroupByArgs = {
    where?: AlertsWhereInput
    orderBy?: Enumerable<AlertsOrderByWithAggregationInput>
    by: Array<AlertsScalarFieldEnum>
    having?: AlertsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertsCountAggregateInputType | true
    _avg?: AlertsAvgAggregateInputType
    _sum?: AlertsSumAggregateInputType
    _min?: AlertsMinAggregateInputType
    _max?: AlertsMaxAggregateInputType
  }


  export type AlertsGroupByOutputType = {
    id: bigint
    title: string | null
    type: string
    category: string
    AccountId: number | null
    ReferenceId: number
    isRead: boolean | null
    createdAt: Date
    updatedAt: Date
    data: JsonValue | null
    _count: AlertsCountAggregateOutputType | null
    _avg: AlertsAvgAggregateOutputType | null
    _sum: AlertsSumAggregateOutputType | null
    _min: AlertsMinAggregateOutputType | null
    _max: AlertsMaxAggregateOutputType | null
  }

  type GetAlertsGroupByPayload<T extends AlertsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AlertsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertsGroupByOutputType[P]>
            : GetScalarType<T[P], AlertsGroupByOutputType[P]>
        }
      >
    >


  export type AlertsSelect = {
    id?: boolean
    title?: boolean
    type?: boolean
    category?: boolean
    AccountId?: boolean
    ReferenceId?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    data?: boolean
    Accounts?: boolean | AccountsArgs
  }

  export type AlertsInclude = {
    Accounts?: boolean | AccountsArgs
  }

  export type AlertsGetPayload<
    S extends boolean | null | undefined | AlertsArgs,
    U = keyof S
      > = S extends true
        ? Alerts
    : S extends undefined
    ? never
    : S extends AlertsArgs | AlertsFindManyArgs
    ?'include' extends U
    ? Alerts  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof Alerts ? Alerts[P] : never
  } 
    : Alerts
  : Alerts


  type AlertsCountArgs = Merge<
    Omit<AlertsFindManyArgs, 'select' | 'include'> & {
      select?: AlertsCountAggregateInputType | true
    }
  >

  export interface AlertsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Alerts that matches the filter.
     * @param {AlertsFindUniqueArgs} args - Arguments to find a Alerts
     * @example
     * // Get one Alerts
     * const alerts = await prisma.alerts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AlertsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AlertsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Alerts'> extends True ? CheckSelect<T, Prisma__AlertsClient<Alerts>, Prisma__AlertsClient<AlertsGetPayload<T>>> : CheckSelect<T, Prisma__AlertsClient<Alerts | null, null>, Prisma__AlertsClient<AlertsGetPayload<T> | null, null>>

    /**
     * Find the first Alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertsFindFirstArgs} args - Arguments to find a Alerts
     * @example
     * // Get one Alerts
     * const alerts = await prisma.alerts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AlertsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AlertsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Alerts'> extends True ? CheckSelect<T, Prisma__AlertsClient<Alerts>, Prisma__AlertsClient<AlertsGetPayload<T>>> : CheckSelect<T, Prisma__AlertsClient<Alerts | null, null>, Prisma__AlertsClient<AlertsGetPayload<T> | null, null>>

    /**
     * Find zero or more Alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alerts
     * const alerts = await prisma.alerts.findMany()
     * 
     * // Get first 10 Alerts
     * const alerts = await prisma.alerts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertsWithIdOnly = await prisma.alerts.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AlertsFindManyArgs>(
      args?: SelectSubset<T, AlertsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Alerts>>, PrismaPromise<Array<AlertsGetPayload<T>>>>

    /**
     * Create a Alerts.
     * @param {AlertsCreateArgs} args - Arguments to create a Alerts.
     * @example
     * // Create one Alerts
     * const Alerts = await prisma.alerts.create({
     *   data: {
     *     // ... data to create a Alerts
     *   }
     * })
     * 
    **/
    create<T extends AlertsCreateArgs>(
      args: SelectSubset<T, AlertsCreateArgs>
    ): CheckSelect<T, Prisma__AlertsClient<Alerts>, Prisma__AlertsClient<AlertsGetPayload<T>>>

    /**
     * Create many Alerts.
     *     @param {AlertsCreateManyArgs} args - Arguments to create many Alerts.
     *     @example
     *     // Create many Alerts
     *     const alerts = await prisma.alerts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AlertsCreateManyArgs>(
      args?: SelectSubset<T, AlertsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Alerts.
     * @param {AlertsDeleteArgs} args - Arguments to delete one Alerts.
     * @example
     * // Delete one Alerts
     * const Alerts = await prisma.alerts.delete({
     *   where: {
     *     // ... filter to delete one Alerts
     *   }
     * })
     * 
    **/
    delete<T extends AlertsDeleteArgs>(
      args: SelectSubset<T, AlertsDeleteArgs>
    ): CheckSelect<T, Prisma__AlertsClient<Alerts>, Prisma__AlertsClient<AlertsGetPayload<T>>>

    /**
     * Update one Alerts.
     * @param {AlertsUpdateArgs} args - Arguments to update one Alerts.
     * @example
     * // Update one Alerts
     * const alerts = await prisma.alerts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AlertsUpdateArgs>(
      args: SelectSubset<T, AlertsUpdateArgs>
    ): CheckSelect<T, Prisma__AlertsClient<Alerts>, Prisma__AlertsClient<AlertsGetPayload<T>>>

    /**
     * Delete zero or more Alerts.
     * @param {AlertsDeleteManyArgs} args - Arguments to filter Alerts to delete.
     * @example
     * // Delete a few Alerts
     * const { count } = await prisma.alerts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AlertsDeleteManyArgs>(
      args?: SelectSubset<T, AlertsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alerts
     * const alerts = await prisma.alerts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AlertsUpdateManyArgs>(
      args: SelectSubset<T, AlertsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Alerts.
     * @param {AlertsUpsertArgs} args - Arguments to update or create a Alerts.
     * @example
     * // Update or create a Alerts
     * const alerts = await prisma.alerts.upsert({
     *   create: {
     *     // ... data to create a Alerts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alerts we want to update
     *   }
     * })
    **/
    upsert<T extends AlertsUpsertArgs>(
      args: SelectSubset<T, AlertsUpsertArgs>
    ): CheckSelect<T, Prisma__AlertsClient<Alerts>, Prisma__AlertsClient<AlertsGetPayload<T>>>

    /**
     * Find one Alerts that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {AlertsFindUniqueOrThrowArgs} args - Arguments to find a Alerts
     * @example
     * // Get one Alerts
     * const alerts = await prisma.alerts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AlertsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AlertsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__AlertsClient<Alerts>, Prisma__AlertsClient<AlertsGetPayload<T>>>

    /**
     * Find the first Alerts that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertsFindFirstOrThrowArgs} args - Arguments to find a Alerts
     * @example
     * // Get one Alerts
     * const alerts = await prisma.alerts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AlertsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AlertsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__AlertsClient<Alerts>, Prisma__AlertsClient<AlertsGetPayload<T>>>

    /**
     * Count the number of Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertsCountArgs} args - Arguments to filter Alerts to count.
     * @example
     * // Count the number of Alerts
     * const count = await prisma.alerts.count({
     *   where: {
     *     // ... the filter for the Alerts we want to count
     *   }
     * })
    **/
    count<T extends AlertsCountArgs>(
      args?: Subset<T, AlertsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertsAggregateArgs>(args: Subset<T, AlertsAggregateArgs>): PrismaPromise<GetAlertsAggregateType<T>>

    /**
     * Group by Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertsGroupByArgs['orderBy'] }
        : { orderBy?: AlertsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Alerts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AlertsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Accounts<T extends AccountsArgs = {}>(args?: Subset<T, AccountsArgs>): CheckSelect<T, Prisma__AccountsClient<Accounts | Null>, Prisma__AccountsClient<AccountsGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Alerts base type for findUnique actions
   */
  export type AlertsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Alerts
     * 
    **/
    select?: AlertsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AlertsInclude | null
    /**
     * Filter, which Alerts to fetch.
     * 
    **/
    where: AlertsWhereUniqueInput
  }

  /**
   * Alerts: findUnique
   */
  export interface AlertsFindUniqueArgs extends AlertsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Alerts base type for findFirst actions
   */
  export type AlertsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Alerts
     * 
    **/
    select?: AlertsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AlertsInclude | null
    /**
     * Filter, which Alerts to fetch.
     * 
    **/
    where?: AlertsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     * 
    **/
    orderBy?: Enumerable<AlertsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     * 
    **/
    cursor?: AlertsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     * 
    **/
    distinct?: Enumerable<AlertsScalarFieldEnum>
  }

  /**
   * Alerts: findFirst
   */
  export interface AlertsFindFirstArgs extends AlertsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Alerts findMany
   */
  export type AlertsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Alerts
     * 
    **/
    select?: AlertsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AlertsInclude | null
    /**
     * Filter, which Alerts to fetch.
     * 
    **/
    where?: AlertsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     * 
    **/
    orderBy?: Enumerable<AlertsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alerts.
     * 
    **/
    cursor?: AlertsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AlertsScalarFieldEnum>
  }


  /**
   * Alerts create
   */
  export type AlertsCreateArgs = {
    /**
     * Select specific fields to fetch from the Alerts
     * 
    **/
    select?: AlertsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AlertsInclude | null
    /**
     * The data needed to create a Alerts.
     * 
    **/
    data: XOR<AlertsCreateInput, AlertsUncheckedCreateInput>
  }


  /**
   * Alerts createMany
   */
  export type AlertsCreateManyArgs = {
    /**
     * The data used to create many Alerts.
     * 
    **/
    data: Enumerable<AlertsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Alerts update
   */
  export type AlertsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Alerts
     * 
    **/
    select?: AlertsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AlertsInclude | null
    /**
     * The data needed to update a Alerts.
     * 
    **/
    data: XOR<AlertsUpdateInput, AlertsUncheckedUpdateInput>
    /**
     * Choose, which Alerts to update.
     * 
    **/
    where: AlertsWhereUniqueInput
  }


  /**
   * Alerts updateMany
   */
  export type AlertsUpdateManyArgs = {
    /**
     * The data used to update Alerts.
     * 
    **/
    data: XOR<AlertsUpdateManyMutationInput, AlertsUncheckedUpdateManyInput>
    /**
     * Filter which Alerts to update
     * 
    **/
    where?: AlertsWhereInput
  }


  /**
   * Alerts upsert
   */
  export type AlertsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Alerts
     * 
    **/
    select?: AlertsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AlertsInclude | null
    /**
     * The filter to search for the Alerts to update in case it exists.
     * 
    **/
    where: AlertsWhereUniqueInput
    /**
     * In case the Alerts found by the `where` argument doesn't exist, create a new Alerts with this data.
     * 
    **/
    create: XOR<AlertsCreateInput, AlertsUncheckedCreateInput>
    /**
     * In case the Alerts was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AlertsUpdateInput, AlertsUncheckedUpdateInput>
  }


  /**
   * Alerts delete
   */
  export type AlertsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Alerts
     * 
    **/
    select?: AlertsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AlertsInclude | null
    /**
     * Filter which Alerts to delete.
     * 
    **/
    where: AlertsWhereUniqueInput
  }


  /**
   * Alerts deleteMany
   */
  export type AlertsDeleteManyArgs = {
    /**
     * Filter which Alerts to delete
     * 
    **/
    where?: AlertsWhereInput
  }


  /**
   * Alerts: findUniqueOrThrow
   */
  export type AlertsFindUniqueOrThrowArgs = AlertsFindUniqueArgsBase
      

  /**
   * Alerts: findFirstOrThrow
   */
  export type AlertsFindFirstOrThrowArgs = AlertsFindFirstArgsBase
      

  /**
   * Alerts without action
   */
  export type AlertsArgs = {
    /**
     * Select specific fields to fetch from the Alerts
     * 
    **/
    select?: AlertsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AlertsInclude | null
  }



  /**
   * Model Careers
   */


  export type AggregateCareers = {
    _count: CareersCountAggregateOutputType | null
    _avg: CareersAvgAggregateOutputType | null
    _sum: CareersSumAggregateOutputType | null
    _min: CareersMinAggregateOutputType | null
    _max: CareersMaxAggregateOutputType | null
  }

  export type CareersAvgAggregateOutputType = {
    id: number | null
    AccountId: number | null
  }

  export type CareersSumAggregateOutputType = {
    id: number | null
    AccountId: number | null
  }

  export type CareersMinAggregateOutputType = {
    id: number | null
    AccountId: number | null
    title: string | null
    startDate: Date | null
    endDate: Date | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CareersMaxAggregateOutputType = {
    id: number | null
    AccountId: number | null
    title: string | null
    startDate: Date | null
    endDate: Date | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CareersCountAggregateOutputType = {
    id: number
    AccountId: number
    title: number
    startDate: number
    endDate: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CareersAvgAggregateInputType = {
    id?: true
    AccountId?: true
  }

  export type CareersSumAggregateInputType = {
    id?: true
    AccountId?: true
  }

  export type CareersMinAggregateInputType = {
    id?: true
    AccountId?: true
    title?: true
    startDate?: true
    endDate?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CareersMaxAggregateInputType = {
    id?: true
    AccountId?: true
    title?: true
    startDate?: true
    endDate?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CareersCountAggregateInputType = {
    id?: true
    AccountId?: true
    title?: true
    startDate?: true
    endDate?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CareersAggregateArgs = {
    /**
     * Filter which Careers to aggregate.
     * 
    **/
    where?: CareersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Careers to fetch.
     * 
    **/
    orderBy?: Enumerable<CareersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CareersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Careers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Careers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Careers
    **/
    _count?: true | CareersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CareersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CareersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CareersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CareersMaxAggregateInputType
  }

  export type GetCareersAggregateType<T extends CareersAggregateArgs> = {
        [P in keyof T & keyof AggregateCareers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCareers[P]>
      : GetScalarType<T[P], AggregateCareers[P]>
  }




  export type CareersGroupByArgs = {
    where?: CareersWhereInput
    orderBy?: Enumerable<CareersOrderByWithAggregationInput>
    by: Array<CareersScalarFieldEnum>
    having?: CareersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CareersCountAggregateInputType | true
    _avg?: CareersAvgAggregateInputType
    _sum?: CareersSumAggregateInputType
    _min?: CareersMinAggregateInputType
    _max?: CareersMaxAggregateInputType
  }


  export type CareersGroupByOutputType = {
    id: number
    AccountId: number | null
    title: string | null
    startDate: Date | null
    endDate: Date | null
    content: string | null
    createdAt: Date
    updatedAt: Date
    _count: CareersCountAggregateOutputType | null
    _avg: CareersAvgAggregateOutputType | null
    _sum: CareersSumAggregateOutputType | null
    _min: CareersMinAggregateOutputType | null
    _max: CareersMaxAggregateOutputType | null
  }

  type GetCareersGroupByPayload<T extends CareersGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CareersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CareersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CareersGroupByOutputType[P]>
            : GetScalarType<T[P], CareersGroupByOutputType[P]>
        }
      >
    >


  export type CareersSelect = {
    id?: boolean
    AccountId?: boolean
    title?: boolean
    startDate?: boolean
    endDate?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Accounts?: boolean | AccountsArgs
  }

  export type CareersInclude = {
    Accounts?: boolean | AccountsArgs
  }

  export type CareersGetPayload<
    S extends boolean | null | undefined | CareersArgs,
    U = keyof S
      > = S extends true
        ? Careers
    : S extends undefined
    ? never
    : S extends CareersArgs | CareersFindManyArgs
    ?'include' extends U
    ? Careers  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof Careers ? Careers[P] : never
  } 
    : Careers
  : Careers


  type CareersCountArgs = Merge<
    Omit<CareersFindManyArgs, 'select' | 'include'> & {
      select?: CareersCountAggregateInputType | true
    }
  >

  export interface CareersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Careers that matches the filter.
     * @param {CareersFindUniqueArgs} args - Arguments to find a Careers
     * @example
     * // Get one Careers
     * const careers = await prisma.careers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CareersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CareersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Careers'> extends True ? CheckSelect<T, Prisma__CareersClient<Careers>, Prisma__CareersClient<CareersGetPayload<T>>> : CheckSelect<T, Prisma__CareersClient<Careers | null, null>, Prisma__CareersClient<CareersGetPayload<T> | null, null>>

    /**
     * Find the first Careers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareersFindFirstArgs} args - Arguments to find a Careers
     * @example
     * // Get one Careers
     * const careers = await prisma.careers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CareersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CareersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Careers'> extends True ? CheckSelect<T, Prisma__CareersClient<Careers>, Prisma__CareersClient<CareersGetPayload<T>>> : CheckSelect<T, Prisma__CareersClient<Careers | null, null>, Prisma__CareersClient<CareersGetPayload<T> | null, null>>

    /**
     * Find zero or more Careers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Careers
     * const careers = await prisma.careers.findMany()
     * 
     * // Get first 10 Careers
     * const careers = await prisma.careers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const careersWithIdOnly = await prisma.careers.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CareersFindManyArgs>(
      args?: SelectSubset<T, CareersFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Careers>>, PrismaPromise<Array<CareersGetPayload<T>>>>

    /**
     * Create a Careers.
     * @param {CareersCreateArgs} args - Arguments to create a Careers.
     * @example
     * // Create one Careers
     * const Careers = await prisma.careers.create({
     *   data: {
     *     // ... data to create a Careers
     *   }
     * })
     * 
    **/
    create<T extends CareersCreateArgs>(
      args: SelectSubset<T, CareersCreateArgs>
    ): CheckSelect<T, Prisma__CareersClient<Careers>, Prisma__CareersClient<CareersGetPayload<T>>>

    /**
     * Create many Careers.
     *     @param {CareersCreateManyArgs} args - Arguments to create many Careers.
     *     @example
     *     // Create many Careers
     *     const careers = await prisma.careers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CareersCreateManyArgs>(
      args?: SelectSubset<T, CareersCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Careers.
     * @param {CareersDeleteArgs} args - Arguments to delete one Careers.
     * @example
     * // Delete one Careers
     * const Careers = await prisma.careers.delete({
     *   where: {
     *     // ... filter to delete one Careers
     *   }
     * })
     * 
    **/
    delete<T extends CareersDeleteArgs>(
      args: SelectSubset<T, CareersDeleteArgs>
    ): CheckSelect<T, Prisma__CareersClient<Careers>, Prisma__CareersClient<CareersGetPayload<T>>>

    /**
     * Update one Careers.
     * @param {CareersUpdateArgs} args - Arguments to update one Careers.
     * @example
     * // Update one Careers
     * const careers = await prisma.careers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CareersUpdateArgs>(
      args: SelectSubset<T, CareersUpdateArgs>
    ): CheckSelect<T, Prisma__CareersClient<Careers>, Prisma__CareersClient<CareersGetPayload<T>>>

    /**
     * Delete zero or more Careers.
     * @param {CareersDeleteManyArgs} args - Arguments to filter Careers to delete.
     * @example
     * // Delete a few Careers
     * const { count } = await prisma.careers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CareersDeleteManyArgs>(
      args?: SelectSubset<T, CareersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Careers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Careers
     * const careers = await prisma.careers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CareersUpdateManyArgs>(
      args: SelectSubset<T, CareersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Careers.
     * @param {CareersUpsertArgs} args - Arguments to update or create a Careers.
     * @example
     * // Update or create a Careers
     * const careers = await prisma.careers.upsert({
     *   create: {
     *     // ... data to create a Careers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Careers we want to update
     *   }
     * })
    **/
    upsert<T extends CareersUpsertArgs>(
      args: SelectSubset<T, CareersUpsertArgs>
    ): CheckSelect<T, Prisma__CareersClient<Careers>, Prisma__CareersClient<CareersGetPayload<T>>>

    /**
     * Find one Careers that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CareersFindUniqueOrThrowArgs} args - Arguments to find a Careers
     * @example
     * // Get one Careers
     * const careers = await prisma.careers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CareersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CareersFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CareersClient<Careers>, Prisma__CareersClient<CareersGetPayload<T>>>

    /**
     * Find the first Careers that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareersFindFirstOrThrowArgs} args - Arguments to find a Careers
     * @example
     * // Get one Careers
     * const careers = await prisma.careers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CareersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CareersFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CareersClient<Careers>, Prisma__CareersClient<CareersGetPayload<T>>>

    /**
     * Count the number of Careers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareersCountArgs} args - Arguments to filter Careers to count.
     * @example
     * // Count the number of Careers
     * const count = await prisma.careers.count({
     *   where: {
     *     // ... the filter for the Careers we want to count
     *   }
     * })
    **/
    count<T extends CareersCountArgs>(
      args?: Subset<T, CareersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CareersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Careers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CareersAggregateArgs>(args: Subset<T, CareersAggregateArgs>): PrismaPromise<GetCareersAggregateType<T>>

    /**
     * Group by Careers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CareersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CareersGroupByArgs['orderBy'] }
        : { orderBy?: CareersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CareersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCareersGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Careers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CareersClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Accounts<T extends AccountsArgs = {}>(args?: Subset<T, AccountsArgs>): CheckSelect<T, Prisma__AccountsClient<Accounts | Null>, Prisma__AccountsClient<AccountsGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Careers base type for findUnique actions
   */
  export type CareersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Careers
     * 
    **/
    select?: CareersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CareersInclude | null
    /**
     * Filter, which Careers to fetch.
     * 
    **/
    where: CareersWhereUniqueInput
  }

  /**
   * Careers: findUnique
   */
  export interface CareersFindUniqueArgs extends CareersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Careers base type for findFirst actions
   */
  export type CareersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Careers
     * 
    **/
    select?: CareersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CareersInclude | null
    /**
     * Filter, which Careers to fetch.
     * 
    **/
    where?: CareersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Careers to fetch.
     * 
    **/
    orderBy?: Enumerable<CareersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Careers.
     * 
    **/
    cursor?: CareersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Careers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Careers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Careers.
     * 
    **/
    distinct?: Enumerable<CareersScalarFieldEnum>
  }

  /**
   * Careers: findFirst
   */
  export interface CareersFindFirstArgs extends CareersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Careers findMany
   */
  export type CareersFindManyArgs = {
    /**
     * Select specific fields to fetch from the Careers
     * 
    **/
    select?: CareersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CareersInclude | null
    /**
     * Filter, which Careers to fetch.
     * 
    **/
    where?: CareersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Careers to fetch.
     * 
    **/
    orderBy?: Enumerable<CareersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Careers.
     * 
    **/
    cursor?: CareersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Careers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Careers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CareersScalarFieldEnum>
  }


  /**
   * Careers create
   */
  export type CareersCreateArgs = {
    /**
     * Select specific fields to fetch from the Careers
     * 
    **/
    select?: CareersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CareersInclude | null
    /**
     * The data needed to create a Careers.
     * 
    **/
    data: XOR<CareersCreateInput, CareersUncheckedCreateInput>
  }


  /**
   * Careers createMany
   */
  export type CareersCreateManyArgs = {
    /**
     * The data used to create many Careers.
     * 
    **/
    data: Enumerable<CareersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Careers update
   */
  export type CareersUpdateArgs = {
    /**
     * Select specific fields to fetch from the Careers
     * 
    **/
    select?: CareersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CareersInclude | null
    /**
     * The data needed to update a Careers.
     * 
    **/
    data: XOR<CareersUpdateInput, CareersUncheckedUpdateInput>
    /**
     * Choose, which Careers to update.
     * 
    **/
    where: CareersWhereUniqueInput
  }


  /**
   * Careers updateMany
   */
  export type CareersUpdateManyArgs = {
    /**
     * The data used to update Careers.
     * 
    **/
    data: XOR<CareersUpdateManyMutationInput, CareersUncheckedUpdateManyInput>
    /**
     * Filter which Careers to update
     * 
    **/
    where?: CareersWhereInput
  }


  /**
   * Careers upsert
   */
  export type CareersUpsertArgs = {
    /**
     * Select specific fields to fetch from the Careers
     * 
    **/
    select?: CareersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CareersInclude | null
    /**
     * The filter to search for the Careers to update in case it exists.
     * 
    **/
    where: CareersWhereUniqueInput
    /**
     * In case the Careers found by the `where` argument doesn't exist, create a new Careers with this data.
     * 
    **/
    create: XOR<CareersCreateInput, CareersUncheckedCreateInput>
    /**
     * In case the Careers was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CareersUpdateInput, CareersUncheckedUpdateInput>
  }


  /**
   * Careers delete
   */
  export type CareersDeleteArgs = {
    /**
     * Select specific fields to fetch from the Careers
     * 
    **/
    select?: CareersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CareersInclude | null
    /**
     * Filter which Careers to delete.
     * 
    **/
    where: CareersWhereUniqueInput
  }


  /**
   * Careers deleteMany
   */
  export type CareersDeleteManyArgs = {
    /**
     * Filter which Careers to delete
     * 
    **/
    where?: CareersWhereInput
  }


  /**
   * Careers: findUniqueOrThrow
   */
  export type CareersFindUniqueOrThrowArgs = CareersFindUniqueArgsBase
      

  /**
   * Careers: findFirstOrThrow
   */
  export type CareersFindFirstOrThrowArgs = CareersFindFirstArgsBase
      

  /**
   * Careers without action
   */
  export type CareersArgs = {
    /**
     * Select specific fields to fetch from the Careers
     * 
    **/
    select?: CareersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CareersInclude | null
  }



  /**
   * Model Coupons
   */


  export type AggregateCoupons = {
    _count: CouponsCountAggregateOutputType | null
    _avg: CouponsAvgAggregateOutputType | null
    _sum: CouponsSumAggregateOutputType | null
    _min: CouponsMinAggregateOutputType | null
    _max: CouponsMaxAggregateOutputType | null
  }

  export type CouponsAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
    maxRetry: number | null
    value: number | null
  }

  export type CouponsSumAggregateOutputType = {
    id: number | null
    quantity: number | null
    maxRetry: number | null
    value: number | null
  }

  export type CouponsMinAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    quantity: number | null
    maxRetry: number | null
    unit: string | null
    value: number | null
    startedAt: Date | null
    endedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CouponsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    quantity: number | null
    maxRetry: number | null
    unit: string | null
    value: number | null
    startedAt: Date | null
    endedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CouponsCountAggregateOutputType = {
    id: number
    name: number
    code: number
    quantity: number
    maxRetry: number
    unit: number
    value: number
    startedAt: number
    endedAt: number
    createdAt: number
    extra: number
    updatedAt: number
    _all: number
  }


  export type CouponsAvgAggregateInputType = {
    id?: true
    quantity?: true
    maxRetry?: true
    value?: true
  }

  export type CouponsSumAggregateInputType = {
    id?: true
    quantity?: true
    maxRetry?: true
    value?: true
  }

  export type CouponsMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    quantity?: true
    maxRetry?: true
    unit?: true
    value?: true
    startedAt?: true
    endedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CouponsMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    quantity?: true
    maxRetry?: true
    unit?: true
    value?: true
    startedAt?: true
    endedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CouponsCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    quantity?: true
    maxRetry?: true
    unit?: true
    value?: true
    startedAt?: true
    endedAt?: true
    createdAt?: true
    extra?: true
    updatedAt?: true
    _all?: true
  }

  export type CouponsAggregateArgs = {
    /**
     * Filter which Coupons to aggregate.
     * 
    **/
    where?: CouponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     * 
    **/
    orderBy?: Enumerable<CouponsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CouponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Coupons
    **/
    _count?: true | CouponsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CouponsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CouponsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CouponsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CouponsMaxAggregateInputType
  }

  export type GetCouponsAggregateType<T extends CouponsAggregateArgs> = {
        [P in keyof T & keyof AggregateCoupons]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoupons[P]>
      : GetScalarType<T[P], AggregateCoupons[P]>
  }




  export type CouponsGroupByArgs = {
    where?: CouponsWhereInput
    orderBy?: Enumerable<CouponsOrderByWithAggregationInput>
    by: Array<CouponsScalarFieldEnum>
    having?: CouponsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CouponsCountAggregateInputType | true
    _avg?: CouponsAvgAggregateInputType
    _sum?: CouponsSumAggregateInputType
    _min?: CouponsMinAggregateInputType
    _max?: CouponsMaxAggregateInputType
  }


  export type CouponsGroupByOutputType = {
    id: number
    name: string | null
    code: string | null
    quantity: number | null
    maxRetry: number | null
    unit: string | null
    value: number | null
    startedAt: Date | null
    endedAt: Date | null
    createdAt: Date
    extra: JsonValue | null
    updatedAt: Date
    _count: CouponsCountAggregateOutputType | null
    _avg: CouponsAvgAggregateOutputType | null
    _sum: CouponsSumAggregateOutputType | null
    _min: CouponsMinAggregateOutputType | null
    _max: CouponsMaxAggregateOutputType | null
  }

  type GetCouponsGroupByPayload<T extends CouponsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CouponsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CouponsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouponsGroupByOutputType[P]>
            : GetScalarType<T[P], CouponsGroupByOutputType[P]>
        }
      >
    >


  export type CouponsSelect = {
    id?: boolean
    name?: boolean
    code?: boolean
    quantity?: boolean
    maxRetry?: boolean
    unit?: boolean
    value?: boolean
    startedAt?: boolean
    endedAt?: boolean
    createdAt?: boolean
    extra?: boolean
    updatedAt?: boolean
    Discounts?: boolean | DiscountsFindManyArgs
    _count?: boolean | CouponsCountOutputTypeArgs
  }

  export type CouponsInclude = {
    Discounts?: boolean | DiscountsFindManyArgs
    _count?: boolean | CouponsCountOutputTypeArgs
  }

  export type CouponsGetPayload<
    S extends boolean | null | undefined | CouponsArgs,
    U = keyof S
      > = S extends true
        ? Coupons
    : S extends undefined
    ? never
    : S extends CouponsArgs | CouponsFindManyArgs
    ?'include' extends U
    ? Coupons  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Discounts' ? Array < DiscountsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? CouponsCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Discounts' ? Array < DiscountsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? CouponsCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Coupons ? Coupons[P] : never
  } 
    : Coupons
  : Coupons


  type CouponsCountArgs = Merge<
    Omit<CouponsFindManyArgs, 'select' | 'include'> & {
      select?: CouponsCountAggregateInputType | true
    }
  >

  export interface CouponsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Coupons that matches the filter.
     * @param {CouponsFindUniqueArgs} args - Arguments to find a Coupons
     * @example
     * // Get one Coupons
     * const coupons = await prisma.coupons.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CouponsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CouponsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Coupons'> extends True ? CheckSelect<T, Prisma__CouponsClient<Coupons>, Prisma__CouponsClient<CouponsGetPayload<T>>> : CheckSelect<T, Prisma__CouponsClient<Coupons | null, null>, Prisma__CouponsClient<CouponsGetPayload<T> | null, null>>

    /**
     * Find the first Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponsFindFirstArgs} args - Arguments to find a Coupons
     * @example
     * // Get one Coupons
     * const coupons = await prisma.coupons.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CouponsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CouponsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Coupons'> extends True ? CheckSelect<T, Prisma__CouponsClient<Coupons>, Prisma__CouponsClient<CouponsGetPayload<T>>> : CheckSelect<T, Prisma__CouponsClient<Coupons | null, null>, Prisma__CouponsClient<CouponsGetPayload<T> | null, null>>

    /**
     * Find zero or more Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coupons
     * const coupons = await prisma.coupons.findMany()
     * 
     * // Get first 10 Coupons
     * const coupons = await prisma.coupons.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const couponsWithIdOnly = await prisma.coupons.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CouponsFindManyArgs>(
      args?: SelectSubset<T, CouponsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Coupons>>, PrismaPromise<Array<CouponsGetPayload<T>>>>

    /**
     * Create a Coupons.
     * @param {CouponsCreateArgs} args - Arguments to create a Coupons.
     * @example
     * // Create one Coupons
     * const Coupons = await prisma.coupons.create({
     *   data: {
     *     // ... data to create a Coupons
     *   }
     * })
     * 
    **/
    create<T extends CouponsCreateArgs>(
      args: SelectSubset<T, CouponsCreateArgs>
    ): CheckSelect<T, Prisma__CouponsClient<Coupons>, Prisma__CouponsClient<CouponsGetPayload<T>>>

    /**
     * Create many Coupons.
     *     @param {CouponsCreateManyArgs} args - Arguments to create many Coupons.
     *     @example
     *     // Create many Coupons
     *     const coupons = await prisma.coupons.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CouponsCreateManyArgs>(
      args?: SelectSubset<T, CouponsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Coupons.
     * @param {CouponsDeleteArgs} args - Arguments to delete one Coupons.
     * @example
     * // Delete one Coupons
     * const Coupons = await prisma.coupons.delete({
     *   where: {
     *     // ... filter to delete one Coupons
     *   }
     * })
     * 
    **/
    delete<T extends CouponsDeleteArgs>(
      args: SelectSubset<T, CouponsDeleteArgs>
    ): CheckSelect<T, Prisma__CouponsClient<Coupons>, Prisma__CouponsClient<CouponsGetPayload<T>>>

    /**
     * Update one Coupons.
     * @param {CouponsUpdateArgs} args - Arguments to update one Coupons.
     * @example
     * // Update one Coupons
     * const coupons = await prisma.coupons.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CouponsUpdateArgs>(
      args: SelectSubset<T, CouponsUpdateArgs>
    ): CheckSelect<T, Prisma__CouponsClient<Coupons>, Prisma__CouponsClient<CouponsGetPayload<T>>>

    /**
     * Delete zero or more Coupons.
     * @param {CouponsDeleteManyArgs} args - Arguments to filter Coupons to delete.
     * @example
     * // Delete a few Coupons
     * const { count } = await prisma.coupons.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CouponsDeleteManyArgs>(
      args?: SelectSubset<T, CouponsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coupons
     * const coupons = await prisma.coupons.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CouponsUpdateManyArgs>(
      args: SelectSubset<T, CouponsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Coupons.
     * @param {CouponsUpsertArgs} args - Arguments to update or create a Coupons.
     * @example
     * // Update or create a Coupons
     * const coupons = await prisma.coupons.upsert({
     *   create: {
     *     // ... data to create a Coupons
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coupons we want to update
     *   }
     * })
    **/
    upsert<T extends CouponsUpsertArgs>(
      args: SelectSubset<T, CouponsUpsertArgs>
    ): CheckSelect<T, Prisma__CouponsClient<Coupons>, Prisma__CouponsClient<CouponsGetPayload<T>>>

    /**
     * Find one Coupons that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CouponsFindUniqueOrThrowArgs} args - Arguments to find a Coupons
     * @example
     * // Get one Coupons
     * const coupons = await prisma.coupons.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CouponsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CouponsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CouponsClient<Coupons>, Prisma__CouponsClient<CouponsGetPayload<T>>>

    /**
     * Find the first Coupons that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponsFindFirstOrThrowArgs} args - Arguments to find a Coupons
     * @example
     * // Get one Coupons
     * const coupons = await prisma.coupons.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CouponsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CouponsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CouponsClient<Coupons>, Prisma__CouponsClient<CouponsGetPayload<T>>>

    /**
     * Count the number of Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponsCountArgs} args - Arguments to filter Coupons to count.
     * @example
     * // Count the number of Coupons
     * const count = await prisma.coupons.count({
     *   where: {
     *     // ... the filter for the Coupons we want to count
     *   }
     * })
    **/
    count<T extends CouponsCountArgs>(
      args?: Subset<T, CouponsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouponsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CouponsAggregateArgs>(args: Subset<T, CouponsAggregateArgs>): PrismaPromise<GetCouponsAggregateType<T>>

    /**
     * Group by Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CouponsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CouponsGroupByArgs['orderBy'] }
        : { orderBy?: CouponsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CouponsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouponsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Coupons.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CouponsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Discounts<T extends DiscountsFindManyArgs = {}>(args?: Subset<T, DiscountsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Discounts>| Null>, PrismaPromise<Array<DiscountsGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Coupons base type for findUnique actions
   */
  export type CouponsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Coupons
     * 
    **/
    select?: CouponsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CouponsInclude | null
    /**
     * Filter, which Coupons to fetch.
     * 
    **/
    where: CouponsWhereUniqueInput
  }

  /**
   * Coupons: findUnique
   */
  export interface CouponsFindUniqueArgs extends CouponsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Coupons base type for findFirst actions
   */
  export type CouponsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Coupons
     * 
    **/
    select?: CouponsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CouponsInclude | null
    /**
     * Filter, which Coupons to fetch.
     * 
    **/
    where?: CouponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     * 
    **/
    orderBy?: Enumerable<CouponsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     * 
    **/
    cursor?: CouponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     * 
    **/
    distinct?: Enumerable<CouponsScalarFieldEnum>
  }

  /**
   * Coupons: findFirst
   */
  export interface CouponsFindFirstArgs extends CouponsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Coupons findMany
   */
  export type CouponsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Coupons
     * 
    **/
    select?: CouponsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CouponsInclude | null
    /**
     * Filter, which Coupons to fetch.
     * 
    **/
    where?: CouponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     * 
    **/
    orderBy?: Enumerable<CouponsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Coupons.
     * 
    **/
    cursor?: CouponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CouponsScalarFieldEnum>
  }


  /**
   * Coupons create
   */
  export type CouponsCreateArgs = {
    /**
     * Select specific fields to fetch from the Coupons
     * 
    **/
    select?: CouponsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CouponsInclude | null
    /**
     * The data needed to create a Coupons.
     * 
    **/
    data: XOR<CouponsCreateInput, CouponsUncheckedCreateInput>
  }


  /**
   * Coupons createMany
   */
  export type CouponsCreateManyArgs = {
    /**
     * The data used to create many Coupons.
     * 
    **/
    data: Enumerable<CouponsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Coupons update
   */
  export type CouponsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Coupons
     * 
    **/
    select?: CouponsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CouponsInclude | null
    /**
     * The data needed to update a Coupons.
     * 
    **/
    data: XOR<CouponsUpdateInput, CouponsUncheckedUpdateInput>
    /**
     * Choose, which Coupons to update.
     * 
    **/
    where: CouponsWhereUniqueInput
  }


  /**
   * Coupons updateMany
   */
  export type CouponsUpdateManyArgs = {
    /**
     * The data used to update Coupons.
     * 
    **/
    data: XOR<CouponsUpdateManyMutationInput, CouponsUncheckedUpdateManyInput>
    /**
     * Filter which Coupons to update
     * 
    **/
    where?: CouponsWhereInput
  }


  /**
   * Coupons upsert
   */
  export type CouponsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Coupons
     * 
    **/
    select?: CouponsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CouponsInclude | null
    /**
     * The filter to search for the Coupons to update in case it exists.
     * 
    **/
    where: CouponsWhereUniqueInput
    /**
     * In case the Coupons found by the `where` argument doesn't exist, create a new Coupons with this data.
     * 
    **/
    create: XOR<CouponsCreateInput, CouponsUncheckedCreateInput>
    /**
     * In case the Coupons was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CouponsUpdateInput, CouponsUncheckedUpdateInput>
  }


  /**
   * Coupons delete
   */
  export type CouponsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Coupons
     * 
    **/
    select?: CouponsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CouponsInclude | null
    /**
     * Filter which Coupons to delete.
     * 
    **/
    where: CouponsWhereUniqueInput
  }


  /**
   * Coupons deleteMany
   */
  export type CouponsDeleteManyArgs = {
    /**
     * Filter which Coupons to delete
     * 
    **/
    where?: CouponsWhereInput
  }


  /**
   * Coupons: findUniqueOrThrow
   */
  export type CouponsFindUniqueOrThrowArgs = CouponsFindUniqueArgsBase
      

  /**
   * Coupons: findFirstOrThrow
   */
  export type CouponsFindFirstOrThrowArgs = CouponsFindFirstArgsBase
      

  /**
   * Coupons without action
   */
  export type CouponsArgs = {
    /**
     * Select specific fields to fetch from the Coupons
     * 
    **/
    select?: CouponsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CouponsInclude | null
  }



  /**
   * Model CustomerTaskDetails
   */


  export type AggregateCustomerTaskDetails = {
    _count: CustomerTaskDetailsCountAggregateOutputType | null
    _avg: CustomerTaskDetailsAvgAggregateOutputType | null
    _sum: CustomerTaskDetailsSumAggregateOutputType | null
    _min: CustomerTaskDetailsMinAggregateOutputType | null
    _max: CustomerTaskDetailsMaxAggregateOutputType | null
  }

  export type CustomerTaskDetailsAvgAggregateOutputType = {
    id: number | null
    AccountId: number | null
    CustomerId: number | null
    area: Decimal | null
  }

  export type CustomerTaskDetailsSumAggregateOutputType = {
    id: number | null
    AccountId: number | null
    CustomerId: number | null
    area: Decimal | null
  }

  export type CustomerTaskDetailsMinAggregateOutputType = {
    id: number | null
    AccountId: number | null
    CustomerId: number | null
    type: string | null
    address: string | null
    villageName: string | null
    category: string | null
    etc: string | null
    x: string | null
    y: string | null
    area: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerTaskDetailsMaxAggregateOutputType = {
    id: number | null
    AccountId: number | null
    CustomerId: number | null
    type: string | null
    address: string | null
    villageName: string | null
    category: string | null
    etc: string | null
    x: string | null
    y: string | null
    area: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerTaskDetailsCountAggregateOutputType = {
    id: number
    AccountId: number
    CustomerId: number
    type: number
    address: number
    villageName: number
    category: number
    etc: number
    geometry: number
    x: number
    y: number
    area: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerTaskDetailsAvgAggregateInputType = {
    id?: true
    AccountId?: true
    CustomerId?: true
    area?: true
  }

  export type CustomerTaskDetailsSumAggregateInputType = {
    id?: true
    AccountId?: true
    CustomerId?: true
    area?: true
  }

  export type CustomerTaskDetailsMinAggregateInputType = {
    id?: true
    AccountId?: true
    CustomerId?: true
    type?: true
    address?: true
    villageName?: true
    category?: true
    etc?: true
    x?: true
    y?: true
    area?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerTaskDetailsMaxAggregateInputType = {
    id?: true
    AccountId?: true
    CustomerId?: true
    type?: true
    address?: true
    villageName?: true
    category?: true
    etc?: true
    x?: true
    y?: true
    area?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerTaskDetailsCountAggregateInputType = {
    id?: true
    AccountId?: true
    CustomerId?: true
    type?: true
    address?: true
    villageName?: true
    category?: true
    etc?: true
    geometry?: true
    x?: true
    y?: true
    area?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerTaskDetailsAggregateArgs = {
    /**
     * Filter which CustomerTaskDetails to aggregate.
     * 
    **/
    where?: CustomerTaskDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerTaskDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerTaskDetailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CustomerTaskDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerTaskDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerTaskDetails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerTaskDetails
    **/
    _count?: true | CustomerTaskDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerTaskDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerTaskDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerTaskDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerTaskDetailsMaxAggregateInputType
  }

  export type GetCustomerTaskDetailsAggregateType<T extends CustomerTaskDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerTaskDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerTaskDetails[P]>
      : GetScalarType<T[P], AggregateCustomerTaskDetails[P]>
  }




  export type CustomerTaskDetailsGroupByArgs = {
    where?: CustomerTaskDetailsWhereInput
    orderBy?: Enumerable<CustomerTaskDetailsOrderByWithAggregationInput>
    by: Array<CustomerTaskDetailsScalarFieldEnum>
    having?: CustomerTaskDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerTaskDetailsCountAggregateInputType | true
    _avg?: CustomerTaskDetailsAvgAggregateInputType
    _sum?: CustomerTaskDetailsSumAggregateInputType
    _min?: CustomerTaskDetailsMinAggregateInputType
    _max?: CustomerTaskDetailsMaxAggregateInputType
  }


  export type CustomerTaskDetailsGroupByOutputType = {
    id: number
    AccountId: number | null
    CustomerId: number | null
    type: string | null
    address: string | null
    villageName: string | null
    category: string | null
    etc: string | null
    geometry: JsonValue | null
    x: string | null
    y: string | null
    area: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: CustomerTaskDetailsCountAggregateOutputType | null
    _avg: CustomerTaskDetailsAvgAggregateOutputType | null
    _sum: CustomerTaskDetailsSumAggregateOutputType | null
    _min: CustomerTaskDetailsMinAggregateOutputType | null
    _max: CustomerTaskDetailsMaxAggregateOutputType | null
  }

  type GetCustomerTaskDetailsGroupByPayload<T extends CustomerTaskDetailsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CustomerTaskDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerTaskDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerTaskDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerTaskDetailsGroupByOutputType[P]>
        }
      >
    >


  export type CustomerTaskDetailsSelect = {
    id?: boolean
    AccountId?: boolean
    CustomerId?: boolean
    type?: boolean
    address?: boolean
    villageName?: boolean
    category?: boolean
    etc?: boolean
    geometry?: boolean
    x?: boolean
    y?: boolean
    area?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Accounts?: boolean | AccountsArgs
    Customers?: boolean | CustomersArgs
  }

  export type CustomerTaskDetailsInclude = {
    Accounts?: boolean | AccountsArgs
    Customers?: boolean | CustomersArgs
  }

  export type CustomerTaskDetailsGetPayload<
    S extends boolean | null | undefined | CustomerTaskDetailsArgs,
    U = keyof S
      > = S extends true
        ? CustomerTaskDetails
    : S extends undefined
    ? never
    : S extends CustomerTaskDetailsArgs | CustomerTaskDetailsFindManyArgs
    ?'include' extends U
    ? CustomerTaskDetails  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'Customers' ? CustomersGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'Customers' ? CustomersGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof CustomerTaskDetails ? CustomerTaskDetails[P] : never
  } 
    : CustomerTaskDetails
  : CustomerTaskDetails


  type CustomerTaskDetailsCountArgs = Merge<
    Omit<CustomerTaskDetailsFindManyArgs, 'select' | 'include'> & {
      select?: CustomerTaskDetailsCountAggregateInputType | true
    }
  >

  export interface CustomerTaskDetailsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CustomerTaskDetails that matches the filter.
     * @param {CustomerTaskDetailsFindUniqueArgs} args - Arguments to find a CustomerTaskDetails
     * @example
     * // Get one CustomerTaskDetails
     * const customerTaskDetails = await prisma.customerTaskDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerTaskDetailsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomerTaskDetailsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CustomerTaskDetails'> extends True ? CheckSelect<T, Prisma__CustomerTaskDetailsClient<CustomerTaskDetails>, Prisma__CustomerTaskDetailsClient<CustomerTaskDetailsGetPayload<T>>> : CheckSelect<T, Prisma__CustomerTaskDetailsClient<CustomerTaskDetails | null, null>, Prisma__CustomerTaskDetailsClient<CustomerTaskDetailsGetPayload<T> | null, null>>

    /**
     * Find the first CustomerTaskDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTaskDetailsFindFirstArgs} args - Arguments to find a CustomerTaskDetails
     * @example
     * // Get one CustomerTaskDetails
     * const customerTaskDetails = await prisma.customerTaskDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerTaskDetailsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomerTaskDetailsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CustomerTaskDetails'> extends True ? CheckSelect<T, Prisma__CustomerTaskDetailsClient<CustomerTaskDetails>, Prisma__CustomerTaskDetailsClient<CustomerTaskDetailsGetPayload<T>>> : CheckSelect<T, Prisma__CustomerTaskDetailsClient<CustomerTaskDetails | null, null>, Prisma__CustomerTaskDetailsClient<CustomerTaskDetailsGetPayload<T> | null, null>>

    /**
     * Find zero or more CustomerTaskDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTaskDetailsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerTaskDetails
     * const customerTaskDetails = await prisma.customerTaskDetails.findMany()
     * 
     * // Get first 10 CustomerTaskDetails
     * const customerTaskDetails = await prisma.customerTaskDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerTaskDetailsWithIdOnly = await prisma.customerTaskDetails.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CustomerTaskDetailsFindManyArgs>(
      args?: SelectSubset<T, CustomerTaskDetailsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CustomerTaskDetails>>, PrismaPromise<Array<CustomerTaskDetailsGetPayload<T>>>>

    /**
     * Create a CustomerTaskDetails.
     * @param {CustomerTaskDetailsCreateArgs} args - Arguments to create a CustomerTaskDetails.
     * @example
     * // Create one CustomerTaskDetails
     * const CustomerTaskDetails = await prisma.customerTaskDetails.create({
     *   data: {
     *     // ... data to create a CustomerTaskDetails
     *   }
     * })
     * 
    **/
    create<T extends CustomerTaskDetailsCreateArgs>(
      args: SelectSubset<T, CustomerTaskDetailsCreateArgs>
    ): CheckSelect<T, Prisma__CustomerTaskDetailsClient<CustomerTaskDetails>, Prisma__CustomerTaskDetailsClient<CustomerTaskDetailsGetPayload<T>>>

    /**
     * Create many CustomerTaskDetails.
     *     @param {CustomerTaskDetailsCreateManyArgs} args - Arguments to create many CustomerTaskDetails.
     *     @example
     *     // Create many CustomerTaskDetails
     *     const customerTaskDetails = await prisma.customerTaskDetails.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerTaskDetailsCreateManyArgs>(
      args?: SelectSubset<T, CustomerTaskDetailsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerTaskDetails.
     * @param {CustomerTaskDetailsDeleteArgs} args - Arguments to delete one CustomerTaskDetails.
     * @example
     * // Delete one CustomerTaskDetails
     * const CustomerTaskDetails = await prisma.customerTaskDetails.delete({
     *   where: {
     *     // ... filter to delete one CustomerTaskDetails
     *   }
     * })
     * 
    **/
    delete<T extends CustomerTaskDetailsDeleteArgs>(
      args: SelectSubset<T, CustomerTaskDetailsDeleteArgs>
    ): CheckSelect<T, Prisma__CustomerTaskDetailsClient<CustomerTaskDetails>, Prisma__CustomerTaskDetailsClient<CustomerTaskDetailsGetPayload<T>>>

    /**
     * Update one CustomerTaskDetails.
     * @param {CustomerTaskDetailsUpdateArgs} args - Arguments to update one CustomerTaskDetails.
     * @example
     * // Update one CustomerTaskDetails
     * const customerTaskDetails = await prisma.customerTaskDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerTaskDetailsUpdateArgs>(
      args: SelectSubset<T, CustomerTaskDetailsUpdateArgs>
    ): CheckSelect<T, Prisma__CustomerTaskDetailsClient<CustomerTaskDetails>, Prisma__CustomerTaskDetailsClient<CustomerTaskDetailsGetPayload<T>>>

    /**
     * Delete zero or more CustomerTaskDetails.
     * @param {CustomerTaskDetailsDeleteManyArgs} args - Arguments to filter CustomerTaskDetails to delete.
     * @example
     * // Delete a few CustomerTaskDetails
     * const { count } = await prisma.customerTaskDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerTaskDetailsDeleteManyArgs>(
      args?: SelectSubset<T, CustomerTaskDetailsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerTaskDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTaskDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerTaskDetails
     * const customerTaskDetails = await prisma.customerTaskDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerTaskDetailsUpdateManyArgs>(
      args: SelectSubset<T, CustomerTaskDetailsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerTaskDetails.
     * @param {CustomerTaskDetailsUpsertArgs} args - Arguments to update or create a CustomerTaskDetails.
     * @example
     * // Update or create a CustomerTaskDetails
     * const customerTaskDetails = await prisma.customerTaskDetails.upsert({
     *   create: {
     *     // ... data to create a CustomerTaskDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerTaskDetails we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerTaskDetailsUpsertArgs>(
      args: SelectSubset<T, CustomerTaskDetailsUpsertArgs>
    ): CheckSelect<T, Prisma__CustomerTaskDetailsClient<CustomerTaskDetails>, Prisma__CustomerTaskDetailsClient<CustomerTaskDetailsGetPayload<T>>>

    /**
     * Find one CustomerTaskDetails that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CustomerTaskDetailsFindUniqueOrThrowArgs} args - Arguments to find a CustomerTaskDetails
     * @example
     * // Get one CustomerTaskDetails
     * const customerTaskDetails = await prisma.customerTaskDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomerTaskDetailsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CustomerTaskDetailsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CustomerTaskDetailsClient<CustomerTaskDetails>, Prisma__CustomerTaskDetailsClient<CustomerTaskDetailsGetPayload<T>>>

    /**
     * Find the first CustomerTaskDetails that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTaskDetailsFindFirstOrThrowArgs} args - Arguments to find a CustomerTaskDetails
     * @example
     * // Get one CustomerTaskDetails
     * const customerTaskDetails = await prisma.customerTaskDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomerTaskDetailsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CustomerTaskDetailsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CustomerTaskDetailsClient<CustomerTaskDetails>, Prisma__CustomerTaskDetailsClient<CustomerTaskDetailsGetPayload<T>>>

    /**
     * Count the number of CustomerTaskDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTaskDetailsCountArgs} args - Arguments to filter CustomerTaskDetails to count.
     * @example
     * // Count the number of CustomerTaskDetails
     * const count = await prisma.customerTaskDetails.count({
     *   where: {
     *     // ... the filter for the CustomerTaskDetails we want to count
     *   }
     * })
    **/
    count<T extends CustomerTaskDetailsCountArgs>(
      args?: Subset<T, CustomerTaskDetailsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerTaskDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerTaskDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTaskDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerTaskDetailsAggregateArgs>(args: Subset<T, CustomerTaskDetailsAggregateArgs>): PrismaPromise<GetCustomerTaskDetailsAggregateType<T>>

    /**
     * Group by CustomerTaskDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTaskDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerTaskDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerTaskDetailsGroupByArgs['orderBy'] }
        : { orderBy?: CustomerTaskDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerTaskDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerTaskDetailsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerTaskDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomerTaskDetailsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Accounts<T extends AccountsArgs = {}>(args?: Subset<T, AccountsArgs>): CheckSelect<T, Prisma__AccountsClient<Accounts | Null>, Prisma__AccountsClient<AccountsGetPayload<T> | Null>>;

    Customers<T extends CustomersArgs = {}>(args?: Subset<T, CustomersArgs>): CheckSelect<T, Prisma__CustomersClient<Customers | Null>, Prisma__CustomersClient<CustomersGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CustomerTaskDetails base type for findUnique actions
   */
  export type CustomerTaskDetailsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CustomerTaskDetails
     * 
    **/
    select?: CustomerTaskDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerTaskDetailsInclude | null
    /**
     * Filter, which CustomerTaskDetails to fetch.
     * 
    **/
    where: CustomerTaskDetailsWhereUniqueInput
  }

  /**
   * CustomerTaskDetails: findUnique
   */
  export interface CustomerTaskDetailsFindUniqueArgs extends CustomerTaskDetailsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CustomerTaskDetails base type for findFirst actions
   */
  export type CustomerTaskDetailsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CustomerTaskDetails
     * 
    **/
    select?: CustomerTaskDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerTaskDetailsInclude | null
    /**
     * Filter, which CustomerTaskDetails to fetch.
     * 
    **/
    where?: CustomerTaskDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerTaskDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerTaskDetailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerTaskDetails.
     * 
    **/
    cursor?: CustomerTaskDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerTaskDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerTaskDetails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerTaskDetails.
     * 
    **/
    distinct?: Enumerable<CustomerTaskDetailsScalarFieldEnum>
  }

  /**
   * CustomerTaskDetails: findFirst
   */
  export interface CustomerTaskDetailsFindFirstArgs extends CustomerTaskDetailsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CustomerTaskDetails findMany
   */
  export type CustomerTaskDetailsFindManyArgs = {
    /**
     * Select specific fields to fetch from the CustomerTaskDetails
     * 
    **/
    select?: CustomerTaskDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerTaskDetailsInclude | null
    /**
     * Filter, which CustomerTaskDetails to fetch.
     * 
    **/
    where?: CustomerTaskDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerTaskDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerTaskDetailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerTaskDetails.
     * 
    **/
    cursor?: CustomerTaskDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerTaskDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerTaskDetails.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CustomerTaskDetailsScalarFieldEnum>
  }


  /**
   * CustomerTaskDetails create
   */
  export type CustomerTaskDetailsCreateArgs = {
    /**
     * Select specific fields to fetch from the CustomerTaskDetails
     * 
    **/
    select?: CustomerTaskDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerTaskDetailsInclude | null
    /**
     * The data needed to create a CustomerTaskDetails.
     * 
    **/
    data: XOR<CustomerTaskDetailsCreateInput, CustomerTaskDetailsUncheckedCreateInput>
  }


  /**
   * CustomerTaskDetails createMany
   */
  export type CustomerTaskDetailsCreateManyArgs = {
    /**
     * The data used to create many CustomerTaskDetails.
     * 
    **/
    data: Enumerable<CustomerTaskDetailsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CustomerTaskDetails update
   */
  export type CustomerTaskDetailsUpdateArgs = {
    /**
     * Select specific fields to fetch from the CustomerTaskDetails
     * 
    **/
    select?: CustomerTaskDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerTaskDetailsInclude | null
    /**
     * The data needed to update a CustomerTaskDetails.
     * 
    **/
    data: XOR<CustomerTaskDetailsUpdateInput, CustomerTaskDetailsUncheckedUpdateInput>
    /**
     * Choose, which CustomerTaskDetails to update.
     * 
    **/
    where: CustomerTaskDetailsWhereUniqueInput
  }


  /**
   * CustomerTaskDetails updateMany
   */
  export type CustomerTaskDetailsUpdateManyArgs = {
    /**
     * The data used to update CustomerTaskDetails.
     * 
    **/
    data: XOR<CustomerTaskDetailsUpdateManyMutationInput, CustomerTaskDetailsUncheckedUpdateManyInput>
    /**
     * Filter which CustomerTaskDetails to update
     * 
    **/
    where?: CustomerTaskDetailsWhereInput
  }


  /**
   * CustomerTaskDetails upsert
   */
  export type CustomerTaskDetailsUpsertArgs = {
    /**
     * Select specific fields to fetch from the CustomerTaskDetails
     * 
    **/
    select?: CustomerTaskDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerTaskDetailsInclude | null
    /**
     * The filter to search for the CustomerTaskDetails to update in case it exists.
     * 
    **/
    where: CustomerTaskDetailsWhereUniqueInput
    /**
     * In case the CustomerTaskDetails found by the `where` argument doesn't exist, create a new CustomerTaskDetails with this data.
     * 
    **/
    create: XOR<CustomerTaskDetailsCreateInput, CustomerTaskDetailsUncheckedCreateInput>
    /**
     * In case the CustomerTaskDetails was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CustomerTaskDetailsUpdateInput, CustomerTaskDetailsUncheckedUpdateInput>
  }


  /**
   * CustomerTaskDetails delete
   */
  export type CustomerTaskDetailsDeleteArgs = {
    /**
     * Select specific fields to fetch from the CustomerTaskDetails
     * 
    **/
    select?: CustomerTaskDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerTaskDetailsInclude | null
    /**
     * Filter which CustomerTaskDetails to delete.
     * 
    **/
    where: CustomerTaskDetailsWhereUniqueInput
  }


  /**
   * CustomerTaskDetails deleteMany
   */
  export type CustomerTaskDetailsDeleteManyArgs = {
    /**
     * Filter which CustomerTaskDetails to delete
     * 
    **/
    where?: CustomerTaskDetailsWhereInput
  }


  /**
   * CustomerTaskDetails: findUniqueOrThrow
   */
  export type CustomerTaskDetailsFindUniqueOrThrowArgs = CustomerTaskDetailsFindUniqueArgsBase
      

  /**
   * CustomerTaskDetails: findFirstOrThrow
   */
  export type CustomerTaskDetailsFindFirstOrThrowArgs = CustomerTaskDetailsFindFirstArgsBase
      

  /**
   * CustomerTaskDetails without action
   */
  export type CustomerTaskDetailsArgs = {
    /**
     * Select specific fields to fetch from the CustomerTaskDetails
     * 
    **/
    select?: CustomerTaskDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerTaskDetailsInclude | null
  }



  /**
   * Model Customers
   */


  export type AggregateCustomers = {
    _count: CustomersCountAggregateOutputType | null
    _avg: CustomersAvgAggregateOutputType | null
    _sum: CustomersSumAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  export type CustomersAvgAggregateOutputType = {
    id: number | null
    AccountId: number | null
  }

  export type CustomersSumAggregateOutputType = {
    id: number | null
    AccountId: number | null
  }

  export type CustomersMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    AccountId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomersMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    AccountId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomersCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    crops: number
    AccountId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomersAvgAggregateInputType = {
    id?: true
    AccountId?: true
  }

  export type CustomersSumAggregateInputType = {
    id?: true
    AccountId?: true
  }

  export type CustomersMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    AccountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomersMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    AccountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomersCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    crops?: true
    AccountId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomersAggregateArgs = {
    /**
     * Filter which Customers to aggregate.
     * 
    **/
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomersMaxAggregateInputType
  }

  export type GetCustomersAggregateType<T extends CustomersAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomers[P]>
      : GetScalarType<T[P], AggregateCustomers[P]>
  }




  export type CustomersGroupByArgs = {
    where?: CustomersWhereInput
    orderBy?: Enumerable<CustomersOrderByWithAggregationInput>
    by: Array<CustomersScalarFieldEnum>
    having?: CustomersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomersCountAggregateInputType | true
    _avg?: CustomersAvgAggregateInputType
    _sum?: CustomersSumAggregateInputType
    _min?: CustomersMinAggregateInputType
    _max?: CustomersMaxAggregateInputType
  }


  export type CustomersGroupByOutputType = {
    id: number
    name: string | null
    email: string | null
    phone: string | null
    crops: string[]
    AccountId: number | null
    createdAt: Date
    updatedAt: Date
    _count: CustomersCountAggregateOutputType | null
    _avg: CustomersAvgAggregateOutputType | null
    _sum: CustomersSumAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  type GetCustomersGroupByPayload<T extends CustomersGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CustomersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomersGroupByOutputType[P]>
            : GetScalarType<T[P], CustomersGroupByOutputType[P]>
        }
      >
    >


  export type CustomersSelect = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    crops?: boolean
    AccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Accounts?: boolean | AccountsArgs
    CustomerTaskDetails?: boolean | CustomerTaskDetailsFindManyArgs
    _count?: boolean | CustomersCountOutputTypeArgs
  }

  export type CustomersInclude = {
    Accounts?: boolean | AccountsArgs
    CustomerTaskDetails?: boolean | CustomerTaskDetailsFindManyArgs
    _count?: boolean | CustomersCountOutputTypeArgs
  }

  export type CustomersGetPayload<
    S extends boolean | null | undefined | CustomersArgs,
    U = keyof S
      > = S extends true
        ? Customers
    : S extends undefined
    ? never
    : S extends CustomersArgs | CustomersFindManyArgs
    ?'include' extends U
    ? Customers  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'CustomerTaskDetails' ? Array < CustomerTaskDetailsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? CustomersCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'CustomerTaskDetails' ? Array < CustomerTaskDetailsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? CustomersCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Customers ? Customers[P] : never
  } 
    : Customers
  : Customers


  type CustomersCountArgs = Merge<
    Omit<CustomersFindManyArgs, 'select' | 'include'> & {
      select?: CustomersCountAggregateInputType | true
    }
  >

  export interface CustomersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Customers that matches the filter.
     * @param {CustomersFindUniqueArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Customers'> extends True ? CheckSelect<T, Prisma__CustomersClient<Customers>, Prisma__CustomersClient<CustomersGetPayload<T>>> : CheckSelect<T, Prisma__CustomersClient<Customers | null, null>, Prisma__CustomersClient<CustomersGetPayload<T> | null, null>>

    /**
     * Find the first Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindFirstArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Customers'> extends True ? CheckSelect<T, Prisma__CustomersClient<Customers>, Prisma__CustomersClient<CustomersGetPayload<T>>> : CheckSelect<T, Prisma__CustomersClient<Customers | null, null>, Prisma__CustomersClient<CustomersGetPayload<T> | null, null>>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customers.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customersWithIdOnly = await prisma.customers.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CustomersFindManyArgs>(
      args?: SelectSubset<T, CustomersFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Customers>>, PrismaPromise<Array<CustomersGetPayload<T>>>>

    /**
     * Create a Customers.
     * @param {CustomersCreateArgs} args - Arguments to create a Customers.
     * @example
     * // Create one Customers
     * const Customers = await prisma.customers.create({
     *   data: {
     *     // ... data to create a Customers
     *   }
     * })
     * 
    **/
    create<T extends CustomersCreateArgs>(
      args: SelectSubset<T, CustomersCreateArgs>
    ): CheckSelect<T, Prisma__CustomersClient<Customers>, Prisma__CustomersClient<CustomersGetPayload<T>>>

    /**
     * Create many Customers.
     *     @param {CustomersCreateManyArgs} args - Arguments to create many Customers.
     *     @example
     *     // Create many Customers
     *     const customers = await prisma.customers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomersCreateManyArgs>(
      args?: SelectSubset<T, CustomersCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Customers.
     * @param {CustomersDeleteArgs} args - Arguments to delete one Customers.
     * @example
     * // Delete one Customers
     * const Customers = await prisma.customers.delete({
     *   where: {
     *     // ... filter to delete one Customers
     *   }
     * })
     * 
    **/
    delete<T extends CustomersDeleteArgs>(
      args: SelectSubset<T, CustomersDeleteArgs>
    ): CheckSelect<T, Prisma__CustomersClient<Customers>, Prisma__CustomersClient<CustomersGetPayload<T>>>

    /**
     * Update one Customers.
     * @param {CustomersUpdateArgs} args - Arguments to update one Customers.
     * @example
     * // Update one Customers
     * const customers = await prisma.customers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomersUpdateArgs>(
      args: SelectSubset<T, CustomersUpdateArgs>
    ): CheckSelect<T, Prisma__CustomersClient<Customers>, Prisma__CustomersClient<CustomersGetPayload<T>>>

    /**
     * Delete zero or more Customers.
     * @param {CustomersDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomersDeleteManyArgs>(
      args?: SelectSubset<T, CustomersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customers = await prisma.customers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomersUpdateManyArgs>(
      args: SelectSubset<T, CustomersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Customers.
     * @param {CustomersUpsertArgs} args - Arguments to update or create a Customers.
     * @example
     * // Update or create a Customers
     * const customers = await prisma.customers.upsert({
     *   create: {
     *     // ... data to create a Customers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customers we want to update
     *   }
     * })
    **/
    upsert<T extends CustomersUpsertArgs>(
      args: SelectSubset<T, CustomersUpsertArgs>
    ): CheckSelect<T, Prisma__CustomersClient<Customers>, Prisma__CustomersClient<CustomersGetPayload<T>>>

    /**
     * Find one Customers that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CustomersFindUniqueOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CustomersFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CustomersClient<Customers>, Prisma__CustomersClient<CustomersGetPayload<T>>>

    /**
     * Find the first Customers that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindFirstOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CustomersFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CustomersClient<Customers>, Prisma__CustomersClient<CustomersGetPayload<T>>>

    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customers.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomersCountArgs>(
      args?: Subset<T, CustomersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomersAggregateArgs>(args: Subset<T, CustomersAggregateArgs>): PrismaPromise<GetCustomersAggregateType<T>>

    /**
     * Group by Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomersGroupByArgs['orderBy'] }
        : { orderBy?: CustomersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomersGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Customers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomersClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Accounts<T extends AccountsArgs = {}>(args?: Subset<T, AccountsArgs>): CheckSelect<T, Prisma__AccountsClient<Accounts | Null>, Prisma__AccountsClient<AccountsGetPayload<T> | Null>>;

    CustomerTaskDetails<T extends CustomerTaskDetailsFindManyArgs = {}>(args?: Subset<T, CustomerTaskDetailsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CustomerTaskDetails>| Null>, PrismaPromise<Array<CustomerTaskDetailsGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Customers base type for findUnique actions
   */
  export type CustomersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Customers
     * 
    **/
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomersInclude | null
    /**
     * Filter, which Customers to fetch.
     * 
    **/
    where: CustomersWhereUniqueInput
  }

  /**
   * Customers: findUnique
   */
  export interface CustomersFindUniqueArgs extends CustomersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Customers base type for findFirst actions
   */
  export type CustomersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Customers
     * 
    **/
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomersInclude | null
    /**
     * Filter, which Customers to fetch.
     * 
    **/
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     * 
    **/
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     * 
    **/
    distinct?: Enumerable<CustomersScalarFieldEnum>
  }

  /**
   * Customers: findFirst
   */
  export interface CustomersFindFirstArgs extends CustomersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Customers findMany
   */
  export type CustomersFindManyArgs = {
    /**
     * Select specific fields to fetch from the Customers
     * 
    **/
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomersInclude | null
    /**
     * Filter, which Customers to fetch.
     * 
    **/
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     * 
    **/
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CustomersScalarFieldEnum>
  }


  /**
   * Customers create
   */
  export type CustomersCreateArgs = {
    /**
     * Select specific fields to fetch from the Customers
     * 
    **/
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomersInclude | null
    /**
     * The data needed to create a Customers.
     * 
    **/
    data: XOR<CustomersCreateInput, CustomersUncheckedCreateInput>
  }


  /**
   * Customers createMany
   */
  export type CustomersCreateManyArgs = {
    /**
     * The data used to create many Customers.
     * 
    **/
    data: Enumerable<CustomersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Customers update
   */
  export type CustomersUpdateArgs = {
    /**
     * Select specific fields to fetch from the Customers
     * 
    **/
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomersInclude | null
    /**
     * The data needed to update a Customers.
     * 
    **/
    data: XOR<CustomersUpdateInput, CustomersUncheckedUpdateInput>
    /**
     * Choose, which Customers to update.
     * 
    **/
    where: CustomersWhereUniqueInput
  }


  /**
   * Customers updateMany
   */
  export type CustomersUpdateManyArgs = {
    /**
     * The data used to update Customers.
     * 
    **/
    data: XOR<CustomersUpdateManyMutationInput, CustomersUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     * 
    **/
    where?: CustomersWhereInput
  }


  /**
   * Customers upsert
   */
  export type CustomersUpsertArgs = {
    /**
     * Select specific fields to fetch from the Customers
     * 
    **/
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomersInclude | null
    /**
     * The filter to search for the Customers to update in case it exists.
     * 
    **/
    where: CustomersWhereUniqueInput
    /**
     * In case the Customers found by the `where` argument doesn't exist, create a new Customers with this data.
     * 
    **/
    create: XOR<CustomersCreateInput, CustomersUncheckedCreateInput>
    /**
     * In case the Customers was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CustomersUpdateInput, CustomersUncheckedUpdateInput>
  }


  /**
   * Customers delete
   */
  export type CustomersDeleteArgs = {
    /**
     * Select specific fields to fetch from the Customers
     * 
    **/
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomersInclude | null
    /**
     * Filter which Customers to delete.
     * 
    **/
    where: CustomersWhereUniqueInput
  }


  /**
   * Customers deleteMany
   */
  export type CustomersDeleteManyArgs = {
    /**
     * Filter which Customers to delete
     * 
    **/
    where?: CustomersWhereInput
  }


  /**
   * Customers: findUniqueOrThrow
   */
  export type CustomersFindUniqueOrThrowArgs = CustomersFindUniqueArgsBase
      

  /**
   * Customers: findFirstOrThrow
   */
  export type CustomersFindFirstOrThrowArgs = CustomersFindFirstArgsBase
      

  /**
   * Customers without action
   */
  export type CustomersArgs = {
    /**
     * Select specific fields to fetch from the Customers
     * 
    **/
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomersInclude | null
  }



  /**
   * Model Discounts
   */


  export type AggregateDiscounts = {
    _count: DiscountsCountAggregateOutputType | null
    _avg: DiscountsAvgAggregateOutputType | null
    _sum: DiscountsSumAggregateOutputType | null
    _min: DiscountsMinAggregateOutputType | null
    _max: DiscountsMaxAggregateOutputType | null
  }

  export type DiscountsAvgAggregateOutputType = {
    id: number | null
    price: number | null
    AccountId: number | null
    OrderId: number | null
    CouponId: number | null
    ProductId: number | null
  }

  export type DiscountsSumAggregateOutputType = {
    id: number | null
    price: number | null
    AccountId: number | null
    OrderId: number | null
    CouponId: number | null
    ProductId: number | null
  }

  export type DiscountsMinAggregateOutputType = {
    id: number | null
    name: string | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
    AccountId: number | null
    OrderId: number | null
    CouponId: number | null
    ProductId: number | null
  }

  export type DiscountsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
    AccountId: number | null
    OrderId: number | null
    CouponId: number | null
    ProductId: number | null
  }

  export type DiscountsCountAggregateOutputType = {
    id: number
    name: number
    price: number
    createdAt: number
    updatedAt: number
    AccountId: number
    OrderId: number
    CouponId: number
    ProductId: number
    filters: number
    _all: number
  }


  export type DiscountsAvgAggregateInputType = {
    id?: true
    price?: true
    AccountId?: true
    OrderId?: true
    CouponId?: true
    ProductId?: true
  }

  export type DiscountsSumAggregateInputType = {
    id?: true
    price?: true
    AccountId?: true
    OrderId?: true
    CouponId?: true
    ProductId?: true
  }

  export type DiscountsMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    AccountId?: true
    OrderId?: true
    CouponId?: true
    ProductId?: true
  }

  export type DiscountsMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    AccountId?: true
    OrderId?: true
    CouponId?: true
    ProductId?: true
  }

  export type DiscountsCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    AccountId?: true
    OrderId?: true
    CouponId?: true
    ProductId?: true
    filters?: true
    _all?: true
  }

  export type DiscountsAggregateArgs = {
    /**
     * Filter which Discounts to aggregate.
     * 
    **/
    where?: DiscountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     * 
    **/
    orderBy?: Enumerable<DiscountsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DiscountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Discounts
    **/
    _count?: true | DiscountsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiscountsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiscountsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscountsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscountsMaxAggregateInputType
  }

  export type GetDiscountsAggregateType<T extends DiscountsAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscounts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscounts[P]>
      : GetScalarType<T[P], AggregateDiscounts[P]>
  }




  export type DiscountsGroupByArgs = {
    where?: DiscountsWhereInput
    orderBy?: Enumerable<DiscountsOrderByWithAggregationInput>
    by: Array<DiscountsScalarFieldEnum>
    having?: DiscountsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscountsCountAggregateInputType | true
    _avg?: DiscountsAvgAggregateInputType
    _sum?: DiscountsSumAggregateInputType
    _min?: DiscountsMinAggregateInputType
    _max?: DiscountsMaxAggregateInputType
  }


  export type DiscountsGroupByOutputType = {
    id: number
    name: string | null
    price: number | null
    createdAt: Date
    updatedAt: Date
    AccountId: number | null
    OrderId: number | null
    CouponId: number | null
    ProductId: number | null
    filters: JsonValue | null
    _count: DiscountsCountAggregateOutputType | null
    _avg: DiscountsAvgAggregateOutputType | null
    _sum: DiscountsSumAggregateOutputType | null
    _min: DiscountsMinAggregateOutputType | null
    _max: DiscountsMaxAggregateOutputType | null
  }

  type GetDiscountsGroupByPayload<T extends DiscountsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DiscountsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscountsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscountsGroupByOutputType[P]>
            : GetScalarType<T[P], DiscountsGroupByOutputType[P]>
        }
      >
    >


  export type DiscountsSelect = {
    id?: boolean
    name?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    AccountId?: boolean
    OrderId?: boolean
    CouponId?: boolean
    ProductId?: boolean
    filters?: boolean
    Accounts?: boolean | AccountsArgs
    Coupons?: boolean | CouponsArgs
    Orders?: boolean | OrdersArgs
    Products?: boolean | ProductsArgs
  }

  export type DiscountsInclude = {
    Accounts?: boolean | AccountsArgs
    Coupons?: boolean | CouponsArgs
    Orders?: boolean | OrdersArgs
    Products?: boolean | ProductsArgs
  }

  export type DiscountsGetPayload<
    S extends boolean | null | undefined | DiscountsArgs,
    U = keyof S
      > = S extends true
        ? Discounts
    : S extends undefined
    ? never
    : S extends DiscountsArgs | DiscountsFindManyArgs
    ?'include' extends U
    ? Discounts  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'Coupons' ? CouponsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'Orders' ? OrdersGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'Products' ? ProductsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'Coupons' ? CouponsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'Orders' ? OrdersGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'Products' ? ProductsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof Discounts ? Discounts[P] : never
  } 
    : Discounts
  : Discounts


  type DiscountsCountArgs = Merge<
    Omit<DiscountsFindManyArgs, 'select' | 'include'> & {
      select?: DiscountsCountAggregateInputType | true
    }
  >

  export interface DiscountsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Discounts that matches the filter.
     * @param {DiscountsFindUniqueArgs} args - Arguments to find a Discounts
     * @example
     * // Get one Discounts
     * const discounts = await prisma.discounts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DiscountsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DiscountsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Discounts'> extends True ? CheckSelect<T, Prisma__DiscountsClient<Discounts>, Prisma__DiscountsClient<DiscountsGetPayload<T>>> : CheckSelect<T, Prisma__DiscountsClient<Discounts | null, null>, Prisma__DiscountsClient<DiscountsGetPayload<T> | null, null>>

    /**
     * Find the first Discounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountsFindFirstArgs} args - Arguments to find a Discounts
     * @example
     * // Get one Discounts
     * const discounts = await prisma.discounts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DiscountsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DiscountsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Discounts'> extends True ? CheckSelect<T, Prisma__DiscountsClient<Discounts>, Prisma__DiscountsClient<DiscountsGetPayload<T>>> : CheckSelect<T, Prisma__DiscountsClient<Discounts | null, null>, Prisma__DiscountsClient<DiscountsGetPayload<T> | null, null>>

    /**
     * Find zero or more Discounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Discounts
     * const discounts = await prisma.discounts.findMany()
     * 
     * // Get first 10 Discounts
     * const discounts = await prisma.discounts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const discountsWithIdOnly = await prisma.discounts.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DiscountsFindManyArgs>(
      args?: SelectSubset<T, DiscountsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Discounts>>, PrismaPromise<Array<DiscountsGetPayload<T>>>>

    /**
     * Create a Discounts.
     * @param {DiscountsCreateArgs} args - Arguments to create a Discounts.
     * @example
     * // Create one Discounts
     * const Discounts = await prisma.discounts.create({
     *   data: {
     *     // ... data to create a Discounts
     *   }
     * })
     * 
    **/
    create<T extends DiscountsCreateArgs>(
      args: SelectSubset<T, DiscountsCreateArgs>
    ): CheckSelect<T, Prisma__DiscountsClient<Discounts>, Prisma__DiscountsClient<DiscountsGetPayload<T>>>

    /**
     * Create many Discounts.
     *     @param {DiscountsCreateManyArgs} args - Arguments to create many Discounts.
     *     @example
     *     // Create many Discounts
     *     const discounts = await prisma.discounts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DiscountsCreateManyArgs>(
      args?: SelectSubset<T, DiscountsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Discounts.
     * @param {DiscountsDeleteArgs} args - Arguments to delete one Discounts.
     * @example
     * // Delete one Discounts
     * const Discounts = await prisma.discounts.delete({
     *   where: {
     *     // ... filter to delete one Discounts
     *   }
     * })
     * 
    **/
    delete<T extends DiscountsDeleteArgs>(
      args: SelectSubset<T, DiscountsDeleteArgs>
    ): CheckSelect<T, Prisma__DiscountsClient<Discounts>, Prisma__DiscountsClient<DiscountsGetPayload<T>>>

    /**
     * Update one Discounts.
     * @param {DiscountsUpdateArgs} args - Arguments to update one Discounts.
     * @example
     * // Update one Discounts
     * const discounts = await prisma.discounts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DiscountsUpdateArgs>(
      args: SelectSubset<T, DiscountsUpdateArgs>
    ): CheckSelect<T, Prisma__DiscountsClient<Discounts>, Prisma__DiscountsClient<DiscountsGetPayload<T>>>

    /**
     * Delete zero or more Discounts.
     * @param {DiscountsDeleteManyArgs} args - Arguments to filter Discounts to delete.
     * @example
     * // Delete a few Discounts
     * const { count } = await prisma.discounts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DiscountsDeleteManyArgs>(
      args?: SelectSubset<T, DiscountsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Discounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Discounts
     * const discounts = await prisma.discounts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DiscountsUpdateManyArgs>(
      args: SelectSubset<T, DiscountsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Discounts.
     * @param {DiscountsUpsertArgs} args - Arguments to update or create a Discounts.
     * @example
     * // Update or create a Discounts
     * const discounts = await prisma.discounts.upsert({
     *   create: {
     *     // ... data to create a Discounts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Discounts we want to update
     *   }
     * })
    **/
    upsert<T extends DiscountsUpsertArgs>(
      args: SelectSubset<T, DiscountsUpsertArgs>
    ): CheckSelect<T, Prisma__DiscountsClient<Discounts>, Prisma__DiscountsClient<DiscountsGetPayload<T>>>

    /**
     * Find one Discounts that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {DiscountsFindUniqueOrThrowArgs} args - Arguments to find a Discounts
     * @example
     * // Get one Discounts
     * const discounts = await prisma.discounts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DiscountsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DiscountsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__DiscountsClient<Discounts>, Prisma__DiscountsClient<DiscountsGetPayload<T>>>

    /**
     * Find the first Discounts that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountsFindFirstOrThrowArgs} args - Arguments to find a Discounts
     * @example
     * // Get one Discounts
     * const discounts = await prisma.discounts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DiscountsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DiscountsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__DiscountsClient<Discounts>, Prisma__DiscountsClient<DiscountsGetPayload<T>>>

    /**
     * Count the number of Discounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountsCountArgs} args - Arguments to filter Discounts to count.
     * @example
     * // Count the number of Discounts
     * const count = await prisma.discounts.count({
     *   where: {
     *     // ... the filter for the Discounts we want to count
     *   }
     * })
    **/
    count<T extends DiscountsCountArgs>(
      args?: Subset<T, DiscountsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscountsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Discounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscountsAggregateArgs>(args: Subset<T, DiscountsAggregateArgs>): PrismaPromise<GetDiscountsAggregateType<T>>

    /**
     * Group by Discounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiscountsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiscountsGroupByArgs['orderBy'] }
        : { orderBy?: DiscountsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiscountsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscountsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Discounts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DiscountsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Accounts<T extends AccountsArgs = {}>(args?: Subset<T, AccountsArgs>): CheckSelect<T, Prisma__AccountsClient<Accounts | Null>, Prisma__AccountsClient<AccountsGetPayload<T> | Null>>;

    Coupons<T extends CouponsArgs = {}>(args?: Subset<T, CouponsArgs>): CheckSelect<T, Prisma__CouponsClient<Coupons | Null>, Prisma__CouponsClient<CouponsGetPayload<T> | Null>>;

    Orders<T extends OrdersArgs = {}>(args?: Subset<T, OrdersArgs>): CheckSelect<T, Prisma__OrdersClient<Orders | Null>, Prisma__OrdersClient<OrdersGetPayload<T> | Null>>;

    Products<T extends ProductsArgs = {}>(args?: Subset<T, ProductsArgs>): CheckSelect<T, Prisma__ProductsClient<Products | Null>, Prisma__ProductsClient<ProductsGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Discounts base type for findUnique actions
   */
  export type DiscountsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Discounts
     * 
    **/
    select?: DiscountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountsInclude | null
    /**
     * Filter, which Discounts to fetch.
     * 
    **/
    where: DiscountsWhereUniqueInput
  }

  /**
   * Discounts: findUnique
   */
  export interface DiscountsFindUniqueArgs extends DiscountsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Discounts base type for findFirst actions
   */
  export type DiscountsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Discounts
     * 
    **/
    select?: DiscountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountsInclude | null
    /**
     * Filter, which Discounts to fetch.
     * 
    **/
    where?: DiscountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     * 
    **/
    orderBy?: Enumerable<DiscountsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Discounts.
     * 
    **/
    cursor?: DiscountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Discounts.
     * 
    **/
    distinct?: Enumerable<DiscountsScalarFieldEnum>
  }

  /**
   * Discounts: findFirst
   */
  export interface DiscountsFindFirstArgs extends DiscountsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Discounts findMany
   */
  export type DiscountsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Discounts
     * 
    **/
    select?: DiscountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountsInclude | null
    /**
     * Filter, which Discounts to fetch.
     * 
    **/
    where?: DiscountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     * 
    **/
    orderBy?: Enumerable<DiscountsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Discounts.
     * 
    **/
    cursor?: DiscountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DiscountsScalarFieldEnum>
  }


  /**
   * Discounts create
   */
  export type DiscountsCreateArgs = {
    /**
     * Select specific fields to fetch from the Discounts
     * 
    **/
    select?: DiscountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountsInclude | null
    /**
     * The data needed to create a Discounts.
     * 
    **/
    data: XOR<DiscountsCreateInput, DiscountsUncheckedCreateInput>
  }


  /**
   * Discounts createMany
   */
  export type DiscountsCreateManyArgs = {
    /**
     * The data used to create many Discounts.
     * 
    **/
    data: Enumerable<DiscountsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Discounts update
   */
  export type DiscountsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Discounts
     * 
    **/
    select?: DiscountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountsInclude | null
    /**
     * The data needed to update a Discounts.
     * 
    **/
    data: XOR<DiscountsUpdateInput, DiscountsUncheckedUpdateInput>
    /**
     * Choose, which Discounts to update.
     * 
    **/
    where: DiscountsWhereUniqueInput
  }


  /**
   * Discounts updateMany
   */
  export type DiscountsUpdateManyArgs = {
    /**
     * The data used to update Discounts.
     * 
    **/
    data: XOR<DiscountsUpdateManyMutationInput, DiscountsUncheckedUpdateManyInput>
    /**
     * Filter which Discounts to update
     * 
    **/
    where?: DiscountsWhereInput
  }


  /**
   * Discounts upsert
   */
  export type DiscountsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Discounts
     * 
    **/
    select?: DiscountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountsInclude | null
    /**
     * The filter to search for the Discounts to update in case it exists.
     * 
    **/
    where: DiscountsWhereUniqueInput
    /**
     * In case the Discounts found by the `where` argument doesn't exist, create a new Discounts with this data.
     * 
    **/
    create: XOR<DiscountsCreateInput, DiscountsUncheckedCreateInput>
    /**
     * In case the Discounts was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DiscountsUpdateInput, DiscountsUncheckedUpdateInput>
  }


  /**
   * Discounts delete
   */
  export type DiscountsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Discounts
     * 
    **/
    select?: DiscountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountsInclude | null
    /**
     * Filter which Discounts to delete.
     * 
    **/
    where: DiscountsWhereUniqueInput
  }


  /**
   * Discounts deleteMany
   */
  export type DiscountsDeleteManyArgs = {
    /**
     * Filter which Discounts to delete
     * 
    **/
    where?: DiscountsWhereInput
  }


  /**
   * Discounts: findUniqueOrThrow
   */
  export type DiscountsFindUniqueOrThrowArgs = DiscountsFindUniqueArgsBase
      

  /**
   * Discounts: findFirstOrThrow
   */
  export type DiscountsFindFirstOrThrowArgs = DiscountsFindFirstArgsBase
      

  /**
   * Discounts without action
   */
  export type DiscountsArgs = {
    /**
     * Select specific fields to fetch from the Discounts
     * 
    **/
    select?: DiscountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountsInclude | null
  }



  /**
   * Model Events
   */


  export type AggregateEvents = {
    _count: EventsCountAggregateOutputType | null
    _avg: EventsAvgAggregateOutputType | null
    _sum: EventsSumAggregateOutputType | null
    _min: EventsMinAggregateOutputType | null
    _max: EventsMaxAggregateOutputType | null
  }

  export type EventsAvgAggregateOutputType = {
    id: number | null
    createdBy: number | null
  }

  export type EventsSumAggregateOutputType = {
    id: bigint | null
    createdBy: number | null
  }

  export type EventsMinAggregateOutputType = {
    id: bigint | null
    table: string | null
    action: string | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventsMaxAggregateOutputType = {
    id: bigint | null
    table: string | null
    action: string | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventsCountAggregateOutputType = {
    id: number
    table: number
    action: number
    createdBy: number
    data: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventsAvgAggregateInputType = {
    id?: true
    createdBy?: true
  }

  export type EventsSumAggregateInputType = {
    id?: true
    createdBy?: true
  }

  export type EventsMinAggregateInputType = {
    id?: true
    table?: true
    action?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventsMaxAggregateInputType = {
    id?: true
    table?: true
    action?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventsCountAggregateInputType = {
    id?: true
    table?: true
    action?: true
    createdBy?: true
    data?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventsAggregateArgs = {
    /**
     * Filter which Events to aggregate.
     * 
    **/
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     * 
    **/
    orderBy?: Enumerable<EventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventsMaxAggregateInputType
  }

  export type GetEventsAggregateType<T extends EventsAggregateArgs> = {
        [P in keyof T & keyof AggregateEvents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvents[P]>
      : GetScalarType<T[P], AggregateEvents[P]>
  }




  export type EventsGroupByArgs = {
    where?: EventsWhereInput
    orderBy?: Enumerable<EventsOrderByWithAggregationInput>
    by: Array<EventsScalarFieldEnum>
    having?: EventsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventsCountAggregateInputType | true
    _avg?: EventsAvgAggregateInputType
    _sum?: EventsSumAggregateInputType
    _min?: EventsMinAggregateInputType
    _max?: EventsMaxAggregateInputType
  }


  export type EventsGroupByOutputType = {
    id: bigint
    table: string
    action: string | null
    createdBy: number | null
    data: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: EventsCountAggregateOutputType | null
    _avg: EventsAvgAggregateOutputType | null
    _sum: EventsSumAggregateOutputType | null
    _min: EventsMinAggregateOutputType | null
    _max: EventsMaxAggregateOutputType | null
  }

  type GetEventsGroupByPayload<T extends EventsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EventsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventsGroupByOutputType[P]>
            : GetScalarType<T[P], EventsGroupByOutputType[P]>
        }
      >
    >


  export type EventsSelect = {
    id?: boolean
    table?: boolean
    action?: boolean
    createdBy?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventsGetPayload<
    S extends boolean | null | undefined | EventsArgs,
    U = keyof S
      > = S extends true
        ? Events
    : S extends undefined
    ? never
    : S extends EventsArgs | EventsFindManyArgs
    ?'include' extends U
    ? Events 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Events ? Events[P] : never
  } 
    : Events
  : Events


  type EventsCountArgs = Merge<
    Omit<EventsFindManyArgs, 'select' | 'include'> & {
      select?: EventsCountAggregateInputType | true
    }
  >

  export interface EventsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Events that matches the filter.
     * @param {EventsFindUniqueArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EventsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EventsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Events'> extends True ? CheckSelect<T, Prisma__EventsClient<Events>, Prisma__EventsClient<EventsGetPayload<T>>> : CheckSelect<T, Prisma__EventsClient<Events | null, null>, Prisma__EventsClient<EventsGetPayload<T> | null, null>>

    /**
     * Find the first Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsFindFirstArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EventsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EventsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Events'> extends True ? CheckSelect<T, Prisma__EventsClient<Events>, Prisma__EventsClient<EventsGetPayload<T>>> : CheckSelect<T, Prisma__EventsClient<Events | null, null>, Prisma__EventsClient<EventsGetPayload<T> | null, null>>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.events.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.events.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventsWithIdOnly = await prisma.events.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EventsFindManyArgs>(
      args?: SelectSubset<T, EventsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Events>>, PrismaPromise<Array<EventsGetPayload<T>>>>

    /**
     * Create a Events.
     * @param {EventsCreateArgs} args - Arguments to create a Events.
     * @example
     * // Create one Events
     * const Events = await prisma.events.create({
     *   data: {
     *     // ... data to create a Events
     *   }
     * })
     * 
    **/
    create<T extends EventsCreateArgs>(
      args: SelectSubset<T, EventsCreateArgs>
    ): CheckSelect<T, Prisma__EventsClient<Events>, Prisma__EventsClient<EventsGetPayload<T>>>

    /**
     * Create many Events.
     *     @param {EventsCreateManyArgs} args - Arguments to create many Events.
     *     @example
     *     // Create many Events
     *     const events = await prisma.events.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EventsCreateManyArgs>(
      args?: SelectSubset<T, EventsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Events.
     * @param {EventsDeleteArgs} args - Arguments to delete one Events.
     * @example
     * // Delete one Events
     * const Events = await prisma.events.delete({
     *   where: {
     *     // ... filter to delete one Events
     *   }
     * })
     * 
    **/
    delete<T extends EventsDeleteArgs>(
      args: SelectSubset<T, EventsDeleteArgs>
    ): CheckSelect<T, Prisma__EventsClient<Events>, Prisma__EventsClient<EventsGetPayload<T>>>

    /**
     * Update one Events.
     * @param {EventsUpdateArgs} args - Arguments to update one Events.
     * @example
     * // Update one Events
     * const events = await prisma.events.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EventsUpdateArgs>(
      args: SelectSubset<T, EventsUpdateArgs>
    ): CheckSelect<T, Prisma__EventsClient<Events>, Prisma__EventsClient<EventsGetPayload<T>>>

    /**
     * Delete zero or more Events.
     * @param {EventsDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.events.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EventsDeleteManyArgs>(
      args?: SelectSubset<T, EventsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const events = await prisma.events.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EventsUpdateManyArgs>(
      args: SelectSubset<T, EventsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Events.
     * @param {EventsUpsertArgs} args - Arguments to update or create a Events.
     * @example
     * // Update or create a Events
     * const events = await prisma.events.upsert({
     *   create: {
     *     // ... data to create a Events
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Events we want to update
     *   }
     * })
    **/
    upsert<T extends EventsUpsertArgs>(
      args: SelectSubset<T, EventsUpsertArgs>
    ): CheckSelect<T, Prisma__EventsClient<Events>, Prisma__EventsClient<EventsGetPayload<T>>>

    /**
     * Find one Events that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {EventsFindUniqueOrThrowArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EventsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, EventsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__EventsClient<Events>, Prisma__EventsClient<EventsGetPayload<T>>>

    /**
     * Find the first Events that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsFindFirstOrThrowArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EventsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EventsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__EventsClient<Events>, Prisma__EventsClient<EventsGetPayload<T>>>

    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.events.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventsCountArgs>(
      args?: Subset<T, EventsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventsAggregateArgs>(args: Subset<T, EventsAggregateArgs>): PrismaPromise<GetEventsAggregateType<T>>

    /**
     * Group by Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventsGroupByArgs['orderBy'] }
        : { orderBy?: EventsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Events.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EventsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Events base type for findUnique actions
   */
  export type EventsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Events
     * 
    **/
    select?: EventsSelect | null
    /**
     * Filter, which Events to fetch.
     * 
    **/
    where: EventsWhereUniqueInput
  }

  /**
   * Events: findUnique
   */
  export interface EventsFindUniqueArgs extends EventsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Events base type for findFirst actions
   */
  export type EventsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Events
     * 
    **/
    select?: EventsSelect | null
    /**
     * Filter, which Events to fetch.
     * 
    **/
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     * 
    **/
    orderBy?: Enumerable<EventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     * 
    **/
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     * 
    **/
    distinct?: Enumerable<EventsScalarFieldEnum>
  }

  /**
   * Events: findFirst
   */
  export interface EventsFindFirstArgs extends EventsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Events findMany
   */
  export type EventsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Events
     * 
    **/
    select?: EventsSelect | null
    /**
     * Filter, which Events to fetch.
     * 
    **/
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     * 
    **/
    orderBy?: Enumerable<EventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     * 
    **/
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EventsScalarFieldEnum>
  }


  /**
   * Events create
   */
  export type EventsCreateArgs = {
    /**
     * Select specific fields to fetch from the Events
     * 
    **/
    select?: EventsSelect | null
    /**
     * The data needed to create a Events.
     * 
    **/
    data: XOR<EventsCreateInput, EventsUncheckedCreateInput>
  }


  /**
   * Events createMany
   */
  export type EventsCreateManyArgs = {
    /**
     * The data used to create many Events.
     * 
    **/
    data: Enumerable<EventsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Events update
   */
  export type EventsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Events
     * 
    **/
    select?: EventsSelect | null
    /**
     * The data needed to update a Events.
     * 
    **/
    data: XOR<EventsUpdateInput, EventsUncheckedUpdateInput>
    /**
     * Choose, which Events to update.
     * 
    **/
    where: EventsWhereUniqueInput
  }


  /**
   * Events updateMany
   */
  export type EventsUpdateManyArgs = {
    /**
     * The data used to update Events.
     * 
    **/
    data: XOR<EventsUpdateManyMutationInput, EventsUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     * 
    **/
    where?: EventsWhereInput
  }


  /**
   * Events upsert
   */
  export type EventsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Events
     * 
    **/
    select?: EventsSelect | null
    /**
     * The filter to search for the Events to update in case it exists.
     * 
    **/
    where: EventsWhereUniqueInput
    /**
     * In case the Events found by the `where` argument doesn't exist, create a new Events with this data.
     * 
    **/
    create: XOR<EventsCreateInput, EventsUncheckedCreateInput>
    /**
     * In case the Events was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EventsUpdateInput, EventsUncheckedUpdateInput>
  }


  /**
   * Events delete
   */
  export type EventsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Events
     * 
    **/
    select?: EventsSelect | null
    /**
     * Filter which Events to delete.
     * 
    **/
    where: EventsWhereUniqueInput
  }


  /**
   * Events deleteMany
   */
  export type EventsDeleteManyArgs = {
    /**
     * Filter which Events to delete
     * 
    **/
    where?: EventsWhereInput
  }


  /**
   * Events: findUniqueOrThrow
   */
  export type EventsFindUniqueOrThrowArgs = EventsFindUniqueArgsBase
      

  /**
   * Events: findFirstOrThrow
   */
  export type EventsFindFirstOrThrowArgs = EventsFindFirstArgsBase
      

  /**
   * Events without action
   */
  export type EventsArgs = {
    /**
     * Select specific fields to fetch from the Events
     * 
    **/
    select?: EventsSelect | null
  }



  /**
   * Model Geos
   */


  export type AggregateGeos = {
    _count: GeosCountAggregateOutputType | null
    _avg: GeosAvgAggregateOutputType | null
    _sum: GeosSumAggregateOutputType | null
    _min: GeosMinAggregateOutputType | null
    _max: GeosMaxAggregateOutputType | null
  }

  export type GeosAvgAggregateOutputType = {
    id: number | null
    area: Decimal | null
  }

  export type GeosSumAggregateOutputType = {
    id: number | null
    area: Decimal | null
  }

  export type GeosMinAggregateOutputType = {
    id: number | null
    address: string | null
    x: string | null
    y: string | null
    pnu: string | null
    area: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GeosMaxAggregateOutputType = {
    id: number | null
    address: string | null
    x: string | null
    y: string | null
    pnu: string | null
    area: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GeosCountAggregateOutputType = {
    id: number
    address: number
    geometry: number
    x: number
    y: number
    pnu: number
    area: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GeosAvgAggregateInputType = {
    id?: true
    area?: true
  }

  export type GeosSumAggregateInputType = {
    id?: true
    area?: true
  }

  export type GeosMinAggregateInputType = {
    id?: true
    address?: true
    x?: true
    y?: true
    pnu?: true
    area?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GeosMaxAggregateInputType = {
    id?: true
    address?: true
    x?: true
    y?: true
    pnu?: true
    area?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GeosCountAggregateInputType = {
    id?: true
    address?: true
    geometry?: true
    x?: true
    y?: true
    pnu?: true
    area?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GeosAggregateArgs = {
    /**
     * Filter which Geos to aggregate.
     * 
    **/
    where?: GeosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Geos to fetch.
     * 
    **/
    orderBy?: Enumerable<GeosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: GeosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Geos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Geos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Geos
    **/
    _count?: true | GeosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GeosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GeosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GeosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GeosMaxAggregateInputType
  }

  export type GetGeosAggregateType<T extends GeosAggregateArgs> = {
        [P in keyof T & keyof AggregateGeos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeos[P]>
      : GetScalarType<T[P], AggregateGeos[P]>
  }




  export type GeosGroupByArgs = {
    where?: GeosWhereInput
    orderBy?: Enumerable<GeosOrderByWithAggregationInput>
    by: Array<GeosScalarFieldEnum>
    having?: GeosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GeosCountAggregateInputType | true
    _avg?: GeosAvgAggregateInputType
    _sum?: GeosSumAggregateInputType
    _min?: GeosMinAggregateInputType
    _max?: GeosMaxAggregateInputType
  }


  export type GeosGroupByOutputType = {
    id: number
    address: string | null
    geometry: JsonValue | null
    x: string | null
    y: string | null
    pnu: string | null
    area: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: GeosCountAggregateOutputType | null
    _avg: GeosAvgAggregateOutputType | null
    _sum: GeosSumAggregateOutputType | null
    _min: GeosMinAggregateOutputType | null
    _max: GeosMaxAggregateOutputType | null
  }

  type GetGeosGroupByPayload<T extends GeosGroupByArgs> = PrismaPromise<
    Array<
      PickArray<GeosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GeosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GeosGroupByOutputType[P]>
            : GetScalarType<T[P], GeosGroupByOutputType[P]>
        }
      >
    >


  export type GeosSelect = {
    id?: boolean
    address?: boolean
    geometry?: boolean
    x?: boolean
    y?: boolean
    pnu?: boolean
    area?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GeosGetPayload<
    S extends boolean | null | undefined | GeosArgs,
    U = keyof S
      > = S extends true
        ? Geos
    : S extends undefined
    ? never
    : S extends GeosArgs | GeosFindManyArgs
    ?'include' extends U
    ? Geos 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Geos ? Geos[P] : never
  } 
    : Geos
  : Geos


  type GeosCountArgs = Merge<
    Omit<GeosFindManyArgs, 'select' | 'include'> & {
      select?: GeosCountAggregateInputType | true
    }
  >

  export interface GeosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Geos that matches the filter.
     * @param {GeosFindUniqueArgs} args - Arguments to find a Geos
     * @example
     * // Get one Geos
     * const geos = await prisma.geos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GeosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GeosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Geos'> extends True ? CheckSelect<T, Prisma__GeosClient<Geos>, Prisma__GeosClient<GeosGetPayload<T>>> : CheckSelect<T, Prisma__GeosClient<Geos | null, null>, Prisma__GeosClient<GeosGetPayload<T> | null, null>>

    /**
     * Find the first Geos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeosFindFirstArgs} args - Arguments to find a Geos
     * @example
     * // Get one Geos
     * const geos = await prisma.geos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GeosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GeosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Geos'> extends True ? CheckSelect<T, Prisma__GeosClient<Geos>, Prisma__GeosClient<GeosGetPayload<T>>> : CheckSelect<T, Prisma__GeosClient<Geos | null, null>, Prisma__GeosClient<GeosGetPayload<T> | null, null>>

    /**
     * Find zero or more Geos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Geos
     * const geos = await prisma.geos.findMany()
     * 
     * // Get first 10 Geos
     * const geos = await prisma.geos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const geosWithIdOnly = await prisma.geos.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GeosFindManyArgs>(
      args?: SelectSubset<T, GeosFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Geos>>, PrismaPromise<Array<GeosGetPayload<T>>>>

    /**
     * Create a Geos.
     * @param {GeosCreateArgs} args - Arguments to create a Geos.
     * @example
     * // Create one Geos
     * const Geos = await prisma.geos.create({
     *   data: {
     *     // ... data to create a Geos
     *   }
     * })
     * 
    **/
    create<T extends GeosCreateArgs>(
      args: SelectSubset<T, GeosCreateArgs>
    ): CheckSelect<T, Prisma__GeosClient<Geos>, Prisma__GeosClient<GeosGetPayload<T>>>

    /**
     * Create many Geos.
     *     @param {GeosCreateManyArgs} args - Arguments to create many Geos.
     *     @example
     *     // Create many Geos
     *     const geos = await prisma.geos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GeosCreateManyArgs>(
      args?: SelectSubset<T, GeosCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Geos.
     * @param {GeosDeleteArgs} args - Arguments to delete one Geos.
     * @example
     * // Delete one Geos
     * const Geos = await prisma.geos.delete({
     *   where: {
     *     // ... filter to delete one Geos
     *   }
     * })
     * 
    **/
    delete<T extends GeosDeleteArgs>(
      args: SelectSubset<T, GeosDeleteArgs>
    ): CheckSelect<T, Prisma__GeosClient<Geos>, Prisma__GeosClient<GeosGetPayload<T>>>

    /**
     * Update one Geos.
     * @param {GeosUpdateArgs} args - Arguments to update one Geos.
     * @example
     * // Update one Geos
     * const geos = await prisma.geos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GeosUpdateArgs>(
      args: SelectSubset<T, GeosUpdateArgs>
    ): CheckSelect<T, Prisma__GeosClient<Geos>, Prisma__GeosClient<GeosGetPayload<T>>>

    /**
     * Delete zero or more Geos.
     * @param {GeosDeleteManyArgs} args - Arguments to filter Geos to delete.
     * @example
     * // Delete a few Geos
     * const { count } = await prisma.geos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GeosDeleteManyArgs>(
      args?: SelectSubset<T, GeosDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Geos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Geos
     * const geos = await prisma.geos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GeosUpdateManyArgs>(
      args: SelectSubset<T, GeosUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Geos.
     * @param {GeosUpsertArgs} args - Arguments to update or create a Geos.
     * @example
     * // Update or create a Geos
     * const geos = await prisma.geos.upsert({
     *   create: {
     *     // ... data to create a Geos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Geos we want to update
     *   }
     * })
    **/
    upsert<T extends GeosUpsertArgs>(
      args: SelectSubset<T, GeosUpsertArgs>
    ): CheckSelect<T, Prisma__GeosClient<Geos>, Prisma__GeosClient<GeosGetPayload<T>>>

    /**
     * Find one Geos that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {GeosFindUniqueOrThrowArgs} args - Arguments to find a Geos
     * @example
     * // Get one Geos
     * const geos = await prisma.geos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GeosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, GeosFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__GeosClient<Geos>, Prisma__GeosClient<GeosGetPayload<T>>>

    /**
     * Find the first Geos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeosFindFirstOrThrowArgs} args - Arguments to find a Geos
     * @example
     * // Get one Geos
     * const geos = await prisma.geos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GeosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, GeosFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__GeosClient<Geos>, Prisma__GeosClient<GeosGetPayload<T>>>

    /**
     * Count the number of Geos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeosCountArgs} args - Arguments to filter Geos to count.
     * @example
     * // Count the number of Geos
     * const count = await prisma.geos.count({
     *   where: {
     *     // ... the filter for the Geos we want to count
     *   }
     * })
    **/
    count<T extends GeosCountArgs>(
      args?: Subset<T, GeosCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GeosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Geos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GeosAggregateArgs>(args: Subset<T, GeosAggregateArgs>): PrismaPromise<GetGeosAggregateType<T>>

    /**
     * Group by Geos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GeosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GeosGroupByArgs['orderBy'] }
        : { orderBy?: GeosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GeosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGeosGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Geos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GeosClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Geos base type for findUnique actions
   */
  export type GeosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Geos
     * 
    **/
    select?: GeosSelect | null
    /**
     * Filter, which Geos to fetch.
     * 
    **/
    where: GeosWhereUniqueInput
  }

  /**
   * Geos: findUnique
   */
  export interface GeosFindUniqueArgs extends GeosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Geos base type for findFirst actions
   */
  export type GeosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Geos
     * 
    **/
    select?: GeosSelect | null
    /**
     * Filter, which Geos to fetch.
     * 
    **/
    where?: GeosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Geos to fetch.
     * 
    **/
    orderBy?: Enumerable<GeosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Geos.
     * 
    **/
    cursor?: GeosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Geos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Geos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Geos.
     * 
    **/
    distinct?: Enumerable<GeosScalarFieldEnum>
  }

  /**
   * Geos: findFirst
   */
  export interface GeosFindFirstArgs extends GeosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Geos findMany
   */
  export type GeosFindManyArgs = {
    /**
     * Select specific fields to fetch from the Geos
     * 
    **/
    select?: GeosSelect | null
    /**
     * Filter, which Geos to fetch.
     * 
    **/
    where?: GeosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Geos to fetch.
     * 
    **/
    orderBy?: Enumerable<GeosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Geos.
     * 
    **/
    cursor?: GeosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Geos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Geos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GeosScalarFieldEnum>
  }


  /**
   * Geos create
   */
  export type GeosCreateArgs = {
    /**
     * Select specific fields to fetch from the Geos
     * 
    **/
    select?: GeosSelect | null
    /**
     * The data needed to create a Geos.
     * 
    **/
    data: XOR<GeosCreateInput, GeosUncheckedCreateInput>
  }


  /**
   * Geos createMany
   */
  export type GeosCreateManyArgs = {
    /**
     * The data used to create many Geos.
     * 
    **/
    data: Enumerable<GeosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Geos update
   */
  export type GeosUpdateArgs = {
    /**
     * Select specific fields to fetch from the Geos
     * 
    **/
    select?: GeosSelect | null
    /**
     * The data needed to update a Geos.
     * 
    **/
    data: XOR<GeosUpdateInput, GeosUncheckedUpdateInput>
    /**
     * Choose, which Geos to update.
     * 
    **/
    where: GeosWhereUniqueInput
  }


  /**
   * Geos updateMany
   */
  export type GeosUpdateManyArgs = {
    /**
     * The data used to update Geos.
     * 
    **/
    data: XOR<GeosUpdateManyMutationInput, GeosUncheckedUpdateManyInput>
    /**
     * Filter which Geos to update
     * 
    **/
    where?: GeosWhereInput
  }


  /**
   * Geos upsert
   */
  export type GeosUpsertArgs = {
    /**
     * Select specific fields to fetch from the Geos
     * 
    **/
    select?: GeosSelect | null
    /**
     * The filter to search for the Geos to update in case it exists.
     * 
    **/
    where: GeosWhereUniqueInput
    /**
     * In case the Geos found by the `where` argument doesn't exist, create a new Geos with this data.
     * 
    **/
    create: XOR<GeosCreateInput, GeosUncheckedCreateInput>
    /**
     * In case the Geos was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<GeosUpdateInput, GeosUncheckedUpdateInput>
  }


  /**
   * Geos delete
   */
  export type GeosDeleteArgs = {
    /**
     * Select specific fields to fetch from the Geos
     * 
    **/
    select?: GeosSelect | null
    /**
     * Filter which Geos to delete.
     * 
    **/
    where: GeosWhereUniqueInput
  }


  /**
   * Geos deleteMany
   */
  export type GeosDeleteManyArgs = {
    /**
     * Filter which Geos to delete
     * 
    **/
    where?: GeosWhereInput
  }


  /**
   * Geos: findUniqueOrThrow
   */
  export type GeosFindUniqueOrThrowArgs = GeosFindUniqueArgsBase
      

  /**
   * Geos: findFirstOrThrow
   */
  export type GeosFindFirstOrThrowArgs = GeosFindFirstArgsBase
      

  /**
   * Geos without action
   */
  export type GeosArgs = {
    /**
     * Select specific fields to fetch from the Geos
     * 
    **/
    select?: GeosSelect | null
  }



  /**
   * Model Lands
   */


  export type AggregateLands = {
    _count: LandsCountAggregateOutputType | null
    _avg: LandsAvgAggregateOutputType | null
    _sum: LandsSumAggregateOutputType | null
    _min: LandsMinAggregateOutputType | null
    _max: LandsMaxAggregateOutputType | null
  }

  export type LandsAvgAggregateOutputType = {
    id: number | null
    AccountId: number | null
    area: Decimal | null
  }

  export type LandsSumAggregateOutputType = {
    id: bigint | null
    AccountId: number | null
    area: Decimal | null
  }

  export type LandsMinAggregateOutputType = {
    id: bigint | null
    AccountId: number | null
    is_active: boolean | null
    type: string | null
    villageName: string | null
    status: string | null
    x: string | null
    y: string | null
    area: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LandsMaxAggregateOutputType = {
    id: bigint | null
    AccountId: number | null
    is_active: boolean | null
    type: string | null
    villageName: string | null
    status: string | null
    x: string | null
    y: string | null
    area: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LandsCountAggregateOutputType = {
    id: number
    AccountId: number
    is_active: number
    type: number
    villageName: number
    status: number
    geometry: number
    x: number
    y: number
    area: number
    extra: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LandsAvgAggregateInputType = {
    id?: true
    AccountId?: true
    area?: true
  }

  export type LandsSumAggregateInputType = {
    id?: true
    AccountId?: true
    area?: true
  }

  export type LandsMinAggregateInputType = {
    id?: true
    AccountId?: true
    is_active?: true
    type?: true
    villageName?: true
    status?: true
    x?: true
    y?: true
    area?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LandsMaxAggregateInputType = {
    id?: true
    AccountId?: true
    is_active?: true
    type?: true
    villageName?: true
    status?: true
    x?: true
    y?: true
    area?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LandsCountAggregateInputType = {
    id?: true
    AccountId?: true
    is_active?: true
    type?: true
    villageName?: true
    status?: true
    geometry?: true
    x?: true
    y?: true
    area?: true
    extra?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LandsAggregateArgs = {
    /**
     * Filter which Lands to aggregate.
     * 
    **/
    where?: LandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lands to fetch.
     * 
    **/
    orderBy?: Enumerable<LandsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: LandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lands from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lands.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lands
    **/
    _count?: true | LandsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LandsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LandsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LandsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LandsMaxAggregateInputType
  }

  export type GetLandsAggregateType<T extends LandsAggregateArgs> = {
        [P in keyof T & keyof AggregateLands]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLands[P]>
      : GetScalarType<T[P], AggregateLands[P]>
  }




  export type LandsGroupByArgs = {
    where?: LandsWhereInput
    orderBy?: Enumerable<LandsOrderByWithAggregationInput>
    by: Array<LandsScalarFieldEnum>
    having?: LandsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LandsCountAggregateInputType | true
    _avg?: LandsAvgAggregateInputType
    _sum?: LandsSumAggregateInputType
    _min?: LandsMinAggregateInputType
    _max?: LandsMaxAggregateInputType
  }


  export type LandsGroupByOutputType = {
    id: bigint
    AccountId: number
    is_active: boolean | null
    type: string | null
    villageName: string | null
    status: string | null
    geometry: JsonValue | null
    x: string | null
    y: string | null
    area: Decimal | null
    extra: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: LandsCountAggregateOutputType | null
    _avg: LandsAvgAggregateOutputType | null
    _sum: LandsSumAggregateOutputType | null
    _min: LandsMinAggregateOutputType | null
    _max: LandsMaxAggregateOutputType | null
  }

  type GetLandsGroupByPayload<T extends LandsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<LandsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LandsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LandsGroupByOutputType[P]>
            : GetScalarType<T[P], LandsGroupByOutputType[P]>
        }
      >
    >


  export type LandsSelect = {
    id?: boolean
    AccountId?: boolean
    is_active?: boolean
    type?: boolean
    villageName?: boolean
    status?: boolean
    geometry?: boolean
    x?: boolean
    y?: boolean
    area?: boolean
    extra?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Accounts?: boolean | AccountsArgs
  }

  export type LandsInclude = {
    Accounts?: boolean | AccountsArgs
  }

  export type LandsGetPayload<
    S extends boolean | null | undefined | LandsArgs,
    U = keyof S
      > = S extends true
        ? Lands
    : S extends undefined
    ? never
    : S extends LandsArgs | LandsFindManyArgs
    ?'include' extends U
    ? Lands  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Lands ? Lands[P] : never
  } 
    : Lands
  : Lands


  type LandsCountArgs = Merge<
    Omit<LandsFindManyArgs, 'select' | 'include'> & {
      select?: LandsCountAggregateInputType | true
    }
  >

  export interface LandsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Lands that matches the filter.
     * @param {LandsFindUniqueArgs} args - Arguments to find a Lands
     * @example
     * // Get one Lands
     * const lands = await prisma.lands.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LandsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LandsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Lands'> extends True ? CheckSelect<T, Prisma__LandsClient<Lands>, Prisma__LandsClient<LandsGetPayload<T>>> : CheckSelect<T, Prisma__LandsClient<Lands | null, null>, Prisma__LandsClient<LandsGetPayload<T> | null, null>>

    /**
     * Find the first Lands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandsFindFirstArgs} args - Arguments to find a Lands
     * @example
     * // Get one Lands
     * const lands = await prisma.lands.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LandsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LandsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Lands'> extends True ? CheckSelect<T, Prisma__LandsClient<Lands>, Prisma__LandsClient<LandsGetPayload<T>>> : CheckSelect<T, Prisma__LandsClient<Lands | null, null>, Prisma__LandsClient<LandsGetPayload<T> | null, null>>

    /**
     * Find zero or more Lands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lands
     * const lands = await prisma.lands.findMany()
     * 
     * // Get first 10 Lands
     * const lands = await prisma.lands.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const landsWithIdOnly = await prisma.lands.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LandsFindManyArgs>(
      args?: SelectSubset<T, LandsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Lands>>, PrismaPromise<Array<LandsGetPayload<T>>>>

    /**
     * Create a Lands.
     * @param {LandsCreateArgs} args - Arguments to create a Lands.
     * @example
     * // Create one Lands
     * const Lands = await prisma.lands.create({
     *   data: {
     *     // ... data to create a Lands
     *   }
     * })
     * 
    **/
    create<T extends LandsCreateArgs>(
      args: SelectSubset<T, LandsCreateArgs>
    ): CheckSelect<T, Prisma__LandsClient<Lands>, Prisma__LandsClient<LandsGetPayload<T>>>

    /**
     * Create many Lands.
     *     @param {LandsCreateManyArgs} args - Arguments to create many Lands.
     *     @example
     *     // Create many Lands
     *     const lands = await prisma.lands.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LandsCreateManyArgs>(
      args?: SelectSubset<T, LandsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Lands.
     * @param {LandsDeleteArgs} args - Arguments to delete one Lands.
     * @example
     * // Delete one Lands
     * const Lands = await prisma.lands.delete({
     *   where: {
     *     // ... filter to delete one Lands
     *   }
     * })
     * 
    **/
    delete<T extends LandsDeleteArgs>(
      args: SelectSubset<T, LandsDeleteArgs>
    ): CheckSelect<T, Prisma__LandsClient<Lands>, Prisma__LandsClient<LandsGetPayload<T>>>

    /**
     * Update one Lands.
     * @param {LandsUpdateArgs} args - Arguments to update one Lands.
     * @example
     * // Update one Lands
     * const lands = await prisma.lands.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LandsUpdateArgs>(
      args: SelectSubset<T, LandsUpdateArgs>
    ): CheckSelect<T, Prisma__LandsClient<Lands>, Prisma__LandsClient<LandsGetPayload<T>>>

    /**
     * Delete zero or more Lands.
     * @param {LandsDeleteManyArgs} args - Arguments to filter Lands to delete.
     * @example
     * // Delete a few Lands
     * const { count } = await prisma.lands.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LandsDeleteManyArgs>(
      args?: SelectSubset<T, LandsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lands
     * const lands = await prisma.lands.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LandsUpdateManyArgs>(
      args: SelectSubset<T, LandsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Lands.
     * @param {LandsUpsertArgs} args - Arguments to update or create a Lands.
     * @example
     * // Update or create a Lands
     * const lands = await prisma.lands.upsert({
     *   create: {
     *     // ... data to create a Lands
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lands we want to update
     *   }
     * })
    **/
    upsert<T extends LandsUpsertArgs>(
      args: SelectSubset<T, LandsUpsertArgs>
    ): CheckSelect<T, Prisma__LandsClient<Lands>, Prisma__LandsClient<LandsGetPayload<T>>>

    /**
     * Find one Lands that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {LandsFindUniqueOrThrowArgs} args - Arguments to find a Lands
     * @example
     * // Get one Lands
     * const lands = await prisma.lands.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LandsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LandsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__LandsClient<Lands>, Prisma__LandsClient<LandsGetPayload<T>>>

    /**
     * Find the first Lands that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandsFindFirstOrThrowArgs} args - Arguments to find a Lands
     * @example
     * // Get one Lands
     * const lands = await prisma.lands.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LandsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LandsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__LandsClient<Lands>, Prisma__LandsClient<LandsGetPayload<T>>>

    /**
     * Count the number of Lands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandsCountArgs} args - Arguments to filter Lands to count.
     * @example
     * // Count the number of Lands
     * const count = await prisma.lands.count({
     *   where: {
     *     // ... the filter for the Lands we want to count
     *   }
     * })
    **/
    count<T extends LandsCountArgs>(
      args?: Subset<T, LandsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LandsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LandsAggregateArgs>(args: Subset<T, LandsAggregateArgs>): PrismaPromise<GetLandsAggregateType<T>>

    /**
     * Group by Lands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LandsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LandsGroupByArgs['orderBy'] }
        : { orderBy?: LandsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LandsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLandsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Lands.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LandsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Accounts<T extends AccountsArgs = {}>(args?: Subset<T, AccountsArgs>): CheckSelect<T, Prisma__AccountsClient<Accounts | Null>, Prisma__AccountsClient<AccountsGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Lands base type for findUnique actions
   */
  export type LandsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Lands
     * 
    **/
    select?: LandsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LandsInclude | null
    /**
     * Filter, which Lands to fetch.
     * 
    **/
    where: LandsWhereUniqueInput
  }

  /**
   * Lands: findUnique
   */
  export interface LandsFindUniqueArgs extends LandsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Lands base type for findFirst actions
   */
  export type LandsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Lands
     * 
    **/
    select?: LandsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LandsInclude | null
    /**
     * Filter, which Lands to fetch.
     * 
    **/
    where?: LandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lands to fetch.
     * 
    **/
    orderBy?: Enumerable<LandsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lands.
     * 
    **/
    cursor?: LandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lands from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lands.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lands.
     * 
    **/
    distinct?: Enumerable<LandsScalarFieldEnum>
  }

  /**
   * Lands: findFirst
   */
  export interface LandsFindFirstArgs extends LandsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Lands findMany
   */
  export type LandsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Lands
     * 
    **/
    select?: LandsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LandsInclude | null
    /**
     * Filter, which Lands to fetch.
     * 
    **/
    where?: LandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lands to fetch.
     * 
    **/
    orderBy?: Enumerable<LandsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lands.
     * 
    **/
    cursor?: LandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lands from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lands.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LandsScalarFieldEnum>
  }


  /**
   * Lands create
   */
  export type LandsCreateArgs = {
    /**
     * Select specific fields to fetch from the Lands
     * 
    **/
    select?: LandsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LandsInclude | null
    /**
     * The data needed to create a Lands.
     * 
    **/
    data: XOR<LandsCreateInput, LandsUncheckedCreateInput>
  }


  /**
   * Lands createMany
   */
  export type LandsCreateManyArgs = {
    /**
     * The data used to create many Lands.
     * 
    **/
    data: Enumerable<LandsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Lands update
   */
  export type LandsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Lands
     * 
    **/
    select?: LandsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LandsInclude | null
    /**
     * The data needed to update a Lands.
     * 
    **/
    data: XOR<LandsUpdateInput, LandsUncheckedUpdateInput>
    /**
     * Choose, which Lands to update.
     * 
    **/
    where: LandsWhereUniqueInput
  }


  /**
   * Lands updateMany
   */
  export type LandsUpdateManyArgs = {
    /**
     * The data used to update Lands.
     * 
    **/
    data: XOR<LandsUpdateManyMutationInput, LandsUncheckedUpdateManyInput>
    /**
     * Filter which Lands to update
     * 
    **/
    where?: LandsWhereInput
  }


  /**
   * Lands upsert
   */
  export type LandsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Lands
     * 
    **/
    select?: LandsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LandsInclude | null
    /**
     * The filter to search for the Lands to update in case it exists.
     * 
    **/
    where: LandsWhereUniqueInput
    /**
     * In case the Lands found by the `where` argument doesn't exist, create a new Lands with this data.
     * 
    **/
    create: XOR<LandsCreateInput, LandsUncheckedCreateInput>
    /**
     * In case the Lands was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<LandsUpdateInput, LandsUncheckedUpdateInput>
  }


  /**
   * Lands delete
   */
  export type LandsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Lands
     * 
    **/
    select?: LandsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LandsInclude | null
    /**
     * Filter which Lands to delete.
     * 
    **/
    where: LandsWhereUniqueInput
  }


  /**
   * Lands deleteMany
   */
  export type LandsDeleteManyArgs = {
    /**
     * Filter which Lands to delete
     * 
    **/
    where?: LandsWhereInput
  }


  /**
   * Lands: findUniqueOrThrow
   */
  export type LandsFindUniqueOrThrowArgs = LandsFindUniqueArgsBase
      

  /**
   * Lands: findFirstOrThrow
   */
  export type LandsFindFirstOrThrowArgs = LandsFindFirstArgsBase
      

  /**
   * Lands without action
   */
  export type LandsArgs = {
    /**
     * Select specific fields to fetch from the Lands
     * 
    **/
    select?: LandsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LandsInclude | null
  }



  /**
   * Model Notices
   */


  export type AggregateNotices = {
    _count: NoticesCountAggregateOutputType | null
    _avg: NoticesAvgAggregateOutputType | null
    _sum: NoticesSumAggregateOutputType | null
    _min: NoticesMinAggregateOutputType | null
    _max: NoticesMaxAggregateOutputType | null
  }

  export type NoticesAvgAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type NoticesSumAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type NoticesMinAggregateOutputType = {
    id: number | null
    startDate: Date | null
    endDate: Date | null
    imageURL: string | null
    externalURL: string | null
    order: number | null
    active: boolean | null
    deletedDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
  }

  export type NoticesMaxAggregateOutputType = {
    id: number | null
    startDate: Date | null
    endDate: Date | null
    imageURL: string | null
    externalURL: string | null
    order: number | null
    active: boolean | null
    deletedDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
  }

  export type NoticesCountAggregateOutputType = {
    id: number
    startDate: number
    endDate: number
    imageURL: number
    externalURL: number
    order: number
    active: number
    deletedDate: number
    createdAt: number
    updatedAt: number
    name: number
    _all: number
  }


  export type NoticesAvgAggregateInputType = {
    id?: true
    order?: true
  }

  export type NoticesSumAggregateInputType = {
    id?: true
    order?: true
  }

  export type NoticesMinAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    imageURL?: true
    externalURL?: true
    order?: true
    active?: true
    deletedDate?: true
    createdAt?: true
    updatedAt?: true
    name?: true
  }

  export type NoticesMaxAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    imageURL?: true
    externalURL?: true
    order?: true
    active?: true
    deletedDate?: true
    createdAt?: true
    updatedAt?: true
    name?: true
  }

  export type NoticesCountAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    imageURL?: true
    externalURL?: true
    order?: true
    active?: true
    deletedDate?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    _all?: true
  }

  export type NoticesAggregateArgs = {
    /**
     * Filter which Notices to aggregate.
     * 
    **/
    where?: NoticesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     * 
    **/
    orderBy?: Enumerable<NoticesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: NoticesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notices
    **/
    _count?: true | NoticesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoticesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoticesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoticesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoticesMaxAggregateInputType
  }

  export type GetNoticesAggregateType<T extends NoticesAggregateArgs> = {
        [P in keyof T & keyof AggregateNotices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotices[P]>
      : GetScalarType<T[P], AggregateNotices[P]>
  }




  export type NoticesGroupByArgs = {
    where?: NoticesWhereInput
    orderBy?: Enumerable<NoticesOrderByWithAggregationInput>
    by: Array<NoticesScalarFieldEnum>
    having?: NoticesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoticesCountAggregateInputType | true
    _avg?: NoticesAvgAggregateInputType
    _sum?: NoticesSumAggregateInputType
    _min?: NoticesMinAggregateInputType
    _max?: NoticesMaxAggregateInputType
  }


  export type NoticesGroupByOutputType = {
    id: number
    startDate: Date | null
    endDate: Date | null
    imageURL: string | null
    externalURL: string | null
    order: number | null
    active: boolean | null
    deletedDate: Date | null
    createdAt: Date
    updatedAt: Date
    name: string | null
    _count: NoticesCountAggregateOutputType | null
    _avg: NoticesAvgAggregateOutputType | null
    _sum: NoticesSumAggregateOutputType | null
    _min: NoticesMinAggregateOutputType | null
    _max: NoticesMaxAggregateOutputType | null
  }

  type GetNoticesGroupByPayload<T extends NoticesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<NoticesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoticesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoticesGroupByOutputType[P]>
            : GetScalarType<T[P], NoticesGroupByOutputType[P]>
        }
      >
    >


  export type NoticesSelect = {
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    imageURL?: boolean
    externalURL?: boolean
    order?: boolean
    active?: boolean
    deletedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
  }

  export type NoticesGetPayload<
    S extends boolean | null | undefined | NoticesArgs,
    U = keyof S
      > = S extends true
        ? Notices
    : S extends undefined
    ? never
    : S extends NoticesArgs | NoticesFindManyArgs
    ?'include' extends U
    ? Notices 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Notices ? Notices[P] : never
  } 
    : Notices
  : Notices


  type NoticesCountArgs = Merge<
    Omit<NoticesFindManyArgs, 'select' | 'include'> & {
      select?: NoticesCountAggregateInputType | true
    }
  >

  export interface NoticesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Notices that matches the filter.
     * @param {NoticesFindUniqueArgs} args - Arguments to find a Notices
     * @example
     * // Get one Notices
     * const notices = await prisma.notices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NoticesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NoticesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Notices'> extends True ? CheckSelect<T, Prisma__NoticesClient<Notices>, Prisma__NoticesClient<NoticesGetPayload<T>>> : CheckSelect<T, Prisma__NoticesClient<Notices | null, null>, Prisma__NoticesClient<NoticesGetPayload<T> | null, null>>

    /**
     * Find the first Notices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticesFindFirstArgs} args - Arguments to find a Notices
     * @example
     * // Get one Notices
     * const notices = await prisma.notices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NoticesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NoticesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Notices'> extends True ? CheckSelect<T, Prisma__NoticesClient<Notices>, Prisma__NoticesClient<NoticesGetPayload<T>>> : CheckSelect<T, Prisma__NoticesClient<Notices | null, null>, Prisma__NoticesClient<NoticesGetPayload<T> | null, null>>

    /**
     * Find zero or more Notices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notices
     * const notices = await prisma.notices.findMany()
     * 
     * // Get first 10 Notices
     * const notices = await prisma.notices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noticesWithIdOnly = await prisma.notices.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NoticesFindManyArgs>(
      args?: SelectSubset<T, NoticesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Notices>>, PrismaPromise<Array<NoticesGetPayload<T>>>>

    /**
     * Create a Notices.
     * @param {NoticesCreateArgs} args - Arguments to create a Notices.
     * @example
     * // Create one Notices
     * const Notices = await prisma.notices.create({
     *   data: {
     *     // ... data to create a Notices
     *   }
     * })
     * 
    **/
    create<T extends NoticesCreateArgs>(
      args: SelectSubset<T, NoticesCreateArgs>
    ): CheckSelect<T, Prisma__NoticesClient<Notices>, Prisma__NoticesClient<NoticesGetPayload<T>>>

    /**
     * Create many Notices.
     *     @param {NoticesCreateManyArgs} args - Arguments to create many Notices.
     *     @example
     *     // Create many Notices
     *     const notices = await prisma.notices.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NoticesCreateManyArgs>(
      args?: SelectSubset<T, NoticesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Notices.
     * @param {NoticesDeleteArgs} args - Arguments to delete one Notices.
     * @example
     * // Delete one Notices
     * const Notices = await prisma.notices.delete({
     *   where: {
     *     // ... filter to delete one Notices
     *   }
     * })
     * 
    **/
    delete<T extends NoticesDeleteArgs>(
      args: SelectSubset<T, NoticesDeleteArgs>
    ): CheckSelect<T, Prisma__NoticesClient<Notices>, Prisma__NoticesClient<NoticesGetPayload<T>>>

    /**
     * Update one Notices.
     * @param {NoticesUpdateArgs} args - Arguments to update one Notices.
     * @example
     * // Update one Notices
     * const notices = await prisma.notices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NoticesUpdateArgs>(
      args: SelectSubset<T, NoticesUpdateArgs>
    ): CheckSelect<T, Prisma__NoticesClient<Notices>, Prisma__NoticesClient<NoticesGetPayload<T>>>

    /**
     * Delete zero or more Notices.
     * @param {NoticesDeleteManyArgs} args - Arguments to filter Notices to delete.
     * @example
     * // Delete a few Notices
     * const { count } = await prisma.notices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NoticesDeleteManyArgs>(
      args?: SelectSubset<T, NoticesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notices
     * const notices = await prisma.notices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NoticesUpdateManyArgs>(
      args: SelectSubset<T, NoticesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Notices.
     * @param {NoticesUpsertArgs} args - Arguments to update or create a Notices.
     * @example
     * // Update or create a Notices
     * const notices = await prisma.notices.upsert({
     *   create: {
     *     // ... data to create a Notices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notices we want to update
     *   }
     * })
    **/
    upsert<T extends NoticesUpsertArgs>(
      args: SelectSubset<T, NoticesUpsertArgs>
    ): CheckSelect<T, Prisma__NoticesClient<Notices>, Prisma__NoticesClient<NoticesGetPayload<T>>>

    /**
     * Find one Notices that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {NoticesFindUniqueOrThrowArgs} args - Arguments to find a Notices
     * @example
     * // Get one Notices
     * const notices = await prisma.notices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NoticesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, NoticesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__NoticesClient<Notices>, Prisma__NoticesClient<NoticesGetPayload<T>>>

    /**
     * Find the first Notices that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticesFindFirstOrThrowArgs} args - Arguments to find a Notices
     * @example
     * // Get one Notices
     * const notices = await prisma.notices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NoticesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NoticesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__NoticesClient<Notices>, Prisma__NoticesClient<NoticesGetPayload<T>>>

    /**
     * Count the number of Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticesCountArgs} args - Arguments to filter Notices to count.
     * @example
     * // Count the number of Notices
     * const count = await prisma.notices.count({
     *   where: {
     *     // ... the filter for the Notices we want to count
     *   }
     * })
    **/
    count<T extends NoticesCountArgs>(
      args?: Subset<T, NoticesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoticesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoticesAggregateArgs>(args: Subset<T, NoticesAggregateArgs>): PrismaPromise<GetNoticesAggregateType<T>>

    /**
     * Group by Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoticesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoticesGroupByArgs['orderBy'] }
        : { orderBy?: NoticesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoticesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoticesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Notices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NoticesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Notices base type for findUnique actions
   */
  export type NoticesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Notices
     * 
    **/
    select?: NoticesSelect | null
    /**
     * Filter, which Notices to fetch.
     * 
    **/
    where: NoticesWhereUniqueInput
  }

  /**
   * Notices: findUnique
   */
  export interface NoticesFindUniqueArgs extends NoticesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notices base type for findFirst actions
   */
  export type NoticesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Notices
     * 
    **/
    select?: NoticesSelect | null
    /**
     * Filter, which Notices to fetch.
     * 
    **/
    where?: NoticesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     * 
    **/
    orderBy?: Enumerable<NoticesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notices.
     * 
    **/
    cursor?: NoticesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notices.
     * 
    **/
    distinct?: Enumerable<NoticesScalarFieldEnum>
  }

  /**
   * Notices: findFirst
   */
  export interface NoticesFindFirstArgs extends NoticesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notices findMany
   */
  export type NoticesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Notices
     * 
    **/
    select?: NoticesSelect | null
    /**
     * Filter, which Notices to fetch.
     * 
    **/
    where?: NoticesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     * 
    **/
    orderBy?: Enumerable<NoticesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notices.
     * 
    **/
    cursor?: NoticesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     * 
    **/
    skip?: number
    distinct?: Enumerable<NoticesScalarFieldEnum>
  }


  /**
   * Notices create
   */
  export type NoticesCreateArgs = {
    /**
     * Select specific fields to fetch from the Notices
     * 
    **/
    select?: NoticesSelect | null
    /**
     * The data needed to create a Notices.
     * 
    **/
    data: XOR<NoticesCreateInput, NoticesUncheckedCreateInput>
  }


  /**
   * Notices createMany
   */
  export type NoticesCreateManyArgs = {
    /**
     * The data used to create many Notices.
     * 
    **/
    data: Enumerable<NoticesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Notices update
   */
  export type NoticesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Notices
     * 
    **/
    select?: NoticesSelect | null
    /**
     * The data needed to update a Notices.
     * 
    **/
    data: XOR<NoticesUpdateInput, NoticesUncheckedUpdateInput>
    /**
     * Choose, which Notices to update.
     * 
    **/
    where: NoticesWhereUniqueInput
  }


  /**
   * Notices updateMany
   */
  export type NoticesUpdateManyArgs = {
    /**
     * The data used to update Notices.
     * 
    **/
    data: XOR<NoticesUpdateManyMutationInput, NoticesUncheckedUpdateManyInput>
    /**
     * Filter which Notices to update
     * 
    **/
    where?: NoticesWhereInput
  }


  /**
   * Notices upsert
   */
  export type NoticesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Notices
     * 
    **/
    select?: NoticesSelect | null
    /**
     * The filter to search for the Notices to update in case it exists.
     * 
    **/
    where: NoticesWhereUniqueInput
    /**
     * In case the Notices found by the `where` argument doesn't exist, create a new Notices with this data.
     * 
    **/
    create: XOR<NoticesCreateInput, NoticesUncheckedCreateInput>
    /**
     * In case the Notices was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<NoticesUpdateInput, NoticesUncheckedUpdateInput>
  }


  /**
   * Notices delete
   */
  export type NoticesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Notices
     * 
    **/
    select?: NoticesSelect | null
    /**
     * Filter which Notices to delete.
     * 
    **/
    where: NoticesWhereUniqueInput
  }


  /**
   * Notices deleteMany
   */
  export type NoticesDeleteManyArgs = {
    /**
     * Filter which Notices to delete
     * 
    **/
    where?: NoticesWhereInput
  }


  /**
   * Notices: findUniqueOrThrow
   */
  export type NoticesFindUniqueOrThrowArgs = NoticesFindUniqueArgsBase
      

  /**
   * Notices: findFirstOrThrow
   */
  export type NoticesFindFirstOrThrowArgs = NoticesFindFirstArgsBase
      

  /**
   * Notices without action
   */
  export type NoticesArgs = {
    /**
     * Select specific fields to fetch from the Notices
     * 
    **/
    select?: NoticesSelect | null
  }



  /**
   * Model Notifications
   */


  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsAvgAggregateOutputType = {
    id: number | null
    AccountId: number | null
  }

  export type NotificationsSumAggregateOutputType = {
    id: bigint | null
    AccountId: number | null
  }

  export type NotificationsMinAggregateOutputType = {
    id: bigint | null
    AccountId: number | null
    fcmToken: string | null
    sendedAt: Date | null
    isSuccess: boolean | null
    failReason: string | null
    eventCode: string | null
    sendCode: string | null
    reservationCode: string | null
    sendCycleCode: string | null
    title: string | null
    message: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationsMaxAggregateOutputType = {
    id: bigint | null
    AccountId: number | null
    fcmToken: string | null
    sendedAt: Date | null
    isSuccess: boolean | null
    failReason: string | null
    eventCode: string | null
    sendCode: string | null
    reservationCode: string | null
    sendCycleCode: string | null
    title: string | null
    message: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationsCountAggregateOutputType = {
    id: number
    AccountId: number
    fcmToken: number
    sendedAt: number
    isSuccess: number
    failReason: number
    eventCode: number
    sendCode: number
    reservationCode: number
    sendCycleCode: number
    title: number
    message: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationsAvgAggregateInputType = {
    id?: true
    AccountId?: true
  }

  export type NotificationsSumAggregateInputType = {
    id?: true
    AccountId?: true
  }

  export type NotificationsMinAggregateInputType = {
    id?: true
    AccountId?: true
    fcmToken?: true
    sendedAt?: true
    isSuccess?: true
    failReason?: true
    eventCode?: true
    sendCode?: true
    reservationCode?: true
    sendCycleCode?: true
    title?: true
    message?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationsMaxAggregateInputType = {
    id?: true
    AccountId?: true
    fcmToken?: true
    sendedAt?: true
    isSuccess?: true
    failReason?: true
    eventCode?: true
    sendCode?: true
    reservationCode?: true
    sendCycleCode?: true
    title?: true
    message?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationsCountAggregateInputType = {
    id?: true
    AccountId?: true
    fcmToken?: true
    sendedAt?: true
    isSuccess?: true
    failReason?: true
    eventCode?: true
    sendCode?: true
    reservationCode?: true
    sendCycleCode?: true
    title?: true
    message?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationsAggregateArgs = {
    /**
     * Filter which Notifications to aggregate.
     * 
    **/
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type NotificationsGroupByArgs = {
    where?: NotificationsWhereInput
    orderBy?: Enumerable<NotificationsOrderByWithAggregationInput>
    by: Array<NotificationsScalarFieldEnum>
    having?: NotificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _avg?: NotificationsAvgAggregateInputType
    _sum?: NotificationsSumAggregateInputType
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }


  export type NotificationsGroupByOutputType = {
    id: bigint
    AccountId: number
    fcmToken: string
    sendedAt: Date | null
    isSuccess: boolean | null
    failReason: string | null
    eventCode: string
    sendCode: string
    reservationCode: string
    sendCycleCode: string
    title: string
    message: string
    image: string | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends NotificationsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type NotificationsSelect = {
    id?: boolean
    AccountId?: boolean
    fcmToken?: boolean
    sendedAt?: boolean
    isSuccess?: boolean
    failReason?: boolean
    eventCode?: boolean
    sendCode?: boolean
    reservationCode?: boolean
    sendCycleCode?: boolean
    title?: boolean
    message?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Accounts?: boolean | AccountsArgs
  }

  export type NotificationsInclude = {
    Accounts?: boolean | AccountsArgs
  }

  export type NotificationsGetPayload<
    S extends boolean | null | undefined | NotificationsArgs,
    U = keyof S
      > = S extends true
        ? Notifications
    : S extends undefined
    ? never
    : S extends NotificationsArgs | NotificationsFindManyArgs
    ?'include' extends U
    ? Notifications  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Notifications ? Notifications[P] : never
  } 
    : Notifications
  : Notifications


  type NotificationsCountArgs = Merge<
    Omit<NotificationsFindManyArgs, 'select' | 'include'> & {
      select?: NotificationsCountAggregateInputType | true
    }
  >

  export interface NotificationsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {NotificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NotificationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Notifications'> extends True ? CheckSelect<T, Prisma__NotificationsClient<Notifications>, Prisma__NotificationsClient<NotificationsGetPayload<T>>> : CheckSelect<T, Prisma__NotificationsClient<Notifications | null, null>, Prisma__NotificationsClient<NotificationsGetPayload<T> | null, null>>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NotificationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Notifications'> extends True ? CheckSelect<T, Prisma__NotificationsClient<Notifications>, Prisma__NotificationsClient<NotificationsGetPayload<T>>> : CheckSelect<T, Prisma__NotificationsClient<Notifications | null, null>, Prisma__NotificationsClient<NotificationsGetPayload<T> | null, null>>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificationsFindManyArgs>(
      args?: SelectSubset<T, NotificationsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Notifications>>, PrismaPromise<Array<NotificationsGetPayload<T>>>>

    /**
     * Create a Notifications.
     * @param {NotificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
    **/
    create<T extends NotificationsCreateArgs>(
      args: SelectSubset<T, NotificationsCreateArgs>
    ): CheckSelect<T, Prisma__NotificationsClient<Notifications>, Prisma__NotificationsClient<NotificationsGetPayload<T>>>

    /**
     * Create many Notifications.
     *     @param {NotificationsCreateManyArgs} args - Arguments to create many Notifications.
     *     @example
     *     // Create many Notifications
     *     const notifications = await prisma.notifications.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NotificationsCreateManyArgs>(
      args?: SelectSubset<T, NotificationsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Notifications.
     * @param {NotificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
    **/
    delete<T extends NotificationsDeleteArgs>(
      args: SelectSubset<T, NotificationsDeleteArgs>
    ): CheckSelect<T, Prisma__NotificationsClient<Notifications>, Prisma__NotificationsClient<NotificationsGetPayload<T>>>

    /**
     * Update one Notifications.
     * @param {NotificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationsUpdateArgs>(
      args: SelectSubset<T, NotificationsUpdateArgs>
    ): CheckSelect<T, Prisma__NotificationsClient<Notifications>, Prisma__NotificationsClient<NotificationsGetPayload<T>>>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationsDeleteManyArgs>(
      args?: SelectSubset<T, NotificationsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationsUpdateManyArgs>(
      args: SelectSubset<T, NotificationsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Notifications.
     * @param {NotificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationsUpsertArgs>(
      args: SelectSubset<T, NotificationsUpsertArgs>
    ): CheckSelect<T, Prisma__NotificationsClient<Notifications>, Prisma__NotificationsClient<NotificationsGetPayload<T>>>

    /**
     * Find one Notifications that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {NotificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificationsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, NotificationsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__NotificationsClient<Notifications>, Prisma__NotificationsClient<NotificationsGetPayload<T>>>

    /**
     * Find the first Notifications that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificationsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotificationsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__NotificationsClient<Notifications>, Prisma__NotificationsClient<NotificationsGetPayload<T>>>

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationsCountArgs>(
      args?: Subset<T, NotificationsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationsGroupByArgs['orderBy'] }
        : { orderBy?: NotificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NotificationsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Accounts<T extends AccountsArgs = {}>(args?: Subset<T, AccountsArgs>): CheckSelect<T, Prisma__AccountsClient<Accounts | Null>, Prisma__AccountsClient<AccountsGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Notifications base type for findUnique actions
   */
  export type NotificationsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Notifications
     * 
    **/
    select?: NotificationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationsInclude | null
    /**
     * Filter, which Notifications to fetch.
     * 
    **/
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications: findUnique
   */
  export interface NotificationsFindUniqueArgs extends NotificationsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notifications base type for findFirst actions
   */
  export type NotificationsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Notifications
     * 
    **/
    select?: NotificationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationsInclude | null
    /**
     * Filter, which Notifications to fetch.
     * 
    **/
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     * 
    **/
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     * 
    **/
    distinct?: Enumerable<NotificationsScalarFieldEnum>
  }

  /**
   * Notifications: findFirst
   */
  export interface NotificationsFindFirstArgs extends NotificationsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notifications findMany
   */
  export type NotificationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Notifications
     * 
    **/
    select?: NotificationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationsInclude | null
    /**
     * Filter, which Notifications to fetch.
     * 
    **/
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     * 
    **/
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    distinct?: Enumerable<NotificationsScalarFieldEnum>
  }


  /**
   * Notifications create
   */
  export type NotificationsCreateArgs = {
    /**
     * Select specific fields to fetch from the Notifications
     * 
    **/
    select?: NotificationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationsInclude | null
    /**
     * The data needed to create a Notifications.
     * 
    **/
    data: XOR<NotificationsCreateInput, NotificationsUncheckedCreateInput>
  }


  /**
   * Notifications createMany
   */
  export type NotificationsCreateManyArgs = {
    /**
     * The data used to create many Notifications.
     * 
    **/
    data: Enumerable<NotificationsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Notifications update
   */
  export type NotificationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Notifications
     * 
    **/
    select?: NotificationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationsInclude | null
    /**
     * The data needed to update a Notifications.
     * 
    **/
    data: XOR<NotificationsUpdateInput, NotificationsUncheckedUpdateInput>
    /**
     * Choose, which Notifications to update.
     * 
    **/
    where: NotificationsWhereUniqueInput
  }


  /**
   * Notifications updateMany
   */
  export type NotificationsUpdateManyArgs = {
    /**
     * The data used to update Notifications.
     * 
    **/
    data: XOR<NotificationsUpdateManyMutationInput, NotificationsUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     * 
    **/
    where?: NotificationsWhereInput
  }


  /**
   * Notifications upsert
   */
  export type NotificationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Notifications
     * 
    **/
    select?: NotificationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationsInclude | null
    /**
     * The filter to search for the Notifications to update in case it exists.
     * 
    **/
    where: NotificationsWhereUniqueInput
    /**
     * In case the Notifications found by the `where` argument doesn't exist, create a new Notifications with this data.
     * 
    **/
    create: XOR<NotificationsCreateInput, NotificationsUncheckedCreateInput>
    /**
     * In case the Notifications was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<NotificationsUpdateInput, NotificationsUncheckedUpdateInput>
  }


  /**
   * Notifications delete
   */
  export type NotificationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Notifications
     * 
    **/
    select?: NotificationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationsInclude | null
    /**
     * Filter which Notifications to delete.
     * 
    **/
    where: NotificationsWhereUniqueInput
  }


  /**
   * Notifications deleteMany
   */
  export type NotificationsDeleteManyArgs = {
    /**
     * Filter which Notifications to delete
     * 
    **/
    where?: NotificationsWhereInput
  }


  /**
   * Notifications: findUniqueOrThrow
   */
  export type NotificationsFindUniqueOrThrowArgs = NotificationsFindUniqueArgsBase
      

  /**
   * Notifications: findFirstOrThrow
   */
  export type NotificationsFindFirstOrThrowArgs = NotificationsFindFirstArgsBase
      

  /**
   * Notifications without action
   */
  export type NotificationsArgs = {
    /**
     * Select specific fields to fetch from the Notifications
     * 
    **/
    select?: NotificationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationsInclude | null
  }



  /**
   * Model OrderHistories
   */


  export type AggregateOrderHistories = {
    _count: OrderHistoriesCountAggregateOutputType | null
    _avg: OrderHistoriesAvgAggregateOutputType | null
    _sum: OrderHistoriesSumAggregateOutputType | null
    _min: OrderHistoriesMinAggregateOutputType | null
    _max: OrderHistoriesMaxAggregateOutputType | null
  }

  export type OrderHistoriesAvgAggregateOutputType = {
    id: number | null
    reqAmount: number | null
    paidAmount: number | null
    AccountId: number | null
    ProductId: number | null
    OrderId: number | null
  }

  export type OrderHistoriesSumAggregateOutputType = {
    id: number | null
    reqAmount: number | null
    paidAmount: number | null
    AccountId: number | null
    ProductId: number | null
    OrderId: number | null
  }

  export type OrderHistoriesMinAggregateOutputType = {
    id: number | null
    name: string | null
    payment: string | null
    paymentMethod: string | null
    externalUid: string | null
    customerUid: string | null
    merchantUid: string | null
    reqAmount: number | null
    paidAmount: number | null
    status: string | null
    AccountId: number | null
    ProductId: number | null
    OrderId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderHistoriesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    payment: string | null
    paymentMethod: string | null
    externalUid: string | null
    customerUid: string | null
    merchantUid: string | null
    reqAmount: number | null
    paidAmount: number | null
    status: string | null
    AccountId: number | null
    ProductId: number | null
    OrderId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderHistoriesCountAggregateOutputType = {
    id: number
    name: number
    payment: number
    paymentMethod: number
    externalUid: number
    customerUid: number
    merchantUid: number
    reqAmount: number
    paidAmount: number
    status: number
    extra: number
    AccountId: number
    ProductId: number
    OrderId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderHistoriesAvgAggregateInputType = {
    id?: true
    reqAmount?: true
    paidAmount?: true
    AccountId?: true
    ProductId?: true
    OrderId?: true
  }

  export type OrderHistoriesSumAggregateInputType = {
    id?: true
    reqAmount?: true
    paidAmount?: true
    AccountId?: true
    ProductId?: true
    OrderId?: true
  }

  export type OrderHistoriesMinAggregateInputType = {
    id?: true
    name?: true
    payment?: true
    paymentMethod?: true
    externalUid?: true
    customerUid?: true
    merchantUid?: true
    reqAmount?: true
    paidAmount?: true
    status?: true
    AccountId?: true
    ProductId?: true
    OrderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderHistoriesMaxAggregateInputType = {
    id?: true
    name?: true
    payment?: true
    paymentMethod?: true
    externalUid?: true
    customerUid?: true
    merchantUid?: true
    reqAmount?: true
    paidAmount?: true
    status?: true
    AccountId?: true
    ProductId?: true
    OrderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderHistoriesCountAggregateInputType = {
    id?: true
    name?: true
    payment?: true
    paymentMethod?: true
    externalUid?: true
    customerUid?: true
    merchantUid?: true
    reqAmount?: true
    paidAmount?: true
    status?: true
    extra?: true
    AccountId?: true
    ProductId?: true
    OrderId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderHistoriesAggregateArgs = {
    /**
     * Filter which OrderHistories to aggregate.
     * 
    **/
    where?: OrderHistoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderHistories to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderHistoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OrderHistoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderHistories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderHistories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderHistories
    **/
    _count?: true | OrderHistoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderHistoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderHistoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderHistoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderHistoriesMaxAggregateInputType
  }

  export type GetOrderHistoriesAggregateType<T extends OrderHistoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderHistories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderHistories[P]>
      : GetScalarType<T[P], AggregateOrderHistories[P]>
  }




  export type OrderHistoriesGroupByArgs = {
    where?: OrderHistoriesWhereInput
    orderBy?: Enumerable<OrderHistoriesOrderByWithAggregationInput>
    by: Array<OrderHistoriesScalarFieldEnum>
    having?: OrderHistoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderHistoriesCountAggregateInputType | true
    _avg?: OrderHistoriesAvgAggregateInputType
    _sum?: OrderHistoriesSumAggregateInputType
    _min?: OrderHistoriesMinAggregateInputType
    _max?: OrderHistoriesMaxAggregateInputType
  }


  export type OrderHistoriesGroupByOutputType = {
    id: number
    name: string | null
    payment: string | null
    paymentMethod: string | null
    externalUid: string | null
    customerUid: string | null
    merchantUid: string | null
    reqAmount: number | null
    paidAmount: number | null
    status: string | null
    extra: JsonValue | null
    AccountId: number | null
    ProductId: number | null
    OrderId: number | null
    createdAt: Date
    updatedAt: Date
    _count: OrderHistoriesCountAggregateOutputType | null
    _avg: OrderHistoriesAvgAggregateOutputType | null
    _sum: OrderHistoriesSumAggregateOutputType | null
    _min: OrderHistoriesMinAggregateOutputType | null
    _max: OrderHistoriesMaxAggregateOutputType | null
  }

  type GetOrderHistoriesGroupByPayload<T extends OrderHistoriesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OrderHistoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderHistoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderHistoriesGroupByOutputType[P]>
            : GetScalarType<T[P], OrderHistoriesGroupByOutputType[P]>
        }
      >
    >


  export type OrderHistoriesSelect = {
    id?: boolean
    name?: boolean
    payment?: boolean
    paymentMethod?: boolean
    externalUid?: boolean
    customerUid?: boolean
    merchantUid?: boolean
    reqAmount?: boolean
    paidAmount?: boolean
    status?: boolean
    extra?: boolean
    AccountId?: boolean
    ProductId?: boolean
    OrderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Accounts?: boolean | AccountsArgs
    Orders?: boolean | OrdersArgs
    Products?: boolean | ProductsArgs
  }

  export type OrderHistoriesInclude = {
    Accounts?: boolean | AccountsArgs
    Orders?: boolean | OrdersArgs
    Products?: boolean | ProductsArgs
  }

  export type OrderHistoriesGetPayload<
    S extends boolean | null | undefined | OrderHistoriesArgs,
    U = keyof S
      > = S extends true
        ? OrderHistories
    : S extends undefined
    ? never
    : S extends OrderHistoriesArgs | OrderHistoriesFindManyArgs
    ?'include' extends U
    ? OrderHistories  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'Orders' ? OrdersGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'Products' ? ProductsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'Orders' ? OrdersGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'Products' ? ProductsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof OrderHistories ? OrderHistories[P] : never
  } 
    : OrderHistories
  : OrderHistories


  type OrderHistoriesCountArgs = Merge<
    Omit<OrderHistoriesFindManyArgs, 'select' | 'include'> & {
      select?: OrderHistoriesCountAggregateInputType | true
    }
  >

  export interface OrderHistoriesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one OrderHistories that matches the filter.
     * @param {OrderHistoriesFindUniqueArgs} args - Arguments to find a OrderHistories
     * @example
     * // Get one OrderHistories
     * const orderHistories = await prisma.orderHistories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderHistoriesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrderHistoriesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OrderHistories'> extends True ? CheckSelect<T, Prisma__OrderHistoriesClient<OrderHistories>, Prisma__OrderHistoriesClient<OrderHistoriesGetPayload<T>>> : CheckSelect<T, Prisma__OrderHistoriesClient<OrderHistories | null, null>, Prisma__OrderHistoriesClient<OrderHistoriesGetPayload<T> | null, null>>

    /**
     * Find the first OrderHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHistoriesFindFirstArgs} args - Arguments to find a OrderHistories
     * @example
     * // Get one OrderHistories
     * const orderHistories = await prisma.orderHistories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderHistoriesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrderHistoriesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OrderHistories'> extends True ? CheckSelect<T, Prisma__OrderHistoriesClient<OrderHistories>, Prisma__OrderHistoriesClient<OrderHistoriesGetPayload<T>>> : CheckSelect<T, Prisma__OrderHistoriesClient<OrderHistories | null, null>, Prisma__OrderHistoriesClient<OrderHistoriesGetPayload<T> | null, null>>

    /**
     * Find zero or more OrderHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHistoriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderHistories
     * const orderHistories = await prisma.orderHistories.findMany()
     * 
     * // Get first 10 OrderHistories
     * const orderHistories = await prisma.orderHistories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderHistoriesWithIdOnly = await prisma.orderHistories.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderHistoriesFindManyArgs>(
      args?: SelectSubset<T, OrderHistoriesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OrderHistories>>, PrismaPromise<Array<OrderHistoriesGetPayload<T>>>>

    /**
     * Create a OrderHistories.
     * @param {OrderHistoriesCreateArgs} args - Arguments to create a OrderHistories.
     * @example
     * // Create one OrderHistories
     * const OrderHistories = await prisma.orderHistories.create({
     *   data: {
     *     // ... data to create a OrderHistories
     *   }
     * })
     * 
    **/
    create<T extends OrderHistoriesCreateArgs>(
      args: SelectSubset<T, OrderHistoriesCreateArgs>
    ): CheckSelect<T, Prisma__OrderHistoriesClient<OrderHistories>, Prisma__OrderHistoriesClient<OrderHistoriesGetPayload<T>>>

    /**
     * Create many OrderHistories.
     *     @param {OrderHistoriesCreateManyArgs} args - Arguments to create many OrderHistories.
     *     @example
     *     // Create many OrderHistories
     *     const orderHistories = await prisma.orderHistories.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderHistoriesCreateManyArgs>(
      args?: SelectSubset<T, OrderHistoriesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OrderHistories.
     * @param {OrderHistoriesDeleteArgs} args - Arguments to delete one OrderHistories.
     * @example
     * // Delete one OrderHistories
     * const OrderHistories = await prisma.orderHistories.delete({
     *   where: {
     *     // ... filter to delete one OrderHistories
     *   }
     * })
     * 
    **/
    delete<T extends OrderHistoriesDeleteArgs>(
      args: SelectSubset<T, OrderHistoriesDeleteArgs>
    ): CheckSelect<T, Prisma__OrderHistoriesClient<OrderHistories>, Prisma__OrderHistoriesClient<OrderHistoriesGetPayload<T>>>

    /**
     * Update one OrderHistories.
     * @param {OrderHistoriesUpdateArgs} args - Arguments to update one OrderHistories.
     * @example
     * // Update one OrderHistories
     * const orderHistories = await prisma.orderHistories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderHistoriesUpdateArgs>(
      args: SelectSubset<T, OrderHistoriesUpdateArgs>
    ): CheckSelect<T, Prisma__OrderHistoriesClient<OrderHistories>, Prisma__OrderHistoriesClient<OrderHistoriesGetPayload<T>>>

    /**
     * Delete zero or more OrderHistories.
     * @param {OrderHistoriesDeleteManyArgs} args - Arguments to filter OrderHistories to delete.
     * @example
     * // Delete a few OrderHistories
     * const { count } = await prisma.orderHistories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderHistoriesDeleteManyArgs>(
      args?: SelectSubset<T, OrderHistoriesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHistoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderHistories
     * const orderHistories = await prisma.orderHistories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderHistoriesUpdateManyArgs>(
      args: SelectSubset<T, OrderHistoriesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderHistories.
     * @param {OrderHistoriesUpsertArgs} args - Arguments to update or create a OrderHistories.
     * @example
     * // Update or create a OrderHistories
     * const orderHistories = await prisma.orderHistories.upsert({
     *   create: {
     *     // ... data to create a OrderHistories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderHistories we want to update
     *   }
     * })
    **/
    upsert<T extends OrderHistoriesUpsertArgs>(
      args: SelectSubset<T, OrderHistoriesUpsertArgs>
    ): CheckSelect<T, Prisma__OrderHistoriesClient<OrderHistories>, Prisma__OrderHistoriesClient<OrderHistoriesGetPayload<T>>>

    /**
     * Find one OrderHistories that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {OrderHistoriesFindUniqueOrThrowArgs} args - Arguments to find a OrderHistories
     * @example
     * // Get one OrderHistories
     * const orderHistories = await prisma.orderHistories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderHistoriesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OrderHistoriesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__OrderHistoriesClient<OrderHistories>, Prisma__OrderHistoriesClient<OrderHistoriesGetPayload<T>>>

    /**
     * Find the first OrderHistories that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHistoriesFindFirstOrThrowArgs} args - Arguments to find a OrderHistories
     * @example
     * // Get one OrderHistories
     * const orderHistories = await prisma.orderHistories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderHistoriesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrderHistoriesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__OrderHistoriesClient<OrderHistories>, Prisma__OrderHistoriesClient<OrderHistoriesGetPayload<T>>>

    /**
     * Count the number of OrderHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHistoriesCountArgs} args - Arguments to filter OrderHistories to count.
     * @example
     * // Count the number of OrderHistories
     * const count = await prisma.orderHistories.count({
     *   where: {
     *     // ... the filter for the OrderHistories we want to count
     *   }
     * })
    **/
    count<T extends OrderHistoriesCountArgs>(
      args?: Subset<T, OrderHistoriesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderHistoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHistoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderHistoriesAggregateArgs>(args: Subset<T, OrderHistoriesAggregateArgs>): PrismaPromise<GetOrderHistoriesAggregateType<T>>

    /**
     * Group by OrderHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHistoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderHistoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderHistoriesGroupByArgs['orderBy'] }
        : { orderBy?: OrderHistoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderHistoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderHistoriesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderHistories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrderHistoriesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Accounts<T extends AccountsArgs = {}>(args?: Subset<T, AccountsArgs>): CheckSelect<T, Prisma__AccountsClient<Accounts | Null>, Prisma__AccountsClient<AccountsGetPayload<T> | Null>>;

    Orders<T extends OrdersArgs = {}>(args?: Subset<T, OrdersArgs>): CheckSelect<T, Prisma__OrdersClient<Orders | Null>, Prisma__OrdersClient<OrdersGetPayload<T> | Null>>;

    Products<T extends ProductsArgs = {}>(args?: Subset<T, ProductsArgs>): CheckSelect<T, Prisma__ProductsClient<Products | Null>, Prisma__ProductsClient<ProductsGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OrderHistories base type for findUnique actions
   */
  export type OrderHistoriesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OrderHistories
     * 
    **/
    select?: OrderHistoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderHistoriesInclude | null
    /**
     * Filter, which OrderHistories to fetch.
     * 
    **/
    where: OrderHistoriesWhereUniqueInput
  }

  /**
   * OrderHistories: findUnique
   */
  export interface OrderHistoriesFindUniqueArgs extends OrderHistoriesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OrderHistories base type for findFirst actions
   */
  export type OrderHistoriesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OrderHistories
     * 
    **/
    select?: OrderHistoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderHistoriesInclude | null
    /**
     * Filter, which OrderHistories to fetch.
     * 
    **/
    where?: OrderHistoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderHistories to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderHistoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderHistories.
     * 
    **/
    cursor?: OrderHistoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderHistories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderHistories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderHistories.
     * 
    **/
    distinct?: Enumerable<OrderHistoriesScalarFieldEnum>
  }

  /**
   * OrderHistories: findFirst
   */
  export interface OrderHistoriesFindFirstArgs extends OrderHistoriesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OrderHistories findMany
   */
  export type OrderHistoriesFindManyArgs = {
    /**
     * Select specific fields to fetch from the OrderHistories
     * 
    **/
    select?: OrderHistoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderHistoriesInclude | null
    /**
     * Filter, which OrderHistories to fetch.
     * 
    **/
    where?: OrderHistoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderHistories to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderHistoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderHistories.
     * 
    **/
    cursor?: OrderHistoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderHistories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderHistories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OrderHistoriesScalarFieldEnum>
  }


  /**
   * OrderHistories create
   */
  export type OrderHistoriesCreateArgs = {
    /**
     * Select specific fields to fetch from the OrderHistories
     * 
    **/
    select?: OrderHistoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderHistoriesInclude | null
    /**
     * The data needed to create a OrderHistories.
     * 
    **/
    data: XOR<OrderHistoriesCreateInput, OrderHistoriesUncheckedCreateInput>
  }


  /**
   * OrderHistories createMany
   */
  export type OrderHistoriesCreateManyArgs = {
    /**
     * The data used to create many OrderHistories.
     * 
    **/
    data: Enumerable<OrderHistoriesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OrderHistories update
   */
  export type OrderHistoriesUpdateArgs = {
    /**
     * Select specific fields to fetch from the OrderHistories
     * 
    **/
    select?: OrderHistoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderHistoriesInclude | null
    /**
     * The data needed to update a OrderHistories.
     * 
    **/
    data: XOR<OrderHistoriesUpdateInput, OrderHistoriesUncheckedUpdateInput>
    /**
     * Choose, which OrderHistories to update.
     * 
    **/
    where: OrderHistoriesWhereUniqueInput
  }


  /**
   * OrderHistories updateMany
   */
  export type OrderHistoriesUpdateManyArgs = {
    /**
     * The data used to update OrderHistories.
     * 
    **/
    data: XOR<OrderHistoriesUpdateManyMutationInput, OrderHistoriesUncheckedUpdateManyInput>
    /**
     * Filter which OrderHistories to update
     * 
    **/
    where?: OrderHistoriesWhereInput
  }


  /**
   * OrderHistories upsert
   */
  export type OrderHistoriesUpsertArgs = {
    /**
     * Select specific fields to fetch from the OrderHistories
     * 
    **/
    select?: OrderHistoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderHistoriesInclude | null
    /**
     * The filter to search for the OrderHistories to update in case it exists.
     * 
    **/
    where: OrderHistoriesWhereUniqueInput
    /**
     * In case the OrderHistories found by the `where` argument doesn't exist, create a new OrderHistories with this data.
     * 
    **/
    create: XOR<OrderHistoriesCreateInput, OrderHistoriesUncheckedCreateInput>
    /**
     * In case the OrderHistories was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OrderHistoriesUpdateInput, OrderHistoriesUncheckedUpdateInput>
  }


  /**
   * OrderHistories delete
   */
  export type OrderHistoriesDeleteArgs = {
    /**
     * Select specific fields to fetch from the OrderHistories
     * 
    **/
    select?: OrderHistoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderHistoriesInclude | null
    /**
     * Filter which OrderHistories to delete.
     * 
    **/
    where: OrderHistoriesWhereUniqueInput
  }


  /**
   * OrderHistories deleteMany
   */
  export type OrderHistoriesDeleteManyArgs = {
    /**
     * Filter which OrderHistories to delete
     * 
    **/
    where?: OrderHistoriesWhereInput
  }


  /**
   * OrderHistories: findUniqueOrThrow
   */
  export type OrderHistoriesFindUniqueOrThrowArgs = OrderHistoriesFindUniqueArgsBase
      

  /**
   * OrderHistories: findFirstOrThrow
   */
  export type OrderHistoriesFindFirstOrThrowArgs = OrderHistoriesFindFirstArgsBase
      

  /**
   * OrderHistories without action
   */
  export type OrderHistoriesArgs = {
    /**
     * Select specific fields to fetch from the OrderHistories
     * 
    **/
    select?: OrderHistoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderHistoriesInclude | null
  }



  /**
   * Model Orders
   */


  export type AggregateOrders = {
    _count: OrdersCountAggregateOutputType | null
    _avg: OrdersAvgAggregateOutputType | null
    _sum: OrdersSumAggregateOutputType | null
    _min: OrdersMinAggregateOutputType | null
    _max: OrdersMaxAggregateOutputType | null
  }

  export type OrdersAvgAggregateOutputType = {
    id: number | null
    reqAmount: number | null
    paidAmount: number | null
    AccountId: number | null
    ProductId: number | null
  }

  export type OrdersSumAggregateOutputType = {
    id: number | null
    reqAmount: number | null
    paidAmount: number | null
    AccountId: number | null
    ProductId: number | null
  }

  export type OrdersMinAggregateOutputType = {
    id: number | null
    name: string | null
    payment: string | null
    paymentMethod: string | null
    externalUid: string | null
    customerUid: string | null
    merchantUid: string | null
    reqAmount: number | null
    paidAmount: number | null
    status: string | null
    AccountId: number | null
    ProductId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    expiredAt: Date | null
    isSubscribe: boolean | null
    issuedAt: Date | null
  }

  export type OrdersMaxAggregateOutputType = {
    id: number | null
    name: string | null
    payment: string | null
    paymentMethod: string | null
    externalUid: string | null
    customerUid: string | null
    merchantUid: string | null
    reqAmount: number | null
    paidAmount: number | null
    status: string | null
    AccountId: number | null
    ProductId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    expiredAt: Date | null
    isSubscribe: boolean | null
    issuedAt: Date | null
  }

  export type OrdersCountAggregateOutputType = {
    id: number
    name: number
    payment: number
    paymentMethod: number
    externalUid: number
    customerUid: number
    merchantUid: number
    reqAmount: number
    paidAmount: number
    status: number
    extra: number
    AccountId: number
    ProductId: number
    createdAt: number
    updatedAt: number
    expiredAt: number
    isSubscribe: number
    issuedAt: number
    _all: number
  }


  export type OrdersAvgAggregateInputType = {
    id?: true
    reqAmount?: true
    paidAmount?: true
    AccountId?: true
    ProductId?: true
  }

  export type OrdersSumAggregateInputType = {
    id?: true
    reqAmount?: true
    paidAmount?: true
    AccountId?: true
    ProductId?: true
  }

  export type OrdersMinAggregateInputType = {
    id?: true
    name?: true
    payment?: true
    paymentMethod?: true
    externalUid?: true
    customerUid?: true
    merchantUid?: true
    reqAmount?: true
    paidAmount?: true
    status?: true
    AccountId?: true
    ProductId?: true
    createdAt?: true
    updatedAt?: true
    expiredAt?: true
    isSubscribe?: true
    issuedAt?: true
  }

  export type OrdersMaxAggregateInputType = {
    id?: true
    name?: true
    payment?: true
    paymentMethod?: true
    externalUid?: true
    customerUid?: true
    merchantUid?: true
    reqAmount?: true
    paidAmount?: true
    status?: true
    AccountId?: true
    ProductId?: true
    createdAt?: true
    updatedAt?: true
    expiredAt?: true
    isSubscribe?: true
    issuedAt?: true
  }

  export type OrdersCountAggregateInputType = {
    id?: true
    name?: true
    payment?: true
    paymentMethod?: true
    externalUid?: true
    customerUid?: true
    merchantUid?: true
    reqAmount?: true
    paidAmount?: true
    status?: true
    extra?: true
    AccountId?: true
    ProductId?: true
    createdAt?: true
    updatedAt?: true
    expiredAt?: true
    isSubscribe?: true
    issuedAt?: true
    _all?: true
  }

  export type OrdersAggregateArgs = {
    /**
     * Filter which Orders to aggregate.
     * 
    **/
    where?: OrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrdersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrdersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrdersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrdersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrdersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrdersMaxAggregateInputType
  }

  export type GetOrdersAggregateType<T extends OrdersAggregateArgs> = {
        [P in keyof T & keyof AggregateOrders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrders[P]>
      : GetScalarType<T[P], AggregateOrders[P]>
  }




  export type OrdersGroupByArgs = {
    where?: OrdersWhereInput
    orderBy?: Enumerable<OrdersOrderByWithAggregationInput>
    by: Array<OrdersScalarFieldEnum>
    having?: OrdersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrdersCountAggregateInputType | true
    _avg?: OrdersAvgAggregateInputType
    _sum?: OrdersSumAggregateInputType
    _min?: OrdersMinAggregateInputType
    _max?: OrdersMaxAggregateInputType
  }


  export type OrdersGroupByOutputType = {
    id: number
    name: string | null
    payment: string | null
    paymentMethod: string | null
    externalUid: string | null
    customerUid: string | null
    merchantUid: string | null
    reqAmount: number | null
    paidAmount: number | null
    status: string | null
    extra: JsonValue | null
    AccountId: number | null
    ProductId: number | null
    createdAt: Date
    updatedAt: Date
    expiredAt: Date | null
    isSubscribe: boolean | null
    issuedAt: Date | null
    _count: OrdersCountAggregateOutputType | null
    _avg: OrdersAvgAggregateOutputType | null
    _sum: OrdersSumAggregateOutputType | null
    _min: OrdersMinAggregateOutputType | null
    _max: OrdersMaxAggregateOutputType | null
  }

  type GetOrdersGroupByPayload<T extends OrdersGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OrdersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrdersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrdersGroupByOutputType[P]>
            : GetScalarType<T[P], OrdersGroupByOutputType[P]>
        }
      >
    >


  export type OrdersSelect = {
    id?: boolean
    name?: boolean
    payment?: boolean
    paymentMethod?: boolean
    externalUid?: boolean
    customerUid?: boolean
    merchantUid?: boolean
    reqAmount?: boolean
    paidAmount?: boolean
    status?: boolean
    extra?: boolean
    AccountId?: boolean
    ProductId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiredAt?: boolean
    isSubscribe?: boolean
    issuedAt?: boolean
    Accounts?: boolean | AccountsArgs
    Products?: boolean | ProductsArgs
    Discounts?: boolean | DiscountsFindManyArgs
    OrderHistories?: boolean | OrderHistoriesFindManyArgs
    _count?: boolean | OrdersCountOutputTypeArgs
  }

  export type OrdersInclude = {
    Accounts?: boolean | AccountsArgs
    Products?: boolean | ProductsArgs
    Discounts?: boolean | DiscountsFindManyArgs
    OrderHistories?: boolean | OrderHistoriesFindManyArgs
    _count?: boolean | OrdersCountOutputTypeArgs
  }

  export type OrdersGetPayload<
    S extends boolean | null | undefined | OrdersArgs,
    U = keyof S
      > = S extends true
        ? Orders
    : S extends undefined
    ? never
    : S extends OrdersArgs | OrdersFindManyArgs
    ?'include' extends U
    ? Orders  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'Products' ? ProductsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'Discounts' ? Array < DiscountsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'OrderHistories' ? Array < OrderHistoriesGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? OrdersCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'Products' ? ProductsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'Discounts' ? Array < DiscountsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'OrderHistories' ? Array < OrderHistoriesGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? OrdersCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Orders ? Orders[P] : never
  } 
    : Orders
  : Orders


  type OrdersCountArgs = Merge<
    Omit<OrdersFindManyArgs, 'select' | 'include'> & {
      select?: OrdersCountAggregateInputType | true
    }
  >

  export interface OrdersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Orders that matches the filter.
     * @param {OrdersFindUniqueArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrdersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrdersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Orders'> extends True ? CheckSelect<T, Prisma__OrdersClient<Orders>, Prisma__OrdersClient<OrdersGetPayload<T>>> : CheckSelect<T, Prisma__OrdersClient<Orders | null, null>, Prisma__OrdersClient<OrdersGetPayload<T> | null, null>>

    /**
     * Find the first Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersFindFirstArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrdersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrdersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Orders'> extends True ? CheckSelect<T, Prisma__OrdersClient<Orders>, Prisma__OrdersClient<OrdersGetPayload<T>>> : CheckSelect<T, Prisma__OrdersClient<Orders | null, null>, Prisma__OrdersClient<OrdersGetPayload<T> | null, null>>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.orders.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.orders.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ordersWithIdOnly = await prisma.orders.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrdersFindManyArgs>(
      args?: SelectSubset<T, OrdersFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Orders>>, PrismaPromise<Array<OrdersGetPayload<T>>>>

    /**
     * Create a Orders.
     * @param {OrdersCreateArgs} args - Arguments to create a Orders.
     * @example
     * // Create one Orders
     * const Orders = await prisma.orders.create({
     *   data: {
     *     // ... data to create a Orders
     *   }
     * })
     * 
    **/
    create<T extends OrdersCreateArgs>(
      args: SelectSubset<T, OrdersCreateArgs>
    ): CheckSelect<T, Prisma__OrdersClient<Orders>, Prisma__OrdersClient<OrdersGetPayload<T>>>

    /**
     * Create many Orders.
     *     @param {OrdersCreateManyArgs} args - Arguments to create many Orders.
     *     @example
     *     // Create many Orders
     *     const orders = await prisma.orders.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrdersCreateManyArgs>(
      args?: SelectSubset<T, OrdersCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Orders.
     * @param {OrdersDeleteArgs} args - Arguments to delete one Orders.
     * @example
     * // Delete one Orders
     * const Orders = await prisma.orders.delete({
     *   where: {
     *     // ... filter to delete one Orders
     *   }
     * })
     * 
    **/
    delete<T extends OrdersDeleteArgs>(
      args: SelectSubset<T, OrdersDeleteArgs>
    ): CheckSelect<T, Prisma__OrdersClient<Orders>, Prisma__OrdersClient<OrdersGetPayload<T>>>

    /**
     * Update one Orders.
     * @param {OrdersUpdateArgs} args - Arguments to update one Orders.
     * @example
     * // Update one Orders
     * const orders = await prisma.orders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrdersUpdateArgs>(
      args: SelectSubset<T, OrdersUpdateArgs>
    ): CheckSelect<T, Prisma__OrdersClient<Orders>, Prisma__OrdersClient<OrdersGetPayload<T>>>

    /**
     * Delete zero or more Orders.
     * @param {OrdersDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.orders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrdersDeleteManyArgs>(
      args?: SelectSubset<T, OrdersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const orders = await prisma.orders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrdersUpdateManyArgs>(
      args: SelectSubset<T, OrdersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Orders.
     * @param {OrdersUpsertArgs} args - Arguments to update or create a Orders.
     * @example
     * // Update or create a Orders
     * const orders = await prisma.orders.upsert({
     *   create: {
     *     // ... data to create a Orders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Orders we want to update
     *   }
     * })
    **/
    upsert<T extends OrdersUpsertArgs>(
      args: SelectSubset<T, OrdersUpsertArgs>
    ): CheckSelect<T, Prisma__OrdersClient<Orders>, Prisma__OrdersClient<OrdersGetPayload<T>>>

    /**
     * Find one Orders that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {OrdersFindUniqueOrThrowArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrdersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OrdersFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__OrdersClient<Orders>, Prisma__OrdersClient<OrdersGetPayload<T>>>

    /**
     * Find the first Orders that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersFindFirstOrThrowArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrdersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrdersFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__OrdersClient<Orders>, Prisma__OrdersClient<OrdersGetPayload<T>>>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.orders.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrdersCountArgs>(
      args?: Subset<T, OrdersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrdersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrdersAggregateArgs>(args: Subset<T, OrdersAggregateArgs>): PrismaPromise<GetOrdersAggregateType<T>>

    /**
     * Group by Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrdersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrdersGroupByArgs['orderBy'] }
        : { orderBy?: OrdersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrdersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrdersGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Orders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrdersClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Accounts<T extends AccountsArgs = {}>(args?: Subset<T, AccountsArgs>): CheckSelect<T, Prisma__AccountsClient<Accounts | Null>, Prisma__AccountsClient<AccountsGetPayload<T> | Null>>;

    Products<T extends ProductsArgs = {}>(args?: Subset<T, ProductsArgs>): CheckSelect<T, Prisma__ProductsClient<Products | Null>, Prisma__ProductsClient<ProductsGetPayload<T> | Null>>;

    Discounts<T extends DiscountsFindManyArgs = {}>(args?: Subset<T, DiscountsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Discounts>| Null>, PrismaPromise<Array<DiscountsGetPayload<T>>| Null>>;

    OrderHistories<T extends OrderHistoriesFindManyArgs = {}>(args?: Subset<T, OrderHistoriesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OrderHistories>| Null>, PrismaPromise<Array<OrderHistoriesGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Orders base type for findUnique actions
   */
  export type OrdersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Orders
     * 
    **/
    select?: OrdersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrdersInclude | null
    /**
     * Filter, which Orders to fetch.
     * 
    **/
    where: OrdersWhereUniqueInput
  }

  /**
   * Orders: findUnique
   */
  export interface OrdersFindUniqueArgs extends OrdersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Orders base type for findFirst actions
   */
  export type OrdersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Orders
     * 
    **/
    select?: OrdersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrdersInclude | null
    /**
     * Filter, which Orders to fetch.
     * 
    **/
    where?: OrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrdersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     * 
    **/
    cursor?: OrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     * 
    **/
    distinct?: Enumerable<OrdersScalarFieldEnum>
  }

  /**
   * Orders: findFirst
   */
  export interface OrdersFindFirstArgs extends OrdersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Orders findMany
   */
  export type OrdersFindManyArgs = {
    /**
     * Select specific fields to fetch from the Orders
     * 
    **/
    select?: OrdersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrdersInclude | null
    /**
     * Filter, which Orders to fetch.
     * 
    **/
    where?: OrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrdersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     * 
    **/
    cursor?: OrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OrdersScalarFieldEnum>
  }


  /**
   * Orders create
   */
  export type OrdersCreateArgs = {
    /**
     * Select specific fields to fetch from the Orders
     * 
    **/
    select?: OrdersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrdersInclude | null
    /**
     * The data needed to create a Orders.
     * 
    **/
    data: XOR<OrdersCreateInput, OrdersUncheckedCreateInput>
  }


  /**
   * Orders createMany
   */
  export type OrdersCreateManyArgs = {
    /**
     * The data used to create many Orders.
     * 
    **/
    data: Enumerable<OrdersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Orders update
   */
  export type OrdersUpdateArgs = {
    /**
     * Select specific fields to fetch from the Orders
     * 
    **/
    select?: OrdersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrdersInclude | null
    /**
     * The data needed to update a Orders.
     * 
    **/
    data: XOR<OrdersUpdateInput, OrdersUncheckedUpdateInput>
    /**
     * Choose, which Orders to update.
     * 
    **/
    where: OrdersWhereUniqueInput
  }


  /**
   * Orders updateMany
   */
  export type OrdersUpdateManyArgs = {
    /**
     * The data used to update Orders.
     * 
    **/
    data: XOR<OrdersUpdateManyMutationInput, OrdersUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     * 
    **/
    where?: OrdersWhereInput
  }


  /**
   * Orders upsert
   */
  export type OrdersUpsertArgs = {
    /**
     * Select specific fields to fetch from the Orders
     * 
    **/
    select?: OrdersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrdersInclude | null
    /**
     * The filter to search for the Orders to update in case it exists.
     * 
    **/
    where: OrdersWhereUniqueInput
    /**
     * In case the Orders found by the `where` argument doesn't exist, create a new Orders with this data.
     * 
    **/
    create: XOR<OrdersCreateInput, OrdersUncheckedCreateInput>
    /**
     * In case the Orders was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OrdersUpdateInput, OrdersUncheckedUpdateInput>
  }


  /**
   * Orders delete
   */
  export type OrdersDeleteArgs = {
    /**
     * Select specific fields to fetch from the Orders
     * 
    **/
    select?: OrdersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrdersInclude | null
    /**
     * Filter which Orders to delete.
     * 
    **/
    where: OrdersWhereUniqueInput
  }


  /**
   * Orders deleteMany
   */
  export type OrdersDeleteManyArgs = {
    /**
     * Filter which Orders to delete
     * 
    **/
    where?: OrdersWhereInput
  }


  /**
   * Orders: findUniqueOrThrow
   */
  export type OrdersFindUniqueOrThrowArgs = OrdersFindUniqueArgsBase
      

  /**
   * Orders: findFirstOrThrow
   */
  export type OrdersFindFirstOrThrowArgs = OrdersFindFirstArgsBase
      

  /**
   * Orders without action
   */
  export type OrdersArgs = {
    /**
     * Select specific fields to fetch from the Orders
     * 
    **/
    select?: OrdersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrdersInclude | null
  }



  /**
   * Model Permissions
   */


  export type AggregatePermissions = {
    _count: PermissionsCountAggregateOutputType | null
    _avg: PermissionsAvgAggregateOutputType | null
    _sum: PermissionsSumAggregateOutputType | null
    _min: PermissionsMinAggregateOutputType | null
    _max: PermissionsMaxAggregateOutputType | null
  }

  export type PermissionsAvgAggregateOutputType = {
    id: number | null
    resourceId: number | null
    AccountId: number | null
  }

  export type PermissionsSumAggregateOutputType = {
    id: number | null
    resourceId: number | null
    AccountId: number | null
  }

  export type PermissionsMinAggregateOutputType = {
    id: number | null
    resource: string | null
    key: enum_Permissions_key | null
    resourceId: number | null
    AccountId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionsMaxAggregateOutputType = {
    id: number | null
    resource: string | null
    key: enum_Permissions_key | null
    resourceId: number | null
    AccountId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionsCountAggregateOutputType = {
    id: number
    resource: number
    key: number
    resourceId: number
    AccountId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PermissionsAvgAggregateInputType = {
    id?: true
    resourceId?: true
    AccountId?: true
  }

  export type PermissionsSumAggregateInputType = {
    id?: true
    resourceId?: true
    AccountId?: true
  }

  export type PermissionsMinAggregateInputType = {
    id?: true
    resource?: true
    key?: true
    resourceId?: true
    AccountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionsMaxAggregateInputType = {
    id?: true
    resource?: true
    key?: true
    resourceId?: true
    AccountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionsCountAggregateInputType = {
    id?: true
    resource?: true
    key?: true
    resourceId?: true
    AccountId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PermissionsAggregateArgs = {
    /**
     * Filter which Permissions to aggregate.
     * 
    **/
    where?: PermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     * 
    **/
    orderBy?: Enumerable<PermissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionsMaxAggregateInputType
  }

  export type GetPermissionsAggregateType<T extends PermissionsAggregateArgs> = {
        [P in keyof T & keyof AggregatePermissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermissions[P]>
      : GetScalarType<T[P], AggregatePermissions[P]>
  }




  export type PermissionsGroupByArgs = {
    where?: PermissionsWhereInput
    orderBy?: Enumerable<PermissionsOrderByWithAggregationInput>
    by: Array<PermissionsScalarFieldEnum>
    having?: PermissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionsCountAggregateInputType | true
    _avg?: PermissionsAvgAggregateInputType
    _sum?: PermissionsSumAggregateInputType
    _min?: PermissionsMinAggregateInputType
    _max?: PermissionsMaxAggregateInputType
  }


  export type PermissionsGroupByOutputType = {
    id: number
    resource: string
    key: enum_Permissions_key
    resourceId: number
    AccountId: number | null
    createdAt: Date
    updatedAt: Date
    _count: PermissionsCountAggregateOutputType | null
    _avg: PermissionsAvgAggregateOutputType | null
    _sum: PermissionsSumAggregateOutputType | null
    _min: PermissionsMinAggregateOutputType | null
    _max: PermissionsMaxAggregateOutputType | null
  }

  type GetPermissionsGroupByPayload<T extends PermissionsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PermissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionsGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionsGroupByOutputType[P]>
        }
      >
    >


  export type PermissionsSelect = {
    id?: boolean
    resource?: boolean
    key?: boolean
    resourceId?: boolean
    AccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Accounts?: boolean | AccountsArgs
  }

  export type PermissionsInclude = {
    Accounts?: boolean | AccountsArgs
  }

  export type PermissionsGetPayload<
    S extends boolean | null | undefined | PermissionsArgs,
    U = keyof S
      > = S extends true
        ? Permissions
    : S extends undefined
    ? never
    : S extends PermissionsArgs | PermissionsFindManyArgs
    ?'include' extends U
    ? Permissions  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof Permissions ? Permissions[P] : never
  } 
    : Permissions
  : Permissions


  type PermissionsCountArgs = Merge<
    Omit<PermissionsFindManyArgs, 'select' | 'include'> & {
      select?: PermissionsCountAggregateInputType | true
    }
  >

  export interface PermissionsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Permissions that matches the filter.
     * @param {PermissionsFindUniqueArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PermissionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PermissionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Permissions'> extends True ? CheckSelect<T, Prisma__PermissionsClient<Permissions>, Prisma__PermissionsClient<PermissionsGetPayload<T>>> : CheckSelect<T, Prisma__PermissionsClient<Permissions | null, null>, Prisma__PermissionsClient<PermissionsGetPayload<T> | null, null>>

    /**
     * Find the first Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsFindFirstArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PermissionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PermissionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Permissions'> extends True ? CheckSelect<T, Prisma__PermissionsClient<Permissions>, Prisma__PermissionsClient<PermissionsGetPayload<T>>> : CheckSelect<T, Prisma__PermissionsClient<Permissions | null, null>, Prisma__PermissionsClient<PermissionsGetPayload<T> | null, null>>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permissions.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionsWithIdOnly = await prisma.permissions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PermissionsFindManyArgs>(
      args?: SelectSubset<T, PermissionsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Permissions>>, PrismaPromise<Array<PermissionsGetPayload<T>>>>

    /**
     * Create a Permissions.
     * @param {PermissionsCreateArgs} args - Arguments to create a Permissions.
     * @example
     * // Create one Permissions
     * const Permissions = await prisma.permissions.create({
     *   data: {
     *     // ... data to create a Permissions
     *   }
     * })
     * 
    **/
    create<T extends PermissionsCreateArgs>(
      args: SelectSubset<T, PermissionsCreateArgs>
    ): CheckSelect<T, Prisma__PermissionsClient<Permissions>, Prisma__PermissionsClient<PermissionsGetPayload<T>>>

    /**
     * Create many Permissions.
     *     @param {PermissionsCreateManyArgs} args - Arguments to create many Permissions.
     *     @example
     *     // Create many Permissions
     *     const permissions = await prisma.permissions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PermissionsCreateManyArgs>(
      args?: SelectSubset<T, PermissionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Permissions.
     * @param {PermissionsDeleteArgs} args - Arguments to delete one Permissions.
     * @example
     * // Delete one Permissions
     * const Permissions = await prisma.permissions.delete({
     *   where: {
     *     // ... filter to delete one Permissions
     *   }
     * })
     * 
    **/
    delete<T extends PermissionsDeleteArgs>(
      args: SelectSubset<T, PermissionsDeleteArgs>
    ): CheckSelect<T, Prisma__PermissionsClient<Permissions>, Prisma__PermissionsClient<PermissionsGetPayload<T>>>

    /**
     * Update one Permissions.
     * @param {PermissionsUpdateArgs} args - Arguments to update one Permissions.
     * @example
     * // Update one Permissions
     * const permissions = await prisma.permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PermissionsUpdateArgs>(
      args: SelectSubset<T, PermissionsUpdateArgs>
    ): CheckSelect<T, Prisma__PermissionsClient<Permissions>, Prisma__PermissionsClient<PermissionsGetPayload<T>>>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionsDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PermissionsDeleteManyArgs>(
      args?: SelectSubset<T, PermissionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permissions = await prisma.permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PermissionsUpdateManyArgs>(
      args: SelectSubset<T, PermissionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Permissions.
     * @param {PermissionsUpsertArgs} args - Arguments to update or create a Permissions.
     * @example
     * // Update or create a Permissions
     * const permissions = await prisma.permissions.upsert({
     *   create: {
     *     // ... data to create a Permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permissions we want to update
     *   }
     * })
    **/
    upsert<T extends PermissionsUpsertArgs>(
      args: SelectSubset<T, PermissionsUpsertArgs>
    ): CheckSelect<T, Prisma__PermissionsClient<Permissions>, Prisma__PermissionsClient<PermissionsGetPayload<T>>>

    /**
     * Find one Permissions that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PermissionsFindUniqueOrThrowArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PermissionsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PermissionsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PermissionsClient<Permissions>, Prisma__PermissionsClient<PermissionsGetPayload<T>>>

    /**
     * Find the first Permissions that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsFindFirstOrThrowArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PermissionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PermissionsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PermissionsClient<Permissions>, Prisma__PermissionsClient<PermissionsGetPayload<T>>>

    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permissions.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionsCountArgs>(
      args?: Subset<T, PermissionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionsAggregateArgs>(args: Subset<T, PermissionsAggregateArgs>): PrismaPromise<GetPermissionsAggregateType<T>>

    /**
     * Group by Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionsGroupByArgs['orderBy'] }
        : { orderBy?: PermissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PermissionsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Accounts<T extends AccountsArgs = {}>(args?: Subset<T, AccountsArgs>): CheckSelect<T, Prisma__AccountsClient<Accounts | Null>, Prisma__AccountsClient<AccountsGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Permissions base type for findUnique actions
   */
  export type PermissionsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Permissions
     * 
    **/
    select?: PermissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermissionsInclude | null
    /**
     * Filter, which Permissions to fetch.
     * 
    **/
    where: PermissionsWhereUniqueInput
  }

  /**
   * Permissions: findUnique
   */
  export interface PermissionsFindUniqueArgs extends PermissionsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Permissions base type for findFirst actions
   */
  export type PermissionsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Permissions
     * 
    **/
    select?: PermissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermissionsInclude | null
    /**
     * Filter, which Permissions to fetch.
     * 
    **/
    where?: PermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     * 
    **/
    orderBy?: Enumerable<PermissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     * 
    **/
    cursor?: PermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     * 
    **/
    distinct?: Enumerable<PermissionsScalarFieldEnum>
  }

  /**
   * Permissions: findFirst
   */
  export interface PermissionsFindFirstArgs extends PermissionsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Permissions findMany
   */
  export type PermissionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Permissions
     * 
    **/
    select?: PermissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermissionsInclude | null
    /**
     * Filter, which Permissions to fetch.
     * 
    **/
    where?: PermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     * 
    **/
    orderBy?: Enumerable<PermissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     * 
    **/
    cursor?: PermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PermissionsScalarFieldEnum>
  }


  /**
   * Permissions create
   */
  export type PermissionsCreateArgs = {
    /**
     * Select specific fields to fetch from the Permissions
     * 
    **/
    select?: PermissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermissionsInclude | null
    /**
     * The data needed to create a Permissions.
     * 
    **/
    data: XOR<PermissionsCreateInput, PermissionsUncheckedCreateInput>
  }


  /**
   * Permissions createMany
   */
  export type PermissionsCreateManyArgs = {
    /**
     * The data used to create many Permissions.
     * 
    **/
    data: Enumerable<PermissionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Permissions update
   */
  export type PermissionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Permissions
     * 
    **/
    select?: PermissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermissionsInclude | null
    /**
     * The data needed to update a Permissions.
     * 
    **/
    data: XOR<PermissionsUpdateInput, PermissionsUncheckedUpdateInput>
    /**
     * Choose, which Permissions to update.
     * 
    **/
    where: PermissionsWhereUniqueInput
  }


  /**
   * Permissions updateMany
   */
  export type PermissionsUpdateManyArgs = {
    /**
     * The data used to update Permissions.
     * 
    **/
    data: XOR<PermissionsUpdateManyMutationInput, PermissionsUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     * 
    **/
    where?: PermissionsWhereInput
  }


  /**
   * Permissions upsert
   */
  export type PermissionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Permissions
     * 
    **/
    select?: PermissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermissionsInclude | null
    /**
     * The filter to search for the Permissions to update in case it exists.
     * 
    **/
    where: PermissionsWhereUniqueInput
    /**
     * In case the Permissions found by the `where` argument doesn't exist, create a new Permissions with this data.
     * 
    **/
    create: XOR<PermissionsCreateInput, PermissionsUncheckedCreateInput>
    /**
     * In case the Permissions was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PermissionsUpdateInput, PermissionsUncheckedUpdateInput>
  }


  /**
   * Permissions delete
   */
  export type PermissionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Permissions
     * 
    **/
    select?: PermissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermissionsInclude | null
    /**
     * Filter which Permissions to delete.
     * 
    **/
    where: PermissionsWhereUniqueInput
  }


  /**
   * Permissions deleteMany
   */
  export type PermissionsDeleteManyArgs = {
    /**
     * Filter which Permissions to delete
     * 
    **/
    where?: PermissionsWhereInput
  }


  /**
   * Permissions: findUniqueOrThrow
   */
  export type PermissionsFindUniqueOrThrowArgs = PermissionsFindUniqueArgsBase
      

  /**
   * Permissions: findFirstOrThrow
   */
  export type PermissionsFindFirstOrThrowArgs = PermissionsFindFirstArgsBase
      

  /**
   * Permissions without action
   */
  export type PermissionsArgs = {
    /**
     * Select specific fields to fetch from the Permissions
     * 
    **/
    select?: PermissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermissionsInclude | null
  }



  /**
   * Model PostAccounts
   */


  export type AggregatePostAccounts = {
    _count: PostAccountsCountAggregateOutputType | null
    _avg: PostAccountsAvgAggregateOutputType | null
    _sum: PostAccountsSumAggregateOutputType | null
    _min: PostAccountsMinAggregateOutputType | null
    _max: PostAccountsMaxAggregateOutputType | null
  }

  export type PostAccountsAvgAggregateOutputType = {
    id: number | null
    AccountId: number | null
    PostId: number | null
  }

  export type PostAccountsSumAggregateOutputType = {
    id: number | null
    AccountId: number | null
    PostId: number | null
  }

  export type PostAccountsMinAggregateOutputType = {
    id: number | null
    AccountId: number | null
    PostId: number | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostAccountsMaxAggregateOutputType = {
    id: number | null
    AccountId: number | null
    PostId: number | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostAccountsCountAggregateOutputType = {
    id: number
    AccountId: number
    PostId: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PostAccountsAvgAggregateInputType = {
    id?: true
    AccountId?: true
    PostId?: true
  }

  export type PostAccountsSumAggregateInputType = {
    id?: true
    AccountId?: true
    PostId?: true
  }

  export type PostAccountsMinAggregateInputType = {
    id?: true
    AccountId?: true
    PostId?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostAccountsMaxAggregateInputType = {
    id?: true
    AccountId?: true
    PostId?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostAccountsCountAggregateInputType = {
    id?: true
    AccountId?: true
    PostId?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PostAccountsAggregateArgs = {
    /**
     * Filter which PostAccounts to aggregate.
     * 
    **/
    where?: PostAccountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAccounts to fetch.
     * 
    **/
    orderBy?: Enumerable<PostAccountsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PostAccountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAccounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAccounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostAccounts
    **/
    _count?: true | PostAccountsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAccountsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostAccountsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostAccountsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostAccountsMaxAggregateInputType
  }

  export type GetPostAccountsAggregateType<T extends PostAccountsAggregateArgs> = {
        [P in keyof T & keyof AggregatePostAccounts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostAccounts[P]>
      : GetScalarType<T[P], AggregatePostAccounts[P]>
  }




  export type PostAccountsGroupByArgs = {
    where?: PostAccountsWhereInput
    orderBy?: Enumerable<PostAccountsOrderByWithAggregationInput>
    by: Array<PostAccountsScalarFieldEnum>
    having?: PostAccountsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostAccountsCountAggregateInputType | true
    _avg?: PostAccountsAvgAggregateInputType
    _sum?: PostAccountsSumAggregateInputType
    _min?: PostAccountsMinAggregateInputType
    _max?: PostAccountsMaxAggregateInputType
  }


  export type PostAccountsGroupByOutputType = {
    id: number
    AccountId: number | null
    PostId: number | null
    type: string | null
    createdAt: Date
    updatedAt: Date
    _count: PostAccountsCountAggregateOutputType | null
    _avg: PostAccountsAvgAggregateOutputType | null
    _sum: PostAccountsSumAggregateOutputType | null
    _min: PostAccountsMinAggregateOutputType | null
    _max: PostAccountsMaxAggregateOutputType | null
  }

  type GetPostAccountsGroupByPayload<T extends PostAccountsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PostAccountsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostAccountsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostAccountsGroupByOutputType[P]>
            : GetScalarType<T[P], PostAccountsGroupByOutputType[P]>
        }
      >
    >


  export type PostAccountsSelect = {
    id?: boolean
    AccountId?: boolean
    PostId?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Accounts?: boolean | AccountsArgs
    Posts?: boolean | PostsArgs
  }

  export type PostAccountsInclude = {
    Accounts?: boolean | AccountsArgs
    Posts?: boolean | PostsArgs
  }

  export type PostAccountsGetPayload<
    S extends boolean | null | undefined | PostAccountsArgs,
    U = keyof S
      > = S extends true
        ? PostAccounts
    : S extends undefined
    ? never
    : S extends PostAccountsArgs | PostAccountsFindManyArgs
    ?'include' extends U
    ? PostAccounts  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'Posts' ? PostsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'Posts' ? PostsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof PostAccounts ? PostAccounts[P] : never
  } 
    : PostAccounts
  : PostAccounts


  type PostAccountsCountArgs = Merge<
    Omit<PostAccountsFindManyArgs, 'select' | 'include'> & {
      select?: PostAccountsCountAggregateInputType | true
    }
  >

  export interface PostAccountsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one PostAccounts that matches the filter.
     * @param {PostAccountsFindUniqueArgs} args - Arguments to find a PostAccounts
     * @example
     * // Get one PostAccounts
     * const postAccounts = await prisma.postAccounts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PostAccountsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PostAccountsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PostAccounts'> extends True ? CheckSelect<T, Prisma__PostAccountsClient<PostAccounts>, Prisma__PostAccountsClient<PostAccountsGetPayload<T>>> : CheckSelect<T, Prisma__PostAccountsClient<PostAccounts | null, null>, Prisma__PostAccountsClient<PostAccountsGetPayload<T> | null, null>>

    /**
     * Find the first PostAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAccountsFindFirstArgs} args - Arguments to find a PostAccounts
     * @example
     * // Get one PostAccounts
     * const postAccounts = await prisma.postAccounts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PostAccountsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PostAccountsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PostAccounts'> extends True ? CheckSelect<T, Prisma__PostAccountsClient<PostAccounts>, Prisma__PostAccountsClient<PostAccountsGetPayload<T>>> : CheckSelect<T, Prisma__PostAccountsClient<PostAccounts | null, null>, Prisma__PostAccountsClient<PostAccountsGetPayload<T> | null, null>>

    /**
     * Find zero or more PostAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAccountsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostAccounts
     * const postAccounts = await prisma.postAccounts.findMany()
     * 
     * // Get first 10 PostAccounts
     * const postAccounts = await prisma.postAccounts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postAccountsWithIdOnly = await prisma.postAccounts.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PostAccountsFindManyArgs>(
      args?: SelectSubset<T, PostAccountsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PostAccounts>>, PrismaPromise<Array<PostAccountsGetPayload<T>>>>

    /**
     * Create a PostAccounts.
     * @param {PostAccountsCreateArgs} args - Arguments to create a PostAccounts.
     * @example
     * // Create one PostAccounts
     * const PostAccounts = await prisma.postAccounts.create({
     *   data: {
     *     // ... data to create a PostAccounts
     *   }
     * })
     * 
    **/
    create<T extends PostAccountsCreateArgs>(
      args: SelectSubset<T, PostAccountsCreateArgs>
    ): CheckSelect<T, Prisma__PostAccountsClient<PostAccounts>, Prisma__PostAccountsClient<PostAccountsGetPayload<T>>>

    /**
     * Create many PostAccounts.
     *     @param {PostAccountsCreateManyArgs} args - Arguments to create many PostAccounts.
     *     @example
     *     // Create many PostAccounts
     *     const postAccounts = await prisma.postAccounts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PostAccountsCreateManyArgs>(
      args?: SelectSubset<T, PostAccountsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PostAccounts.
     * @param {PostAccountsDeleteArgs} args - Arguments to delete one PostAccounts.
     * @example
     * // Delete one PostAccounts
     * const PostAccounts = await prisma.postAccounts.delete({
     *   where: {
     *     // ... filter to delete one PostAccounts
     *   }
     * })
     * 
    **/
    delete<T extends PostAccountsDeleteArgs>(
      args: SelectSubset<T, PostAccountsDeleteArgs>
    ): CheckSelect<T, Prisma__PostAccountsClient<PostAccounts>, Prisma__PostAccountsClient<PostAccountsGetPayload<T>>>

    /**
     * Update one PostAccounts.
     * @param {PostAccountsUpdateArgs} args - Arguments to update one PostAccounts.
     * @example
     * // Update one PostAccounts
     * const postAccounts = await prisma.postAccounts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PostAccountsUpdateArgs>(
      args: SelectSubset<T, PostAccountsUpdateArgs>
    ): CheckSelect<T, Prisma__PostAccountsClient<PostAccounts>, Prisma__PostAccountsClient<PostAccountsGetPayload<T>>>

    /**
     * Delete zero or more PostAccounts.
     * @param {PostAccountsDeleteManyArgs} args - Arguments to filter PostAccounts to delete.
     * @example
     * // Delete a few PostAccounts
     * const { count } = await prisma.postAccounts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PostAccountsDeleteManyArgs>(
      args?: SelectSubset<T, PostAccountsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAccountsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostAccounts
     * const postAccounts = await prisma.postAccounts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PostAccountsUpdateManyArgs>(
      args: SelectSubset<T, PostAccountsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PostAccounts.
     * @param {PostAccountsUpsertArgs} args - Arguments to update or create a PostAccounts.
     * @example
     * // Update or create a PostAccounts
     * const postAccounts = await prisma.postAccounts.upsert({
     *   create: {
     *     // ... data to create a PostAccounts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostAccounts we want to update
     *   }
     * })
    **/
    upsert<T extends PostAccountsUpsertArgs>(
      args: SelectSubset<T, PostAccountsUpsertArgs>
    ): CheckSelect<T, Prisma__PostAccountsClient<PostAccounts>, Prisma__PostAccountsClient<PostAccountsGetPayload<T>>>

    /**
     * Find one PostAccounts that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PostAccountsFindUniqueOrThrowArgs} args - Arguments to find a PostAccounts
     * @example
     * // Get one PostAccounts
     * const postAccounts = await prisma.postAccounts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PostAccountsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PostAccountsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PostAccountsClient<PostAccounts>, Prisma__PostAccountsClient<PostAccountsGetPayload<T>>>

    /**
     * Find the first PostAccounts that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAccountsFindFirstOrThrowArgs} args - Arguments to find a PostAccounts
     * @example
     * // Get one PostAccounts
     * const postAccounts = await prisma.postAccounts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PostAccountsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PostAccountsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PostAccountsClient<PostAccounts>, Prisma__PostAccountsClient<PostAccountsGetPayload<T>>>

    /**
     * Count the number of PostAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAccountsCountArgs} args - Arguments to filter PostAccounts to count.
     * @example
     * // Count the number of PostAccounts
     * const count = await prisma.postAccounts.count({
     *   where: {
     *     // ... the filter for the PostAccounts we want to count
     *   }
     * })
    **/
    count<T extends PostAccountsCountArgs>(
      args?: Subset<T, PostAccountsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostAccountsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAccountsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAccountsAggregateArgs>(args: Subset<T, PostAccountsAggregateArgs>): PrismaPromise<GetPostAccountsAggregateType<T>>

    /**
     * Group by PostAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAccountsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostAccountsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostAccountsGroupByArgs['orderBy'] }
        : { orderBy?: PostAccountsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostAccountsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostAccountsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PostAccounts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PostAccountsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Accounts<T extends AccountsArgs = {}>(args?: Subset<T, AccountsArgs>): CheckSelect<T, Prisma__AccountsClient<Accounts | Null>, Prisma__AccountsClient<AccountsGetPayload<T> | Null>>;

    Posts<T extends PostsArgs = {}>(args?: Subset<T, PostsArgs>): CheckSelect<T, Prisma__PostsClient<Posts | Null>, Prisma__PostsClient<PostsGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PostAccounts base type for findUnique actions
   */
  export type PostAccountsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PostAccounts
     * 
    **/
    select?: PostAccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostAccountsInclude | null
    /**
     * Filter, which PostAccounts to fetch.
     * 
    **/
    where: PostAccountsWhereUniqueInput
  }

  /**
   * PostAccounts: findUnique
   */
  export interface PostAccountsFindUniqueArgs extends PostAccountsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PostAccounts base type for findFirst actions
   */
  export type PostAccountsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PostAccounts
     * 
    **/
    select?: PostAccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostAccountsInclude | null
    /**
     * Filter, which PostAccounts to fetch.
     * 
    **/
    where?: PostAccountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAccounts to fetch.
     * 
    **/
    orderBy?: Enumerable<PostAccountsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostAccounts.
     * 
    **/
    cursor?: PostAccountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAccounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAccounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostAccounts.
     * 
    **/
    distinct?: Enumerable<PostAccountsScalarFieldEnum>
  }

  /**
   * PostAccounts: findFirst
   */
  export interface PostAccountsFindFirstArgs extends PostAccountsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PostAccounts findMany
   */
  export type PostAccountsFindManyArgs = {
    /**
     * Select specific fields to fetch from the PostAccounts
     * 
    **/
    select?: PostAccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostAccountsInclude | null
    /**
     * Filter, which PostAccounts to fetch.
     * 
    **/
    where?: PostAccountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAccounts to fetch.
     * 
    **/
    orderBy?: Enumerable<PostAccountsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostAccounts.
     * 
    **/
    cursor?: PostAccountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAccounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAccounts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PostAccountsScalarFieldEnum>
  }


  /**
   * PostAccounts create
   */
  export type PostAccountsCreateArgs = {
    /**
     * Select specific fields to fetch from the PostAccounts
     * 
    **/
    select?: PostAccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostAccountsInclude | null
    /**
     * The data needed to create a PostAccounts.
     * 
    **/
    data: XOR<PostAccountsCreateInput, PostAccountsUncheckedCreateInput>
  }


  /**
   * PostAccounts createMany
   */
  export type PostAccountsCreateManyArgs = {
    /**
     * The data used to create many PostAccounts.
     * 
    **/
    data: Enumerable<PostAccountsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PostAccounts update
   */
  export type PostAccountsUpdateArgs = {
    /**
     * Select specific fields to fetch from the PostAccounts
     * 
    **/
    select?: PostAccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostAccountsInclude | null
    /**
     * The data needed to update a PostAccounts.
     * 
    **/
    data: XOR<PostAccountsUpdateInput, PostAccountsUncheckedUpdateInput>
    /**
     * Choose, which PostAccounts to update.
     * 
    **/
    where: PostAccountsWhereUniqueInput
  }


  /**
   * PostAccounts updateMany
   */
  export type PostAccountsUpdateManyArgs = {
    /**
     * The data used to update PostAccounts.
     * 
    **/
    data: XOR<PostAccountsUpdateManyMutationInput, PostAccountsUncheckedUpdateManyInput>
    /**
     * Filter which PostAccounts to update
     * 
    **/
    where?: PostAccountsWhereInput
  }


  /**
   * PostAccounts upsert
   */
  export type PostAccountsUpsertArgs = {
    /**
     * Select specific fields to fetch from the PostAccounts
     * 
    **/
    select?: PostAccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostAccountsInclude | null
    /**
     * The filter to search for the PostAccounts to update in case it exists.
     * 
    **/
    where: PostAccountsWhereUniqueInput
    /**
     * In case the PostAccounts found by the `where` argument doesn't exist, create a new PostAccounts with this data.
     * 
    **/
    create: XOR<PostAccountsCreateInput, PostAccountsUncheckedCreateInput>
    /**
     * In case the PostAccounts was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PostAccountsUpdateInput, PostAccountsUncheckedUpdateInput>
  }


  /**
   * PostAccounts delete
   */
  export type PostAccountsDeleteArgs = {
    /**
     * Select specific fields to fetch from the PostAccounts
     * 
    **/
    select?: PostAccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostAccountsInclude | null
    /**
     * Filter which PostAccounts to delete.
     * 
    **/
    where: PostAccountsWhereUniqueInput
  }


  /**
   * PostAccounts deleteMany
   */
  export type PostAccountsDeleteManyArgs = {
    /**
     * Filter which PostAccounts to delete
     * 
    **/
    where?: PostAccountsWhereInput
  }


  /**
   * PostAccounts: findUniqueOrThrow
   */
  export type PostAccountsFindUniqueOrThrowArgs = PostAccountsFindUniqueArgsBase
      

  /**
   * PostAccounts: findFirstOrThrow
   */
  export type PostAccountsFindFirstOrThrowArgs = PostAccountsFindFirstArgsBase
      

  /**
   * PostAccounts without action
   */
  export type PostAccountsArgs = {
    /**
     * Select specific fields to fetch from the PostAccounts
     * 
    **/
    select?: PostAccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostAccountsInclude | null
  }



  /**
   * Model Posts
   */


  export type AggregatePosts = {
    _count: PostsCountAggregateOutputType | null
    _avg: PostsAvgAggregateOutputType | null
    _sum: PostsSumAggregateOutputType | null
    _min: PostsMinAggregateOutputType | null
    _max: PostsMaxAggregateOutputType | null
  }

  export type PostsAvgAggregateOutputType = {
    id: number | null
    price: number | null
    area: Decimal | null
    viewCount: number | null
    AccountId: number | null
  }

  export type PostsSumAggregateOutputType = {
    id: number | null
    price: number | null
    area: Decimal | null
    viewCount: number | null
    AccountId: number | null
  }

  export type PostsMinAggregateOutputType = {
    id: number | null
    category: string | null
    content: string | null
    unit: string | null
    price: number | null
    area: Decimal | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
    viewCount: number | null
    AccountId: number | null
    contactName: string | null
    contactPhone: string | null
    contactEmail: string | null
  }

  export type PostsMaxAggregateOutputType = {
    id: number | null
    category: string | null
    content: string | null
    unit: string | null
    price: number | null
    area: Decimal | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
    viewCount: number | null
    AccountId: number | null
    contactName: string | null
    contactPhone: string | null
    contactEmail: string | null
  }

  export type PostsCountAggregateOutputType = {
    id: number
    category: number
    type: number
    content: number
    unit: number
    price: number
    location: number
    area: number
    title: number
    createdAt: number
    updatedAt: number
    startDate: number
    endDate: number
    status: number
    viewCount: number
    AccountId: number
    contactName: number
    contactPhone: number
    contactEmail: number
    qualifications: number
    _all: number
  }


  export type PostsAvgAggregateInputType = {
    id?: true
    price?: true
    area?: true
    viewCount?: true
    AccountId?: true
  }

  export type PostsSumAggregateInputType = {
    id?: true
    price?: true
    area?: true
    viewCount?: true
    AccountId?: true
  }

  export type PostsMinAggregateInputType = {
    id?: true
    category?: true
    content?: true
    unit?: true
    price?: true
    area?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    startDate?: true
    endDate?: true
    status?: true
    viewCount?: true
    AccountId?: true
    contactName?: true
    contactPhone?: true
    contactEmail?: true
  }

  export type PostsMaxAggregateInputType = {
    id?: true
    category?: true
    content?: true
    unit?: true
    price?: true
    area?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    startDate?: true
    endDate?: true
    status?: true
    viewCount?: true
    AccountId?: true
    contactName?: true
    contactPhone?: true
    contactEmail?: true
  }

  export type PostsCountAggregateInputType = {
    id?: true
    category?: true
    type?: true
    content?: true
    unit?: true
    price?: true
    location?: true
    area?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    startDate?: true
    endDate?: true
    status?: true
    viewCount?: true
    AccountId?: true
    contactName?: true
    contactPhone?: true
    contactEmail?: true
    qualifications?: true
    _all?: true
  }

  export type PostsAggregateArgs = {
    /**
     * Filter which Posts to aggregate.
     * 
    **/
    where?: PostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     * 
    **/
    orderBy?: Enumerable<PostsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostsMaxAggregateInputType
  }

  export type GetPostsAggregateType<T extends PostsAggregateArgs> = {
        [P in keyof T & keyof AggregatePosts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosts[P]>
      : GetScalarType<T[P], AggregatePosts[P]>
  }




  export type PostsGroupByArgs = {
    where?: PostsWhereInput
    orderBy?: Enumerable<PostsOrderByWithAggregationInput>
    by: Array<PostsScalarFieldEnum>
    having?: PostsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostsCountAggregateInputType | true
    _avg?: PostsAvgAggregateInputType
    _sum?: PostsSumAggregateInputType
    _min?: PostsMinAggregateInputType
    _max?: PostsMaxAggregateInputType
  }


  export type PostsGroupByOutputType = {
    id: number
    category: string | null
    type: string[]
    content: string | null
    unit: string | null
    price: number | null
    location: string[]
    area: Decimal | null
    title: string | null
    createdAt: Date
    updatedAt: Date
    startDate: Date | null
    endDate: Date | null
    status: string | null
    viewCount: number | null
    AccountId: number | null
    contactName: string | null
    contactPhone: string | null
    contactEmail: string | null
    qualifications: string[]
    _count: PostsCountAggregateOutputType | null
    _avg: PostsAvgAggregateOutputType | null
    _sum: PostsSumAggregateOutputType | null
    _min: PostsMinAggregateOutputType | null
    _max: PostsMaxAggregateOutputType | null
  }

  type GetPostsGroupByPayload<T extends PostsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PostsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostsGroupByOutputType[P]>
            : GetScalarType<T[P], PostsGroupByOutputType[P]>
        }
      >
    >


  export type PostsSelect = {
    id?: boolean
    category?: boolean
    type?: boolean
    content?: boolean
    unit?: boolean
    price?: boolean
    location?: boolean
    area?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    viewCount?: boolean
    AccountId?: boolean
    contactName?: boolean
    contactPhone?: boolean
    contactEmail?: boolean
    qualifications?: boolean
    Accounts?: boolean | AccountsArgs
    PostAccounts?: boolean | PostAccountsFindManyArgs
    _count?: boolean | PostsCountOutputTypeArgs
  }

  export type PostsInclude = {
    Accounts?: boolean | AccountsArgs
    PostAccounts?: boolean | PostAccountsFindManyArgs
    _count?: boolean | PostsCountOutputTypeArgs
  }

  export type PostsGetPayload<
    S extends boolean | null | undefined | PostsArgs,
    U = keyof S
      > = S extends true
        ? Posts
    : S extends undefined
    ? never
    : S extends PostsArgs | PostsFindManyArgs
    ?'include' extends U
    ? Posts  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'PostAccounts' ? Array < PostAccountsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? PostsCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'PostAccounts' ? Array < PostAccountsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? PostsCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Posts ? Posts[P] : never
  } 
    : Posts
  : Posts


  type PostsCountArgs = Merge<
    Omit<PostsFindManyArgs, 'select' | 'include'> & {
      select?: PostsCountAggregateInputType | true
    }
  >

  export interface PostsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Posts that matches the filter.
     * @param {PostsFindUniqueArgs} args - Arguments to find a Posts
     * @example
     * // Get one Posts
     * const posts = await prisma.posts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PostsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PostsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Posts'> extends True ? CheckSelect<T, Prisma__PostsClient<Posts>, Prisma__PostsClient<PostsGetPayload<T>>> : CheckSelect<T, Prisma__PostsClient<Posts | null, null>, Prisma__PostsClient<PostsGetPayload<T> | null, null>>

    /**
     * Find the first Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsFindFirstArgs} args - Arguments to find a Posts
     * @example
     * // Get one Posts
     * const posts = await prisma.posts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PostsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PostsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Posts'> extends True ? CheckSelect<T, Prisma__PostsClient<Posts>, Prisma__PostsClient<PostsGetPayload<T>>> : CheckSelect<T, Prisma__PostsClient<Posts | null, null>, Prisma__PostsClient<PostsGetPayload<T> | null, null>>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.posts.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.posts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postsWithIdOnly = await prisma.posts.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PostsFindManyArgs>(
      args?: SelectSubset<T, PostsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Posts>>, PrismaPromise<Array<PostsGetPayload<T>>>>

    /**
     * Create a Posts.
     * @param {PostsCreateArgs} args - Arguments to create a Posts.
     * @example
     * // Create one Posts
     * const Posts = await prisma.posts.create({
     *   data: {
     *     // ... data to create a Posts
     *   }
     * })
     * 
    **/
    create<T extends PostsCreateArgs>(
      args: SelectSubset<T, PostsCreateArgs>
    ): CheckSelect<T, Prisma__PostsClient<Posts>, Prisma__PostsClient<PostsGetPayload<T>>>

    /**
     * Create many Posts.
     *     @param {PostsCreateManyArgs} args - Arguments to create many Posts.
     *     @example
     *     // Create many Posts
     *     const posts = await prisma.posts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PostsCreateManyArgs>(
      args?: SelectSubset<T, PostsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Posts.
     * @param {PostsDeleteArgs} args - Arguments to delete one Posts.
     * @example
     * // Delete one Posts
     * const Posts = await prisma.posts.delete({
     *   where: {
     *     // ... filter to delete one Posts
     *   }
     * })
     * 
    **/
    delete<T extends PostsDeleteArgs>(
      args: SelectSubset<T, PostsDeleteArgs>
    ): CheckSelect<T, Prisma__PostsClient<Posts>, Prisma__PostsClient<PostsGetPayload<T>>>

    /**
     * Update one Posts.
     * @param {PostsUpdateArgs} args - Arguments to update one Posts.
     * @example
     * // Update one Posts
     * const posts = await prisma.posts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PostsUpdateArgs>(
      args: SelectSubset<T, PostsUpdateArgs>
    ): CheckSelect<T, Prisma__PostsClient<Posts>, Prisma__PostsClient<PostsGetPayload<T>>>

    /**
     * Delete zero or more Posts.
     * @param {PostsDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.posts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PostsDeleteManyArgs>(
      args?: SelectSubset<T, PostsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const posts = await prisma.posts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PostsUpdateManyArgs>(
      args: SelectSubset<T, PostsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Posts.
     * @param {PostsUpsertArgs} args - Arguments to update or create a Posts.
     * @example
     * // Update or create a Posts
     * const posts = await prisma.posts.upsert({
     *   create: {
     *     // ... data to create a Posts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Posts we want to update
     *   }
     * })
    **/
    upsert<T extends PostsUpsertArgs>(
      args: SelectSubset<T, PostsUpsertArgs>
    ): CheckSelect<T, Prisma__PostsClient<Posts>, Prisma__PostsClient<PostsGetPayload<T>>>

    /**
     * Find one Posts that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PostsFindUniqueOrThrowArgs} args - Arguments to find a Posts
     * @example
     * // Get one Posts
     * const posts = await prisma.posts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PostsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PostsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PostsClient<Posts>, Prisma__PostsClient<PostsGetPayload<T>>>

    /**
     * Find the first Posts that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsFindFirstOrThrowArgs} args - Arguments to find a Posts
     * @example
     * // Get one Posts
     * const posts = await prisma.posts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PostsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PostsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PostsClient<Posts>, Prisma__PostsClient<PostsGetPayload<T>>>

    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.posts.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostsCountArgs>(
      args?: Subset<T, PostsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostsAggregateArgs>(args: Subset<T, PostsAggregateArgs>): PrismaPromise<GetPostsAggregateType<T>>

    /**
     * Group by Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostsGroupByArgs['orderBy'] }
        : { orderBy?: PostsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Posts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PostsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Accounts<T extends AccountsArgs = {}>(args?: Subset<T, AccountsArgs>): CheckSelect<T, Prisma__AccountsClient<Accounts | Null>, Prisma__AccountsClient<AccountsGetPayload<T> | Null>>;

    PostAccounts<T extends PostAccountsFindManyArgs = {}>(args?: Subset<T, PostAccountsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PostAccounts>| Null>, PrismaPromise<Array<PostAccountsGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Posts base type for findUnique actions
   */
  export type PostsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Posts
     * 
    **/
    select?: PostsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostsInclude | null
    /**
     * Filter, which Posts to fetch.
     * 
    **/
    where: PostsWhereUniqueInput
  }

  /**
   * Posts: findUnique
   */
  export interface PostsFindUniqueArgs extends PostsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Posts base type for findFirst actions
   */
  export type PostsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Posts
     * 
    **/
    select?: PostsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostsInclude | null
    /**
     * Filter, which Posts to fetch.
     * 
    **/
    where?: PostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     * 
    **/
    orderBy?: Enumerable<PostsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     * 
    **/
    cursor?: PostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     * 
    **/
    distinct?: Enumerable<PostsScalarFieldEnum>
  }

  /**
   * Posts: findFirst
   */
  export interface PostsFindFirstArgs extends PostsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Posts findMany
   */
  export type PostsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Posts
     * 
    **/
    select?: PostsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostsInclude | null
    /**
     * Filter, which Posts to fetch.
     * 
    **/
    where?: PostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     * 
    **/
    orderBy?: Enumerable<PostsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     * 
    **/
    cursor?: PostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PostsScalarFieldEnum>
  }


  /**
   * Posts create
   */
  export type PostsCreateArgs = {
    /**
     * Select specific fields to fetch from the Posts
     * 
    **/
    select?: PostsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostsInclude | null
    /**
     * The data needed to create a Posts.
     * 
    **/
    data: XOR<PostsCreateInput, PostsUncheckedCreateInput>
  }


  /**
   * Posts createMany
   */
  export type PostsCreateManyArgs = {
    /**
     * The data used to create many Posts.
     * 
    **/
    data: Enumerable<PostsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Posts update
   */
  export type PostsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Posts
     * 
    **/
    select?: PostsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostsInclude | null
    /**
     * The data needed to update a Posts.
     * 
    **/
    data: XOR<PostsUpdateInput, PostsUncheckedUpdateInput>
    /**
     * Choose, which Posts to update.
     * 
    **/
    where: PostsWhereUniqueInput
  }


  /**
   * Posts updateMany
   */
  export type PostsUpdateManyArgs = {
    /**
     * The data used to update Posts.
     * 
    **/
    data: XOR<PostsUpdateManyMutationInput, PostsUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     * 
    **/
    where?: PostsWhereInput
  }


  /**
   * Posts upsert
   */
  export type PostsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Posts
     * 
    **/
    select?: PostsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostsInclude | null
    /**
     * The filter to search for the Posts to update in case it exists.
     * 
    **/
    where: PostsWhereUniqueInput
    /**
     * In case the Posts found by the `where` argument doesn't exist, create a new Posts with this data.
     * 
    **/
    create: XOR<PostsCreateInput, PostsUncheckedCreateInput>
    /**
     * In case the Posts was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PostsUpdateInput, PostsUncheckedUpdateInput>
  }


  /**
   * Posts delete
   */
  export type PostsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Posts
     * 
    **/
    select?: PostsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostsInclude | null
    /**
     * Filter which Posts to delete.
     * 
    **/
    where: PostsWhereUniqueInput
  }


  /**
   * Posts deleteMany
   */
  export type PostsDeleteManyArgs = {
    /**
     * Filter which Posts to delete
     * 
    **/
    where?: PostsWhereInput
  }


  /**
   * Posts: findUniqueOrThrow
   */
  export type PostsFindUniqueOrThrowArgs = PostsFindUniqueArgsBase
      

  /**
   * Posts: findFirstOrThrow
   */
  export type PostsFindFirstOrThrowArgs = PostsFindFirstArgsBase
      

  /**
   * Posts without action
   */
  export type PostsArgs = {
    /**
     * Select specific fields to fetch from the Posts
     * 
    **/
    select?: PostsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostsInclude | null
  }



  /**
   * Model Products
   */


  export type AggregateProducts = {
    _count: ProductsCountAggregateOutputType | null
    _avg: ProductsAvgAggregateOutputType | null
    _sum: ProductsSumAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  export type ProductsAvgAggregateOutputType = {
    id: number | null
    price: number | null
    duration: number | null
  }

  export type ProductsSumAggregateOutputType = {
    id: number | null
    price: number | null
    duration: number | null
  }

  export type ProductsMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    price: number | null
    duration: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    isSubscribe: boolean | null
  }

  export type ProductsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    price: number | null
    duration: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    isSubscribe: boolean | null
  }

  export type ProductsCountAggregateOutputType = {
    id: number
    name: number
    description: number
    price: number
    duration: number
    filters: number
    isActive: number
    createdAt: number
    updatedAt: number
    isSubscribe: number
    _all: number
  }


  export type ProductsAvgAggregateInputType = {
    id?: true
    price?: true
    duration?: true
  }

  export type ProductsSumAggregateInputType = {
    id?: true
    price?: true
    duration?: true
  }

  export type ProductsMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    duration?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    isSubscribe?: true
  }

  export type ProductsMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    duration?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    isSubscribe?: true
  }

  export type ProductsCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    duration?: true
    filters?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    isSubscribe?: true
    _all?: true
  }

  export type ProductsAggregateArgs = {
    /**
     * Filter which Products to aggregate.
     * 
    **/
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductsMaxAggregateInputType
  }

  export type GetProductsAggregateType<T extends ProductsAggregateArgs> = {
        [P in keyof T & keyof AggregateProducts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducts[P]>
      : GetScalarType<T[P], AggregateProducts[P]>
  }




  export type ProductsGroupByArgs = {
    where?: ProductsWhereInput
    orderBy?: Enumerable<ProductsOrderByWithAggregationInput>
    by: Array<ProductsScalarFieldEnum>
    having?: ProductsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductsCountAggregateInputType | true
    _avg?: ProductsAvgAggregateInputType
    _sum?: ProductsSumAggregateInputType
    _min?: ProductsMinAggregateInputType
    _max?: ProductsMaxAggregateInputType
  }


  export type ProductsGroupByOutputType = {
    id: number
    name: string | null
    description: string | null
    price: number | null
    duration: number | null
    filters: JsonValue | null
    isActive: boolean | null
    createdAt: Date
    updatedAt: Date
    isSubscribe: boolean | null
    _count: ProductsCountAggregateOutputType | null
    _avg: ProductsAvgAggregateOutputType | null
    _sum: ProductsSumAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  type GetProductsGroupByPayload<T extends ProductsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProductsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductsGroupByOutputType[P]>
            : GetScalarType<T[P], ProductsGroupByOutputType[P]>
        }
      >
    >


  export type ProductsSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    duration?: boolean
    filters?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isSubscribe?: boolean
    Discounts?: boolean | DiscountsFindManyArgs
    OrderHistories?: boolean | OrderHistoriesFindManyArgs
    Orders?: boolean | OrdersFindManyArgs
    _count?: boolean | ProductsCountOutputTypeArgs
  }

  export type ProductsInclude = {
    Discounts?: boolean | DiscountsFindManyArgs
    OrderHistories?: boolean | OrderHistoriesFindManyArgs
    Orders?: boolean | OrdersFindManyArgs
    _count?: boolean | ProductsCountOutputTypeArgs
  }

  export type ProductsGetPayload<
    S extends boolean | null | undefined | ProductsArgs,
    U = keyof S
      > = S extends true
        ? Products
    : S extends undefined
    ? never
    : S extends ProductsArgs | ProductsFindManyArgs
    ?'include' extends U
    ? Products  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Discounts' ? Array < DiscountsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'OrderHistories' ? Array < OrderHistoriesGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Orders' ? Array < OrdersGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? ProductsCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Discounts' ? Array < DiscountsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'OrderHistories' ? Array < OrderHistoriesGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Orders' ? Array < OrdersGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? ProductsCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Products ? Products[P] : never
  } 
    : Products
  : Products


  type ProductsCountArgs = Merge<
    Omit<ProductsFindManyArgs, 'select' | 'include'> & {
      select?: ProductsCountAggregateInputType | true
    }
  >

  export interface ProductsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Products that matches the filter.
     * @param {ProductsFindUniqueArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Products'> extends True ? CheckSelect<T, Prisma__ProductsClient<Products>, Prisma__ProductsClient<ProductsGetPayload<T>>> : CheckSelect<T, Prisma__ProductsClient<Products | null, null>, Prisma__ProductsClient<ProductsGetPayload<T> | null, null>>

    /**
     * Find the first Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsFindFirstArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Products'> extends True ? CheckSelect<T, Prisma__ProductsClient<Products>, Prisma__ProductsClient<ProductsGetPayload<T>>> : CheckSelect<T, Prisma__ProductsClient<Products | null, null>, Prisma__ProductsClient<ProductsGetPayload<T> | null, null>>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.products.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.products.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productsWithIdOnly = await prisma.products.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductsFindManyArgs>(
      args?: SelectSubset<T, ProductsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Products>>, PrismaPromise<Array<ProductsGetPayload<T>>>>

    /**
     * Create a Products.
     * @param {ProductsCreateArgs} args - Arguments to create a Products.
     * @example
     * // Create one Products
     * const Products = await prisma.products.create({
     *   data: {
     *     // ... data to create a Products
     *   }
     * })
     * 
    **/
    create<T extends ProductsCreateArgs>(
      args: SelectSubset<T, ProductsCreateArgs>
    ): CheckSelect<T, Prisma__ProductsClient<Products>, Prisma__ProductsClient<ProductsGetPayload<T>>>

    /**
     * Create many Products.
     *     @param {ProductsCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const products = await prisma.products.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductsCreateManyArgs>(
      args?: SelectSubset<T, ProductsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Products.
     * @param {ProductsDeleteArgs} args - Arguments to delete one Products.
     * @example
     * // Delete one Products
     * const Products = await prisma.products.delete({
     *   where: {
     *     // ... filter to delete one Products
     *   }
     * })
     * 
    **/
    delete<T extends ProductsDeleteArgs>(
      args: SelectSubset<T, ProductsDeleteArgs>
    ): CheckSelect<T, Prisma__ProductsClient<Products>, Prisma__ProductsClient<ProductsGetPayload<T>>>

    /**
     * Update one Products.
     * @param {ProductsUpdateArgs} args - Arguments to update one Products.
     * @example
     * // Update one Products
     * const products = await prisma.products.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductsUpdateArgs>(
      args: SelectSubset<T, ProductsUpdateArgs>
    ): CheckSelect<T, Prisma__ProductsClient<Products>, Prisma__ProductsClient<ProductsGetPayload<T>>>

    /**
     * Delete zero or more Products.
     * @param {ProductsDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.products.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductsDeleteManyArgs>(
      args?: SelectSubset<T, ProductsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const products = await prisma.products.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductsUpdateManyArgs>(
      args: SelectSubset<T, ProductsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Products.
     * @param {ProductsUpsertArgs} args - Arguments to update or create a Products.
     * @example
     * // Update or create a Products
     * const products = await prisma.products.upsert({
     *   create: {
     *     // ... data to create a Products
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Products we want to update
     *   }
     * })
    **/
    upsert<T extends ProductsUpsertArgs>(
      args: SelectSubset<T, ProductsUpsertArgs>
    ): CheckSelect<T, Prisma__ProductsClient<Products>, Prisma__ProductsClient<ProductsGetPayload<T>>>

    /**
     * Find one Products that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ProductsFindUniqueOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProductsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ProductsClient<Products>, Prisma__ProductsClient<ProductsGetPayload<T>>>

    /**
     * Find the first Products that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsFindFirstOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ProductsClient<Products>, Prisma__ProductsClient<ProductsGetPayload<T>>>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.products.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductsCountArgs>(
      args?: Subset<T, ProductsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductsAggregateArgs>(args: Subset<T, ProductsAggregateArgs>): PrismaPromise<GetProductsAggregateType<T>>

    /**
     * Group by Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductsGroupByArgs['orderBy'] }
        : { orderBy?: ProductsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Products.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Discounts<T extends DiscountsFindManyArgs = {}>(args?: Subset<T, DiscountsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Discounts>| Null>, PrismaPromise<Array<DiscountsGetPayload<T>>| Null>>;

    OrderHistories<T extends OrderHistoriesFindManyArgs = {}>(args?: Subset<T, OrderHistoriesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OrderHistories>| Null>, PrismaPromise<Array<OrderHistoriesGetPayload<T>>| Null>>;

    Orders<T extends OrdersFindManyArgs = {}>(args?: Subset<T, OrdersFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Orders>| Null>, PrismaPromise<Array<OrdersGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Products base type for findUnique actions
   */
  export type ProductsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Products
     * 
    **/
    select?: ProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsInclude | null
    /**
     * Filter, which Products to fetch.
     * 
    **/
    where: ProductsWhereUniqueInput
  }

  /**
   * Products: findUnique
   */
  export interface ProductsFindUniqueArgs extends ProductsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Products base type for findFirst actions
   */
  export type ProductsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Products
     * 
    **/
    select?: ProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsInclude | null
    /**
     * Filter, which Products to fetch.
     * 
    **/
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     * 
    **/
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     * 
    **/
    distinct?: Enumerable<ProductsScalarFieldEnum>
  }

  /**
   * Products: findFirst
   */
  export interface ProductsFindFirstArgs extends ProductsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Products findMany
   */
  export type ProductsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Products
     * 
    **/
    select?: ProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsInclude | null
    /**
     * Filter, which Products to fetch.
     * 
    **/
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     * 
    **/
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductsScalarFieldEnum>
  }


  /**
   * Products create
   */
  export type ProductsCreateArgs = {
    /**
     * Select specific fields to fetch from the Products
     * 
    **/
    select?: ProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsInclude | null
    /**
     * The data needed to create a Products.
     * 
    **/
    data: XOR<ProductsCreateInput, ProductsUncheckedCreateInput>
  }


  /**
   * Products createMany
   */
  export type ProductsCreateManyArgs = {
    /**
     * The data used to create many Products.
     * 
    **/
    data: Enumerable<ProductsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Products update
   */
  export type ProductsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Products
     * 
    **/
    select?: ProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsInclude | null
    /**
     * The data needed to update a Products.
     * 
    **/
    data: XOR<ProductsUpdateInput, ProductsUncheckedUpdateInput>
    /**
     * Choose, which Products to update.
     * 
    **/
    where: ProductsWhereUniqueInput
  }


  /**
   * Products updateMany
   */
  export type ProductsUpdateManyArgs = {
    /**
     * The data used to update Products.
     * 
    **/
    data: XOR<ProductsUpdateManyMutationInput, ProductsUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     * 
    **/
    where?: ProductsWhereInput
  }


  /**
   * Products upsert
   */
  export type ProductsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Products
     * 
    **/
    select?: ProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsInclude | null
    /**
     * The filter to search for the Products to update in case it exists.
     * 
    **/
    where: ProductsWhereUniqueInput
    /**
     * In case the Products found by the `where` argument doesn't exist, create a new Products with this data.
     * 
    **/
    create: XOR<ProductsCreateInput, ProductsUncheckedCreateInput>
    /**
     * In case the Products was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductsUpdateInput, ProductsUncheckedUpdateInput>
  }


  /**
   * Products delete
   */
  export type ProductsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Products
     * 
    **/
    select?: ProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsInclude | null
    /**
     * Filter which Products to delete.
     * 
    **/
    where: ProductsWhereUniqueInput
  }


  /**
   * Products deleteMany
   */
  export type ProductsDeleteManyArgs = {
    /**
     * Filter which Products to delete
     * 
    **/
    where?: ProductsWhereInput
  }


  /**
   * Products: findUniqueOrThrow
   */
  export type ProductsFindUniqueOrThrowArgs = ProductsFindUniqueArgsBase
      

  /**
   * Products: findFirstOrThrow
   */
  export type ProductsFindFirstOrThrowArgs = ProductsFindFirstArgsBase
      

  /**
   * Products without action
   */
  export type ProductsArgs = {
    /**
     * Select specific fields to fetch from the Products
     * 
    **/
    select?: ProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsInclude | null
  }



  /**
   * Model Reports
   */


  export type AggregateReports = {
    _count: ReportsCountAggregateOutputType | null
    _avg: ReportsAvgAggregateOutputType | null
    _sum: ReportsSumAggregateOutputType | null
    _min: ReportsMinAggregateOutputType | null
    _max: ReportsMaxAggregateOutputType | null
  }

  export type ReportsAvgAggregateOutputType = {
    id: number | null
    TaskId: number | null
    AccountId: number | null
  }

  export type ReportsSumAggregateOutputType = {
    id: number | null
    TaskId: number | null
    AccountId: number | null
  }

  export type ReportsMinAggregateOutputType = {
    id: number | null
    name: string | null
    isActive: boolean | null
    isPrivate: boolean | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
    TaskId: number | null
    AccountId: number | null
  }

  export type ReportsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    isActive: boolean | null
    isPrivate: boolean | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
    TaskId: number | null
    AccountId: number | null
  }

  export type ReportsCountAggregateOutputType = {
    id: number
    name: number
    isActive: number
    isPrivate: number
    password: number
    createdAt: number
    updatedAt: number
    TaskId: number
    AccountId: number
    _all: number
  }


  export type ReportsAvgAggregateInputType = {
    id?: true
    TaskId?: true
    AccountId?: true
  }

  export type ReportsSumAggregateInputType = {
    id?: true
    TaskId?: true
    AccountId?: true
  }

  export type ReportsMinAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    isPrivate?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    TaskId?: true
    AccountId?: true
  }

  export type ReportsMaxAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    isPrivate?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    TaskId?: true
    AccountId?: true
  }

  export type ReportsCountAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    isPrivate?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    TaskId?: true
    AccountId?: true
    _all?: true
  }

  export type ReportsAggregateArgs = {
    /**
     * Filter which Reports to aggregate.
     * 
    **/
    where?: ReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     * 
    **/
    orderBy?: Enumerable<ReportsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportsMaxAggregateInputType
  }

  export type GetReportsAggregateType<T extends ReportsAggregateArgs> = {
        [P in keyof T & keyof AggregateReports]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReports[P]>
      : GetScalarType<T[P], AggregateReports[P]>
  }




  export type ReportsGroupByArgs = {
    where?: ReportsWhereInput
    orderBy?: Enumerable<ReportsOrderByWithAggregationInput>
    by: Array<ReportsScalarFieldEnum>
    having?: ReportsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportsCountAggregateInputType | true
    _avg?: ReportsAvgAggregateInputType
    _sum?: ReportsSumAggregateInputType
    _min?: ReportsMinAggregateInputType
    _max?: ReportsMaxAggregateInputType
  }


  export type ReportsGroupByOutputType = {
    id: number
    name: string | null
    isActive: boolean | null
    isPrivate: boolean | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    TaskId: number | null
    AccountId: number | null
    _count: ReportsCountAggregateOutputType | null
    _avg: ReportsAvgAggregateOutputType | null
    _sum: ReportsSumAggregateOutputType | null
    _min: ReportsMinAggregateOutputType | null
    _max: ReportsMaxAggregateOutputType | null
  }

  type GetReportsGroupByPayload<T extends ReportsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReportsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportsGroupByOutputType[P]>
            : GetScalarType<T[P], ReportsGroupByOutputType[P]>
        }
      >
    >


  export type ReportsSelect = {
    id?: boolean
    name?: boolean
    isActive?: boolean
    isPrivate?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    TaskId?: boolean
    AccountId?: boolean
    Accounts?: boolean | AccountsArgs
    Tasks?: boolean | TasksArgs
  }

  export type ReportsInclude = {
    Accounts?: boolean | AccountsArgs
    Tasks?: boolean | TasksArgs
  }

  export type ReportsGetPayload<
    S extends boolean | null | undefined | ReportsArgs,
    U = keyof S
      > = S extends true
        ? Reports
    : S extends undefined
    ? never
    : S extends ReportsArgs | ReportsFindManyArgs
    ?'include' extends U
    ? Reports  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'Tasks' ? TasksGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'Tasks' ? TasksGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof Reports ? Reports[P] : never
  } 
    : Reports
  : Reports


  type ReportsCountArgs = Merge<
    Omit<ReportsFindManyArgs, 'select' | 'include'> & {
      select?: ReportsCountAggregateInputType | true
    }
  >

  export interface ReportsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Reports that matches the filter.
     * @param {ReportsFindUniqueArgs} args - Arguments to find a Reports
     * @example
     * // Get one Reports
     * const reports = await prisma.reports.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReportsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReportsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Reports'> extends True ? CheckSelect<T, Prisma__ReportsClient<Reports>, Prisma__ReportsClient<ReportsGetPayload<T>>> : CheckSelect<T, Prisma__ReportsClient<Reports | null, null>, Prisma__ReportsClient<ReportsGetPayload<T> | null, null>>

    /**
     * Find the first Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportsFindFirstArgs} args - Arguments to find a Reports
     * @example
     * // Get one Reports
     * const reports = await prisma.reports.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReportsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReportsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Reports'> extends True ? CheckSelect<T, Prisma__ReportsClient<Reports>, Prisma__ReportsClient<ReportsGetPayload<T>>> : CheckSelect<T, Prisma__ReportsClient<Reports | null, null>, Prisma__ReportsClient<ReportsGetPayload<T> | null, null>>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.reports.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.reports.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportsWithIdOnly = await prisma.reports.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReportsFindManyArgs>(
      args?: SelectSubset<T, ReportsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Reports>>, PrismaPromise<Array<ReportsGetPayload<T>>>>

    /**
     * Create a Reports.
     * @param {ReportsCreateArgs} args - Arguments to create a Reports.
     * @example
     * // Create one Reports
     * const Reports = await prisma.reports.create({
     *   data: {
     *     // ... data to create a Reports
     *   }
     * })
     * 
    **/
    create<T extends ReportsCreateArgs>(
      args: SelectSubset<T, ReportsCreateArgs>
    ): CheckSelect<T, Prisma__ReportsClient<Reports>, Prisma__ReportsClient<ReportsGetPayload<T>>>

    /**
     * Create many Reports.
     *     @param {ReportsCreateManyArgs} args - Arguments to create many Reports.
     *     @example
     *     // Create many Reports
     *     const reports = await prisma.reports.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReportsCreateManyArgs>(
      args?: SelectSubset<T, ReportsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Reports.
     * @param {ReportsDeleteArgs} args - Arguments to delete one Reports.
     * @example
     * // Delete one Reports
     * const Reports = await prisma.reports.delete({
     *   where: {
     *     // ... filter to delete one Reports
     *   }
     * })
     * 
    **/
    delete<T extends ReportsDeleteArgs>(
      args: SelectSubset<T, ReportsDeleteArgs>
    ): CheckSelect<T, Prisma__ReportsClient<Reports>, Prisma__ReportsClient<ReportsGetPayload<T>>>

    /**
     * Update one Reports.
     * @param {ReportsUpdateArgs} args - Arguments to update one Reports.
     * @example
     * // Update one Reports
     * const reports = await prisma.reports.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReportsUpdateArgs>(
      args: SelectSubset<T, ReportsUpdateArgs>
    ): CheckSelect<T, Prisma__ReportsClient<Reports>, Prisma__ReportsClient<ReportsGetPayload<T>>>

    /**
     * Delete zero or more Reports.
     * @param {ReportsDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.reports.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReportsDeleteManyArgs>(
      args?: SelectSubset<T, ReportsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const reports = await prisma.reports.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReportsUpdateManyArgs>(
      args: SelectSubset<T, ReportsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Reports.
     * @param {ReportsUpsertArgs} args - Arguments to update or create a Reports.
     * @example
     * // Update or create a Reports
     * const reports = await prisma.reports.upsert({
     *   create: {
     *     // ... data to create a Reports
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reports we want to update
     *   }
     * })
    **/
    upsert<T extends ReportsUpsertArgs>(
      args: SelectSubset<T, ReportsUpsertArgs>
    ): CheckSelect<T, Prisma__ReportsClient<Reports>, Prisma__ReportsClient<ReportsGetPayload<T>>>

    /**
     * Find one Reports that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ReportsFindUniqueOrThrowArgs} args - Arguments to find a Reports
     * @example
     * // Get one Reports
     * const reports = await prisma.reports.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReportsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ReportsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ReportsClient<Reports>, Prisma__ReportsClient<ReportsGetPayload<T>>>

    /**
     * Find the first Reports that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportsFindFirstOrThrowArgs} args - Arguments to find a Reports
     * @example
     * // Get one Reports
     * const reports = await prisma.reports.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReportsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ReportsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ReportsClient<Reports>, Prisma__ReportsClient<ReportsGetPayload<T>>>

    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportsCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.reports.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportsCountArgs>(
      args?: Subset<T, ReportsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportsAggregateArgs>(args: Subset<T, ReportsAggregateArgs>): PrismaPromise<GetReportsAggregateType<T>>

    /**
     * Group by Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportsGroupByArgs['orderBy'] }
        : { orderBy?: ReportsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Reports.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReportsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Accounts<T extends AccountsArgs = {}>(args?: Subset<T, AccountsArgs>): CheckSelect<T, Prisma__AccountsClient<Accounts | Null>, Prisma__AccountsClient<AccountsGetPayload<T> | Null>>;

    Tasks<T extends TasksArgs = {}>(args?: Subset<T, TasksArgs>): CheckSelect<T, Prisma__TasksClient<Tasks | Null>, Prisma__TasksClient<TasksGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Reports base type for findUnique actions
   */
  export type ReportsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Reports
     * 
    **/
    select?: ReportsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReportsInclude | null
    /**
     * Filter, which Reports to fetch.
     * 
    **/
    where: ReportsWhereUniqueInput
  }

  /**
   * Reports: findUnique
   */
  export interface ReportsFindUniqueArgs extends ReportsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Reports base type for findFirst actions
   */
  export type ReportsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Reports
     * 
    **/
    select?: ReportsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReportsInclude | null
    /**
     * Filter, which Reports to fetch.
     * 
    **/
    where?: ReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     * 
    **/
    orderBy?: Enumerable<ReportsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     * 
    **/
    cursor?: ReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     * 
    **/
    distinct?: Enumerable<ReportsScalarFieldEnum>
  }

  /**
   * Reports: findFirst
   */
  export interface ReportsFindFirstArgs extends ReportsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Reports findMany
   */
  export type ReportsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Reports
     * 
    **/
    select?: ReportsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReportsInclude | null
    /**
     * Filter, which Reports to fetch.
     * 
    **/
    where?: ReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     * 
    **/
    orderBy?: Enumerable<ReportsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     * 
    **/
    cursor?: ReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReportsScalarFieldEnum>
  }


  /**
   * Reports create
   */
  export type ReportsCreateArgs = {
    /**
     * Select specific fields to fetch from the Reports
     * 
    **/
    select?: ReportsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReportsInclude | null
    /**
     * The data needed to create a Reports.
     * 
    **/
    data: XOR<ReportsCreateInput, ReportsUncheckedCreateInput>
  }


  /**
   * Reports createMany
   */
  export type ReportsCreateManyArgs = {
    /**
     * The data used to create many Reports.
     * 
    **/
    data: Enumerable<ReportsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Reports update
   */
  export type ReportsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Reports
     * 
    **/
    select?: ReportsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReportsInclude | null
    /**
     * The data needed to update a Reports.
     * 
    **/
    data: XOR<ReportsUpdateInput, ReportsUncheckedUpdateInput>
    /**
     * Choose, which Reports to update.
     * 
    **/
    where: ReportsWhereUniqueInput
  }


  /**
   * Reports updateMany
   */
  export type ReportsUpdateManyArgs = {
    /**
     * The data used to update Reports.
     * 
    **/
    data: XOR<ReportsUpdateManyMutationInput, ReportsUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     * 
    **/
    where?: ReportsWhereInput
  }


  /**
   * Reports upsert
   */
  export type ReportsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Reports
     * 
    **/
    select?: ReportsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReportsInclude | null
    /**
     * The filter to search for the Reports to update in case it exists.
     * 
    **/
    where: ReportsWhereUniqueInput
    /**
     * In case the Reports found by the `where` argument doesn't exist, create a new Reports with this data.
     * 
    **/
    create: XOR<ReportsCreateInput, ReportsUncheckedCreateInput>
    /**
     * In case the Reports was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ReportsUpdateInput, ReportsUncheckedUpdateInput>
  }


  /**
   * Reports delete
   */
  export type ReportsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Reports
     * 
    **/
    select?: ReportsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReportsInclude | null
    /**
     * Filter which Reports to delete.
     * 
    **/
    where: ReportsWhereUniqueInput
  }


  /**
   * Reports deleteMany
   */
  export type ReportsDeleteManyArgs = {
    /**
     * Filter which Reports to delete
     * 
    **/
    where?: ReportsWhereInput
  }


  /**
   * Reports: findUniqueOrThrow
   */
  export type ReportsFindUniqueOrThrowArgs = ReportsFindUniqueArgsBase
      

  /**
   * Reports: findFirstOrThrow
   */
  export type ReportsFindFirstOrThrowArgs = ReportsFindFirstArgsBase
      

  /**
   * Reports without action
   */
  export type ReportsArgs = {
    /**
     * Select specific fields to fetch from the Reports
     * 
    **/
    select?: ReportsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReportsInclude | null
  }



  /**
   * Model SequelizeMeta
   */


  export type AggregateSequelizeMeta = {
    _count: SequelizeMetaCountAggregateOutputType | null
    _min: SequelizeMetaMinAggregateOutputType | null
    _max: SequelizeMetaMaxAggregateOutputType | null
  }

  export type SequelizeMetaMinAggregateOutputType = {
    name: string | null
  }

  export type SequelizeMetaMaxAggregateOutputType = {
    name: string | null
  }

  export type SequelizeMetaCountAggregateOutputType = {
    name: number
    _all: number
  }


  export type SequelizeMetaMinAggregateInputType = {
    name?: true
  }

  export type SequelizeMetaMaxAggregateInputType = {
    name?: true
  }

  export type SequelizeMetaCountAggregateInputType = {
    name?: true
    _all?: true
  }

  export type SequelizeMetaAggregateArgs = {
    /**
     * Filter which SequelizeMeta to aggregate.
     * 
    **/
    where?: SequelizeMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SequelizeMetas to fetch.
     * 
    **/
    orderBy?: Enumerable<SequelizeMetaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SequelizeMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SequelizeMetas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SequelizeMetas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SequelizeMetas
    **/
    _count?: true | SequelizeMetaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SequelizeMetaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SequelizeMetaMaxAggregateInputType
  }

  export type GetSequelizeMetaAggregateType<T extends SequelizeMetaAggregateArgs> = {
        [P in keyof T & keyof AggregateSequelizeMeta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSequelizeMeta[P]>
      : GetScalarType<T[P], AggregateSequelizeMeta[P]>
  }




  export type SequelizeMetaGroupByArgs = {
    where?: SequelizeMetaWhereInput
    orderBy?: Enumerable<SequelizeMetaOrderByWithAggregationInput>
    by: Array<SequelizeMetaScalarFieldEnum>
    having?: SequelizeMetaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SequelizeMetaCountAggregateInputType | true
    _min?: SequelizeMetaMinAggregateInputType
    _max?: SequelizeMetaMaxAggregateInputType
  }


  export type SequelizeMetaGroupByOutputType = {
    name: string
    _count: SequelizeMetaCountAggregateOutputType | null
    _min: SequelizeMetaMinAggregateOutputType | null
    _max: SequelizeMetaMaxAggregateOutputType | null
  }

  type GetSequelizeMetaGroupByPayload<T extends SequelizeMetaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SequelizeMetaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SequelizeMetaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SequelizeMetaGroupByOutputType[P]>
            : GetScalarType<T[P], SequelizeMetaGroupByOutputType[P]>
        }
      >
    >


  export type SequelizeMetaSelect = {
    name?: boolean
  }

  export type SequelizeMetaGetPayload<
    S extends boolean | null | undefined | SequelizeMetaArgs,
    U = keyof S
      > = S extends true
        ? SequelizeMeta
    : S extends undefined
    ? never
    : S extends SequelizeMetaArgs | SequelizeMetaFindManyArgs
    ?'include' extends U
    ? SequelizeMeta 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof SequelizeMeta ? SequelizeMeta[P] : never
  } 
    : SequelizeMeta
  : SequelizeMeta


  type SequelizeMetaCountArgs = Merge<
    Omit<SequelizeMetaFindManyArgs, 'select' | 'include'> & {
      select?: SequelizeMetaCountAggregateInputType | true
    }
  >

  export interface SequelizeMetaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one SequelizeMeta that matches the filter.
     * @param {SequelizeMetaFindUniqueArgs} args - Arguments to find a SequelizeMeta
     * @example
     * // Get one SequelizeMeta
     * const sequelizeMeta = await prisma.sequelizeMeta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SequelizeMetaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SequelizeMetaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SequelizeMeta'> extends True ? CheckSelect<T, Prisma__SequelizeMetaClient<SequelizeMeta>, Prisma__SequelizeMetaClient<SequelizeMetaGetPayload<T>>> : CheckSelect<T, Prisma__SequelizeMetaClient<SequelizeMeta | null, null>, Prisma__SequelizeMetaClient<SequelizeMetaGetPayload<T> | null, null>>

    /**
     * Find the first SequelizeMeta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeMetaFindFirstArgs} args - Arguments to find a SequelizeMeta
     * @example
     * // Get one SequelizeMeta
     * const sequelizeMeta = await prisma.sequelizeMeta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SequelizeMetaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SequelizeMetaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SequelizeMeta'> extends True ? CheckSelect<T, Prisma__SequelizeMetaClient<SequelizeMeta>, Prisma__SequelizeMetaClient<SequelizeMetaGetPayload<T>>> : CheckSelect<T, Prisma__SequelizeMetaClient<SequelizeMeta | null, null>, Prisma__SequelizeMetaClient<SequelizeMetaGetPayload<T> | null, null>>

    /**
     * Find zero or more SequelizeMetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeMetaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SequelizeMetas
     * const sequelizeMetas = await prisma.sequelizeMeta.findMany()
     * 
     * // Get first 10 SequelizeMetas
     * const sequelizeMetas = await prisma.sequelizeMeta.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const sequelizeMetaWithNameOnly = await prisma.sequelizeMeta.findMany({ select: { name: true } })
     * 
    **/
    findMany<T extends SequelizeMetaFindManyArgs>(
      args?: SelectSubset<T, SequelizeMetaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SequelizeMeta>>, PrismaPromise<Array<SequelizeMetaGetPayload<T>>>>

    /**
     * Create a SequelizeMeta.
     * @param {SequelizeMetaCreateArgs} args - Arguments to create a SequelizeMeta.
     * @example
     * // Create one SequelizeMeta
     * const SequelizeMeta = await prisma.sequelizeMeta.create({
     *   data: {
     *     // ... data to create a SequelizeMeta
     *   }
     * })
     * 
    **/
    create<T extends SequelizeMetaCreateArgs>(
      args: SelectSubset<T, SequelizeMetaCreateArgs>
    ): CheckSelect<T, Prisma__SequelizeMetaClient<SequelizeMeta>, Prisma__SequelizeMetaClient<SequelizeMetaGetPayload<T>>>

    /**
     * Create many SequelizeMetas.
     *     @param {SequelizeMetaCreateManyArgs} args - Arguments to create many SequelizeMetas.
     *     @example
     *     // Create many SequelizeMetas
     *     const sequelizeMeta = await prisma.sequelizeMeta.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SequelizeMetaCreateManyArgs>(
      args?: SelectSubset<T, SequelizeMetaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SequelizeMeta.
     * @param {SequelizeMetaDeleteArgs} args - Arguments to delete one SequelizeMeta.
     * @example
     * // Delete one SequelizeMeta
     * const SequelizeMeta = await prisma.sequelizeMeta.delete({
     *   where: {
     *     // ... filter to delete one SequelizeMeta
     *   }
     * })
     * 
    **/
    delete<T extends SequelizeMetaDeleteArgs>(
      args: SelectSubset<T, SequelizeMetaDeleteArgs>
    ): CheckSelect<T, Prisma__SequelizeMetaClient<SequelizeMeta>, Prisma__SequelizeMetaClient<SequelizeMetaGetPayload<T>>>

    /**
     * Update one SequelizeMeta.
     * @param {SequelizeMetaUpdateArgs} args - Arguments to update one SequelizeMeta.
     * @example
     * // Update one SequelizeMeta
     * const sequelizeMeta = await prisma.sequelizeMeta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SequelizeMetaUpdateArgs>(
      args: SelectSubset<T, SequelizeMetaUpdateArgs>
    ): CheckSelect<T, Prisma__SequelizeMetaClient<SequelizeMeta>, Prisma__SequelizeMetaClient<SequelizeMetaGetPayload<T>>>

    /**
     * Delete zero or more SequelizeMetas.
     * @param {SequelizeMetaDeleteManyArgs} args - Arguments to filter SequelizeMetas to delete.
     * @example
     * // Delete a few SequelizeMetas
     * const { count } = await prisma.sequelizeMeta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SequelizeMetaDeleteManyArgs>(
      args?: SelectSubset<T, SequelizeMetaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SequelizeMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeMetaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SequelizeMetas
     * const sequelizeMeta = await prisma.sequelizeMeta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SequelizeMetaUpdateManyArgs>(
      args: SelectSubset<T, SequelizeMetaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SequelizeMeta.
     * @param {SequelizeMetaUpsertArgs} args - Arguments to update or create a SequelizeMeta.
     * @example
     * // Update or create a SequelizeMeta
     * const sequelizeMeta = await prisma.sequelizeMeta.upsert({
     *   create: {
     *     // ... data to create a SequelizeMeta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SequelizeMeta we want to update
     *   }
     * })
    **/
    upsert<T extends SequelizeMetaUpsertArgs>(
      args: SelectSubset<T, SequelizeMetaUpsertArgs>
    ): CheckSelect<T, Prisma__SequelizeMetaClient<SequelizeMeta>, Prisma__SequelizeMetaClient<SequelizeMetaGetPayload<T>>>

    /**
     * Find one SequelizeMeta that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SequelizeMetaFindUniqueOrThrowArgs} args - Arguments to find a SequelizeMeta
     * @example
     * // Get one SequelizeMeta
     * const sequelizeMeta = await prisma.sequelizeMeta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SequelizeMetaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SequelizeMetaFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SequelizeMetaClient<SequelizeMeta>, Prisma__SequelizeMetaClient<SequelizeMetaGetPayload<T>>>

    /**
     * Find the first SequelizeMeta that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeMetaFindFirstOrThrowArgs} args - Arguments to find a SequelizeMeta
     * @example
     * // Get one SequelizeMeta
     * const sequelizeMeta = await prisma.sequelizeMeta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SequelizeMetaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SequelizeMetaFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SequelizeMetaClient<SequelizeMeta>, Prisma__SequelizeMetaClient<SequelizeMetaGetPayload<T>>>

    /**
     * Count the number of SequelizeMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeMetaCountArgs} args - Arguments to filter SequelizeMetas to count.
     * @example
     * // Count the number of SequelizeMetas
     * const count = await prisma.sequelizeMeta.count({
     *   where: {
     *     // ... the filter for the SequelizeMetas we want to count
     *   }
     * })
    **/
    count<T extends SequelizeMetaCountArgs>(
      args?: Subset<T, SequelizeMetaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SequelizeMetaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SequelizeMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeMetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SequelizeMetaAggregateArgs>(args: Subset<T, SequelizeMetaAggregateArgs>): PrismaPromise<GetSequelizeMetaAggregateType<T>>

    /**
     * Group by SequelizeMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeMetaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SequelizeMetaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SequelizeMetaGroupByArgs['orderBy'] }
        : { orderBy?: SequelizeMetaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SequelizeMetaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSequelizeMetaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SequelizeMeta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SequelizeMetaClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SequelizeMeta base type for findUnique actions
   */
  export type SequelizeMetaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
     * 
    **/
    select?: SequelizeMetaSelect | null
    /**
     * Filter, which SequelizeMeta to fetch.
     * 
    **/
    where: SequelizeMetaWhereUniqueInput
  }

  /**
   * SequelizeMeta: findUnique
   */
  export interface SequelizeMetaFindUniqueArgs extends SequelizeMetaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SequelizeMeta base type for findFirst actions
   */
  export type SequelizeMetaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
     * 
    **/
    select?: SequelizeMetaSelect | null
    /**
     * Filter, which SequelizeMeta to fetch.
     * 
    **/
    where?: SequelizeMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SequelizeMetas to fetch.
     * 
    **/
    orderBy?: Enumerable<SequelizeMetaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SequelizeMetas.
     * 
    **/
    cursor?: SequelizeMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SequelizeMetas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SequelizeMetas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SequelizeMetas.
     * 
    **/
    distinct?: Enumerable<SequelizeMetaScalarFieldEnum>
  }

  /**
   * SequelizeMeta: findFirst
   */
  export interface SequelizeMetaFindFirstArgs extends SequelizeMetaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SequelizeMeta findMany
   */
  export type SequelizeMetaFindManyArgs = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
     * 
    **/
    select?: SequelizeMetaSelect | null
    /**
     * Filter, which SequelizeMetas to fetch.
     * 
    **/
    where?: SequelizeMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SequelizeMetas to fetch.
     * 
    **/
    orderBy?: Enumerable<SequelizeMetaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SequelizeMetas.
     * 
    **/
    cursor?: SequelizeMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SequelizeMetas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SequelizeMetas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SequelizeMetaScalarFieldEnum>
  }


  /**
   * SequelizeMeta create
   */
  export type SequelizeMetaCreateArgs = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
     * 
    **/
    select?: SequelizeMetaSelect | null
    /**
     * The data needed to create a SequelizeMeta.
     * 
    **/
    data: XOR<SequelizeMetaCreateInput, SequelizeMetaUncheckedCreateInput>
  }


  /**
   * SequelizeMeta createMany
   */
  export type SequelizeMetaCreateManyArgs = {
    /**
     * The data used to create many SequelizeMetas.
     * 
    **/
    data: Enumerable<SequelizeMetaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SequelizeMeta update
   */
  export type SequelizeMetaUpdateArgs = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
     * 
    **/
    select?: SequelizeMetaSelect | null
    /**
     * The data needed to update a SequelizeMeta.
     * 
    **/
    data: XOR<SequelizeMetaUpdateInput, SequelizeMetaUncheckedUpdateInput>
    /**
     * Choose, which SequelizeMeta to update.
     * 
    **/
    where: SequelizeMetaWhereUniqueInput
  }


  /**
   * SequelizeMeta updateMany
   */
  export type SequelizeMetaUpdateManyArgs = {
    /**
     * The data used to update SequelizeMetas.
     * 
    **/
    data: XOR<SequelizeMetaUpdateManyMutationInput, SequelizeMetaUncheckedUpdateManyInput>
    /**
     * Filter which SequelizeMetas to update
     * 
    **/
    where?: SequelizeMetaWhereInput
  }


  /**
   * SequelizeMeta upsert
   */
  export type SequelizeMetaUpsertArgs = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
     * 
    **/
    select?: SequelizeMetaSelect | null
    /**
     * The filter to search for the SequelizeMeta to update in case it exists.
     * 
    **/
    where: SequelizeMetaWhereUniqueInput
    /**
     * In case the SequelizeMeta found by the `where` argument doesn't exist, create a new SequelizeMeta with this data.
     * 
    **/
    create: XOR<SequelizeMetaCreateInput, SequelizeMetaUncheckedCreateInput>
    /**
     * In case the SequelizeMeta was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SequelizeMetaUpdateInput, SequelizeMetaUncheckedUpdateInput>
  }


  /**
   * SequelizeMeta delete
   */
  export type SequelizeMetaDeleteArgs = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
     * 
    **/
    select?: SequelizeMetaSelect | null
    /**
     * Filter which SequelizeMeta to delete.
     * 
    **/
    where: SequelizeMetaWhereUniqueInput
  }


  /**
   * SequelizeMeta deleteMany
   */
  export type SequelizeMetaDeleteManyArgs = {
    /**
     * Filter which SequelizeMetas to delete
     * 
    **/
    where?: SequelizeMetaWhereInput
  }


  /**
   * SequelizeMeta: findUniqueOrThrow
   */
  export type SequelizeMetaFindUniqueOrThrowArgs = SequelizeMetaFindUniqueArgsBase
      

  /**
   * SequelizeMeta: findFirstOrThrow
   */
  export type SequelizeMetaFindFirstOrThrowArgs = SequelizeMetaFindFirstArgsBase
      

  /**
   * SequelizeMeta without action
   */
  export type SequelizeMetaArgs = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
     * 
    **/
    select?: SequelizeMetaSelect | null
  }



  /**
   * Model Services
   */


  export type AggregateServices = {
    _count: ServicesCountAggregateOutputType | null
    _min: ServicesMinAggregateOutputType | null
    _max: ServicesMaxAggregateOutputType | null
  }

  export type ServicesMinAggregateOutputType = {
    key: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServicesMaxAggregateOutputType = {
    key: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServicesCountAggregateOutputType = {
    key: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServicesMinAggregateInputType = {
    key?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServicesMaxAggregateInputType = {
    key?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServicesCountAggregateInputType = {
    key?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServicesAggregateArgs = {
    /**
     * Filter which Services to aggregate.
     * 
    **/
    where?: ServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     * 
    **/
    orderBy?: Enumerable<ServicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicesMaxAggregateInputType
  }

  export type GetServicesAggregateType<T extends ServicesAggregateArgs> = {
        [P in keyof T & keyof AggregateServices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServices[P]>
      : GetScalarType<T[P], AggregateServices[P]>
  }




  export type ServicesGroupByArgs = {
    where?: ServicesWhereInput
    orderBy?: Enumerable<ServicesOrderByWithAggregationInput>
    by: Array<ServicesScalarFieldEnum>
    having?: ServicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicesCountAggregateInputType | true
    _min?: ServicesMinAggregateInputType
    _max?: ServicesMaxAggregateInputType
  }


  export type ServicesGroupByOutputType = {
    key: string
    description: string | null
    isActive: boolean | null
    createdAt: Date
    updatedAt: Date
    _count: ServicesCountAggregateOutputType | null
    _min: ServicesMinAggregateOutputType | null
    _max: ServicesMaxAggregateOutputType | null
  }

  type GetServicesGroupByPayload<T extends ServicesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ServicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicesGroupByOutputType[P]>
            : GetScalarType<T[P], ServicesGroupByOutputType[P]>
        }
      >
    >


  export type ServicesSelect = {
    key?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Accounts?: boolean | AccountsFindManyArgs
    _count?: boolean | ServicesCountOutputTypeArgs
  }

  export type ServicesInclude = {
    Accounts?: boolean | AccountsFindManyArgs
    _count?: boolean | ServicesCountOutputTypeArgs
  }

  export type ServicesGetPayload<
    S extends boolean | null | undefined | ServicesArgs,
    U = keyof S
      > = S extends true
        ? Services
    : S extends undefined
    ? never
    : S extends ServicesArgs | ServicesFindManyArgs
    ?'include' extends U
    ? Services  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Accounts' ? Array < AccountsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? ServicesCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Accounts' ? Array < AccountsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? ServicesCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Services ? Services[P] : never
  } 
    : Services
  : Services


  type ServicesCountArgs = Merge<
    Omit<ServicesFindManyArgs, 'select' | 'include'> & {
      select?: ServicesCountAggregateInputType | true
    }
  >

  export interface ServicesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Services that matches the filter.
     * @param {ServicesFindUniqueArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServicesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ServicesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Services'> extends True ? CheckSelect<T, Prisma__ServicesClient<Services>, Prisma__ServicesClient<ServicesGetPayload<T>>> : CheckSelect<T, Prisma__ServicesClient<Services | null, null>, Prisma__ServicesClient<ServicesGetPayload<T> | null, null>>

    /**
     * Find the first Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesFindFirstArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServicesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ServicesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Services'> extends True ? CheckSelect<T, Prisma__ServicesClient<Services>, Prisma__ServicesClient<ServicesGetPayload<T>>> : CheckSelect<T, Prisma__ServicesClient<Services | null, null>, Prisma__ServicesClient<ServicesGetPayload<T> | null, null>>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.services.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.services.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const servicesWithKeyOnly = await prisma.services.findMany({ select: { key: true } })
     * 
    **/
    findMany<T extends ServicesFindManyArgs>(
      args?: SelectSubset<T, ServicesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Services>>, PrismaPromise<Array<ServicesGetPayload<T>>>>

    /**
     * Create a Services.
     * @param {ServicesCreateArgs} args - Arguments to create a Services.
     * @example
     * // Create one Services
     * const Services = await prisma.services.create({
     *   data: {
     *     // ... data to create a Services
     *   }
     * })
     * 
    **/
    create<T extends ServicesCreateArgs>(
      args: SelectSubset<T, ServicesCreateArgs>
    ): CheckSelect<T, Prisma__ServicesClient<Services>, Prisma__ServicesClient<ServicesGetPayload<T>>>

    /**
     * Create many Services.
     *     @param {ServicesCreateManyArgs} args - Arguments to create many Services.
     *     @example
     *     // Create many Services
     *     const services = await prisma.services.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServicesCreateManyArgs>(
      args?: SelectSubset<T, ServicesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Services.
     * @param {ServicesDeleteArgs} args - Arguments to delete one Services.
     * @example
     * // Delete one Services
     * const Services = await prisma.services.delete({
     *   where: {
     *     // ... filter to delete one Services
     *   }
     * })
     * 
    **/
    delete<T extends ServicesDeleteArgs>(
      args: SelectSubset<T, ServicesDeleteArgs>
    ): CheckSelect<T, Prisma__ServicesClient<Services>, Prisma__ServicesClient<ServicesGetPayload<T>>>

    /**
     * Update one Services.
     * @param {ServicesUpdateArgs} args - Arguments to update one Services.
     * @example
     * // Update one Services
     * const services = await prisma.services.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServicesUpdateArgs>(
      args: SelectSubset<T, ServicesUpdateArgs>
    ): CheckSelect<T, Prisma__ServicesClient<Services>, Prisma__ServicesClient<ServicesGetPayload<T>>>

    /**
     * Delete zero or more Services.
     * @param {ServicesDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.services.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServicesDeleteManyArgs>(
      args?: SelectSubset<T, ServicesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const services = await prisma.services.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServicesUpdateManyArgs>(
      args: SelectSubset<T, ServicesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Services.
     * @param {ServicesUpsertArgs} args - Arguments to update or create a Services.
     * @example
     * // Update or create a Services
     * const services = await prisma.services.upsert({
     *   create: {
     *     // ... data to create a Services
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Services we want to update
     *   }
     * })
    **/
    upsert<T extends ServicesUpsertArgs>(
      args: SelectSubset<T, ServicesUpsertArgs>
    ): CheckSelect<T, Prisma__ServicesClient<Services>, Prisma__ServicesClient<ServicesGetPayload<T>>>

    /**
     * Find one Services that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ServicesFindUniqueOrThrowArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServicesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ServicesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ServicesClient<Services>, Prisma__ServicesClient<ServicesGetPayload<T>>>

    /**
     * Find the first Services that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesFindFirstOrThrowArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServicesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ServicesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ServicesClient<Services>, Prisma__ServicesClient<ServicesGetPayload<T>>>

    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.services.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServicesCountArgs>(
      args?: Subset<T, ServicesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicesAggregateArgs>(args: Subset<T, ServicesAggregateArgs>): PrismaPromise<GetServicesAggregateType<T>>

    /**
     * Group by Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicesGroupByArgs['orderBy'] }
        : { orderBy?: ServicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Services.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ServicesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Accounts<T extends AccountsFindManyArgs = {}>(args?: Subset<T, AccountsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Accounts>| Null>, PrismaPromise<Array<AccountsGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Services base type for findUnique actions
   */
  export type ServicesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Services
     * 
    **/
    select?: ServicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServicesInclude | null
    /**
     * Filter, which Services to fetch.
     * 
    **/
    where: ServicesWhereUniqueInput
  }

  /**
   * Services: findUnique
   */
  export interface ServicesFindUniqueArgs extends ServicesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Services base type for findFirst actions
   */
  export type ServicesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Services
     * 
    **/
    select?: ServicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServicesInclude | null
    /**
     * Filter, which Services to fetch.
     * 
    **/
    where?: ServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     * 
    **/
    orderBy?: Enumerable<ServicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     * 
    **/
    cursor?: ServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     * 
    **/
    distinct?: Enumerable<ServicesScalarFieldEnum>
  }

  /**
   * Services: findFirst
   */
  export interface ServicesFindFirstArgs extends ServicesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Services findMany
   */
  export type ServicesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Services
     * 
    **/
    select?: ServicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServicesInclude | null
    /**
     * Filter, which Services to fetch.
     * 
    **/
    where?: ServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     * 
    **/
    orderBy?: Enumerable<ServicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     * 
    **/
    cursor?: ServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ServicesScalarFieldEnum>
  }


  /**
   * Services create
   */
  export type ServicesCreateArgs = {
    /**
     * Select specific fields to fetch from the Services
     * 
    **/
    select?: ServicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServicesInclude | null
    /**
     * The data needed to create a Services.
     * 
    **/
    data: XOR<ServicesCreateInput, ServicesUncheckedCreateInput>
  }


  /**
   * Services createMany
   */
  export type ServicesCreateManyArgs = {
    /**
     * The data used to create many Services.
     * 
    **/
    data: Enumerable<ServicesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Services update
   */
  export type ServicesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Services
     * 
    **/
    select?: ServicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServicesInclude | null
    /**
     * The data needed to update a Services.
     * 
    **/
    data: XOR<ServicesUpdateInput, ServicesUncheckedUpdateInput>
    /**
     * Choose, which Services to update.
     * 
    **/
    where: ServicesWhereUniqueInput
  }


  /**
   * Services updateMany
   */
  export type ServicesUpdateManyArgs = {
    /**
     * The data used to update Services.
     * 
    **/
    data: XOR<ServicesUpdateManyMutationInput, ServicesUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     * 
    **/
    where?: ServicesWhereInput
  }


  /**
   * Services upsert
   */
  export type ServicesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Services
     * 
    **/
    select?: ServicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServicesInclude | null
    /**
     * The filter to search for the Services to update in case it exists.
     * 
    **/
    where: ServicesWhereUniqueInput
    /**
     * In case the Services found by the `where` argument doesn't exist, create a new Services with this data.
     * 
    **/
    create: XOR<ServicesCreateInput, ServicesUncheckedCreateInput>
    /**
     * In case the Services was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ServicesUpdateInput, ServicesUncheckedUpdateInput>
  }


  /**
   * Services delete
   */
  export type ServicesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Services
     * 
    **/
    select?: ServicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServicesInclude | null
    /**
     * Filter which Services to delete.
     * 
    **/
    where: ServicesWhereUniqueInput
  }


  /**
   * Services deleteMany
   */
  export type ServicesDeleteManyArgs = {
    /**
     * Filter which Services to delete
     * 
    **/
    where?: ServicesWhereInput
  }


  /**
   * Services: findUniqueOrThrow
   */
  export type ServicesFindUniqueOrThrowArgs = ServicesFindUniqueArgsBase
      

  /**
   * Services: findFirstOrThrow
   */
  export type ServicesFindFirstOrThrowArgs = ServicesFindFirstArgsBase
      

  /**
   * Services without action
   */
  export type ServicesArgs = {
    /**
     * Select specific fields to fetch from the Services
     * 
    **/
    select?: ServicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServicesInclude | null
  }



  /**
   * Model Statistics
   */


  export type AggregateStatistics = {
    _count: StatisticsCountAggregateOutputType | null
    _avg: StatisticsAvgAggregateOutputType | null
    _sum: StatisticsSumAggregateOutputType | null
    _min: StatisticsMinAggregateOutputType | null
    _max: StatisticsMaxAggregateOutputType | null
  }

  export type StatisticsAvgAggregateOutputType = {
    id: number | null
    AgentId: number | null
    TeamId: number | null
    TaskId: number | null
    dailyWorkload: Decimal | null
    completedByOwner: Decimal | null
    completedBySelf: Decimal | null
  }

  export type StatisticsSumAggregateOutputType = {
    id: number | null
    AgentId: number | null
    TeamId: number | null
    TaskId: number | null
    dailyWorkload: Decimal | null
    completedByOwner: Decimal | null
    completedBySelf: Decimal | null
  }

  export type StatisticsMinAggregateOutputType = {
    id: number | null
    AgentId: number | null
    TeamId: number | null
    TaskId: number | null
    dailyWorkload: Decimal | null
    completedByOwner: Decimal | null
    completedBySelf: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StatisticsMaxAggregateOutputType = {
    id: number | null
    AgentId: number | null
    TeamId: number | null
    TaskId: number | null
    dailyWorkload: Decimal | null
    completedByOwner: Decimal | null
    completedBySelf: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StatisticsCountAggregateOutputType = {
    id: number
    AgentId: number
    TeamId: number
    TaskId: number
    dailyWorkload: number
    completedByOwner: number
    completedBySelf: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StatisticsAvgAggregateInputType = {
    id?: true
    AgentId?: true
    TeamId?: true
    TaskId?: true
    dailyWorkload?: true
    completedByOwner?: true
    completedBySelf?: true
  }

  export type StatisticsSumAggregateInputType = {
    id?: true
    AgentId?: true
    TeamId?: true
    TaskId?: true
    dailyWorkload?: true
    completedByOwner?: true
    completedBySelf?: true
  }

  export type StatisticsMinAggregateInputType = {
    id?: true
    AgentId?: true
    TeamId?: true
    TaskId?: true
    dailyWorkload?: true
    completedByOwner?: true
    completedBySelf?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StatisticsMaxAggregateInputType = {
    id?: true
    AgentId?: true
    TeamId?: true
    TaskId?: true
    dailyWorkload?: true
    completedByOwner?: true
    completedBySelf?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StatisticsCountAggregateInputType = {
    id?: true
    AgentId?: true
    TeamId?: true
    TaskId?: true
    dailyWorkload?: true
    completedByOwner?: true
    completedBySelf?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StatisticsAggregateArgs = {
    /**
     * Filter which Statistics to aggregate.
     * 
    **/
    where?: StatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Statistics to fetch.
     * 
    **/
    orderBy?: Enumerable<StatisticsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Statistics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Statistics.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Statistics
    **/
    _count?: true | StatisticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StatisticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StatisticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatisticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatisticsMaxAggregateInputType
  }

  export type GetStatisticsAggregateType<T extends StatisticsAggregateArgs> = {
        [P in keyof T & keyof AggregateStatistics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatistics[P]>
      : GetScalarType<T[P], AggregateStatistics[P]>
  }




  export type StatisticsGroupByArgs = {
    where?: StatisticsWhereInput
    orderBy?: Enumerable<StatisticsOrderByWithAggregationInput>
    by: Array<StatisticsScalarFieldEnum>
    having?: StatisticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatisticsCountAggregateInputType | true
    _avg?: StatisticsAvgAggregateInputType
    _sum?: StatisticsSumAggregateInputType
    _min?: StatisticsMinAggregateInputType
    _max?: StatisticsMaxAggregateInputType
  }


  export type StatisticsGroupByOutputType = {
    id: number
    AgentId: number | null
    TeamId: number | null
    TaskId: number | null
    dailyWorkload: Decimal | null
    completedByOwner: Decimal | null
    completedBySelf: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: StatisticsCountAggregateOutputType | null
    _avg: StatisticsAvgAggregateOutputType | null
    _sum: StatisticsSumAggregateOutputType | null
    _min: StatisticsMinAggregateOutputType | null
    _max: StatisticsMaxAggregateOutputType | null
  }

  type GetStatisticsGroupByPayload<T extends StatisticsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StatisticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatisticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatisticsGroupByOutputType[P]>
            : GetScalarType<T[P], StatisticsGroupByOutputType[P]>
        }
      >
    >


  export type StatisticsSelect = {
    id?: boolean
    AgentId?: boolean
    TeamId?: boolean
    TaskId?: boolean
    dailyWorkload?: boolean
    completedByOwner?: boolean
    completedBySelf?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Accounts?: boolean | AccountsArgs
    Tasks?: boolean | TasksArgs
    Teams?: boolean | TeamsArgs
  }

  export type StatisticsInclude = {
    Accounts?: boolean | AccountsArgs
    Tasks?: boolean | TasksArgs
    Teams?: boolean | TeamsArgs
  }

  export type StatisticsGetPayload<
    S extends boolean | null | undefined | StatisticsArgs,
    U = keyof S
      > = S extends true
        ? Statistics
    : S extends undefined
    ? never
    : S extends StatisticsArgs | StatisticsFindManyArgs
    ?'include' extends U
    ? Statistics  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'Tasks' ? TasksGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'Teams' ? TeamsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'Tasks' ? TasksGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'Teams' ? TeamsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof Statistics ? Statistics[P] : never
  } 
    : Statistics
  : Statistics


  type StatisticsCountArgs = Merge<
    Omit<StatisticsFindManyArgs, 'select' | 'include'> & {
      select?: StatisticsCountAggregateInputType | true
    }
  >

  export interface StatisticsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Statistics that matches the filter.
     * @param {StatisticsFindUniqueArgs} args - Arguments to find a Statistics
     * @example
     * // Get one Statistics
     * const statistics = await prisma.statistics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StatisticsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StatisticsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Statistics'> extends True ? CheckSelect<T, Prisma__StatisticsClient<Statistics>, Prisma__StatisticsClient<StatisticsGetPayload<T>>> : CheckSelect<T, Prisma__StatisticsClient<Statistics | null, null>, Prisma__StatisticsClient<StatisticsGetPayload<T> | null, null>>

    /**
     * Find the first Statistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatisticsFindFirstArgs} args - Arguments to find a Statistics
     * @example
     * // Get one Statistics
     * const statistics = await prisma.statistics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StatisticsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StatisticsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Statistics'> extends True ? CheckSelect<T, Prisma__StatisticsClient<Statistics>, Prisma__StatisticsClient<StatisticsGetPayload<T>>> : CheckSelect<T, Prisma__StatisticsClient<Statistics | null, null>, Prisma__StatisticsClient<StatisticsGetPayload<T> | null, null>>

    /**
     * Find zero or more Statistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatisticsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Statistics
     * const statistics = await prisma.statistics.findMany()
     * 
     * // Get first 10 Statistics
     * const statistics = await prisma.statistics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statisticsWithIdOnly = await prisma.statistics.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StatisticsFindManyArgs>(
      args?: SelectSubset<T, StatisticsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Statistics>>, PrismaPromise<Array<StatisticsGetPayload<T>>>>

    /**
     * Create a Statistics.
     * @param {StatisticsCreateArgs} args - Arguments to create a Statistics.
     * @example
     * // Create one Statistics
     * const Statistics = await prisma.statistics.create({
     *   data: {
     *     // ... data to create a Statistics
     *   }
     * })
     * 
    **/
    create<T extends StatisticsCreateArgs>(
      args: SelectSubset<T, StatisticsCreateArgs>
    ): CheckSelect<T, Prisma__StatisticsClient<Statistics>, Prisma__StatisticsClient<StatisticsGetPayload<T>>>

    /**
     * Create many Statistics.
     *     @param {StatisticsCreateManyArgs} args - Arguments to create many Statistics.
     *     @example
     *     // Create many Statistics
     *     const statistics = await prisma.statistics.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StatisticsCreateManyArgs>(
      args?: SelectSubset<T, StatisticsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Statistics.
     * @param {StatisticsDeleteArgs} args - Arguments to delete one Statistics.
     * @example
     * // Delete one Statistics
     * const Statistics = await prisma.statistics.delete({
     *   where: {
     *     // ... filter to delete one Statistics
     *   }
     * })
     * 
    **/
    delete<T extends StatisticsDeleteArgs>(
      args: SelectSubset<T, StatisticsDeleteArgs>
    ): CheckSelect<T, Prisma__StatisticsClient<Statistics>, Prisma__StatisticsClient<StatisticsGetPayload<T>>>

    /**
     * Update one Statistics.
     * @param {StatisticsUpdateArgs} args - Arguments to update one Statistics.
     * @example
     * // Update one Statistics
     * const statistics = await prisma.statistics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StatisticsUpdateArgs>(
      args: SelectSubset<T, StatisticsUpdateArgs>
    ): CheckSelect<T, Prisma__StatisticsClient<Statistics>, Prisma__StatisticsClient<StatisticsGetPayload<T>>>

    /**
     * Delete zero or more Statistics.
     * @param {StatisticsDeleteManyArgs} args - Arguments to filter Statistics to delete.
     * @example
     * // Delete a few Statistics
     * const { count } = await prisma.statistics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StatisticsDeleteManyArgs>(
      args?: SelectSubset<T, StatisticsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Statistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatisticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Statistics
     * const statistics = await prisma.statistics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StatisticsUpdateManyArgs>(
      args: SelectSubset<T, StatisticsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Statistics.
     * @param {StatisticsUpsertArgs} args - Arguments to update or create a Statistics.
     * @example
     * // Update or create a Statistics
     * const statistics = await prisma.statistics.upsert({
     *   create: {
     *     // ... data to create a Statistics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Statistics we want to update
     *   }
     * })
    **/
    upsert<T extends StatisticsUpsertArgs>(
      args: SelectSubset<T, StatisticsUpsertArgs>
    ): CheckSelect<T, Prisma__StatisticsClient<Statistics>, Prisma__StatisticsClient<StatisticsGetPayload<T>>>

    /**
     * Find one Statistics that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {StatisticsFindUniqueOrThrowArgs} args - Arguments to find a Statistics
     * @example
     * // Get one Statistics
     * const statistics = await prisma.statistics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StatisticsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, StatisticsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__StatisticsClient<Statistics>, Prisma__StatisticsClient<StatisticsGetPayload<T>>>

    /**
     * Find the first Statistics that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatisticsFindFirstOrThrowArgs} args - Arguments to find a Statistics
     * @example
     * // Get one Statistics
     * const statistics = await prisma.statistics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StatisticsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StatisticsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__StatisticsClient<Statistics>, Prisma__StatisticsClient<StatisticsGetPayload<T>>>

    /**
     * Count the number of Statistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatisticsCountArgs} args - Arguments to filter Statistics to count.
     * @example
     * // Count the number of Statistics
     * const count = await prisma.statistics.count({
     *   where: {
     *     // ... the filter for the Statistics we want to count
     *   }
     * })
    **/
    count<T extends StatisticsCountArgs>(
      args?: Subset<T, StatisticsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatisticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Statistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatisticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatisticsAggregateArgs>(args: Subset<T, StatisticsAggregateArgs>): PrismaPromise<GetStatisticsAggregateType<T>>

    /**
     * Group by Statistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatisticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatisticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatisticsGroupByArgs['orderBy'] }
        : { orderBy?: StatisticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatisticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatisticsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Statistics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StatisticsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Accounts<T extends AccountsArgs = {}>(args?: Subset<T, AccountsArgs>): CheckSelect<T, Prisma__AccountsClient<Accounts | Null>, Prisma__AccountsClient<AccountsGetPayload<T> | Null>>;

    Tasks<T extends TasksArgs = {}>(args?: Subset<T, TasksArgs>): CheckSelect<T, Prisma__TasksClient<Tasks | Null>, Prisma__TasksClient<TasksGetPayload<T> | Null>>;

    Teams<T extends TeamsArgs = {}>(args?: Subset<T, TeamsArgs>): CheckSelect<T, Prisma__TeamsClient<Teams | Null>, Prisma__TeamsClient<TeamsGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Statistics base type for findUnique actions
   */
  export type StatisticsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Statistics
     * 
    **/
    select?: StatisticsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatisticsInclude | null
    /**
     * Filter, which Statistics to fetch.
     * 
    **/
    where: StatisticsWhereUniqueInput
  }

  /**
   * Statistics: findUnique
   */
  export interface StatisticsFindUniqueArgs extends StatisticsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Statistics base type for findFirst actions
   */
  export type StatisticsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Statistics
     * 
    **/
    select?: StatisticsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatisticsInclude | null
    /**
     * Filter, which Statistics to fetch.
     * 
    **/
    where?: StatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Statistics to fetch.
     * 
    **/
    orderBy?: Enumerable<StatisticsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Statistics.
     * 
    **/
    cursor?: StatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Statistics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Statistics.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Statistics.
     * 
    **/
    distinct?: Enumerable<StatisticsScalarFieldEnum>
  }

  /**
   * Statistics: findFirst
   */
  export interface StatisticsFindFirstArgs extends StatisticsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Statistics findMany
   */
  export type StatisticsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Statistics
     * 
    **/
    select?: StatisticsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatisticsInclude | null
    /**
     * Filter, which Statistics to fetch.
     * 
    **/
    where?: StatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Statistics to fetch.
     * 
    **/
    orderBy?: Enumerable<StatisticsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Statistics.
     * 
    **/
    cursor?: StatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Statistics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Statistics.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StatisticsScalarFieldEnum>
  }


  /**
   * Statistics create
   */
  export type StatisticsCreateArgs = {
    /**
     * Select specific fields to fetch from the Statistics
     * 
    **/
    select?: StatisticsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatisticsInclude | null
    /**
     * The data needed to create a Statistics.
     * 
    **/
    data: XOR<StatisticsCreateInput, StatisticsUncheckedCreateInput>
  }


  /**
   * Statistics createMany
   */
  export type StatisticsCreateManyArgs = {
    /**
     * The data used to create many Statistics.
     * 
    **/
    data: Enumerable<StatisticsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Statistics update
   */
  export type StatisticsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Statistics
     * 
    **/
    select?: StatisticsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatisticsInclude | null
    /**
     * The data needed to update a Statistics.
     * 
    **/
    data: XOR<StatisticsUpdateInput, StatisticsUncheckedUpdateInput>
    /**
     * Choose, which Statistics to update.
     * 
    **/
    where: StatisticsWhereUniqueInput
  }


  /**
   * Statistics updateMany
   */
  export type StatisticsUpdateManyArgs = {
    /**
     * The data used to update Statistics.
     * 
    **/
    data: XOR<StatisticsUpdateManyMutationInput, StatisticsUncheckedUpdateManyInput>
    /**
     * Filter which Statistics to update
     * 
    **/
    where?: StatisticsWhereInput
  }


  /**
   * Statistics upsert
   */
  export type StatisticsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Statistics
     * 
    **/
    select?: StatisticsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatisticsInclude | null
    /**
     * The filter to search for the Statistics to update in case it exists.
     * 
    **/
    where: StatisticsWhereUniqueInput
    /**
     * In case the Statistics found by the `where` argument doesn't exist, create a new Statistics with this data.
     * 
    **/
    create: XOR<StatisticsCreateInput, StatisticsUncheckedCreateInput>
    /**
     * In case the Statistics was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StatisticsUpdateInput, StatisticsUncheckedUpdateInput>
  }


  /**
   * Statistics delete
   */
  export type StatisticsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Statistics
     * 
    **/
    select?: StatisticsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatisticsInclude | null
    /**
     * Filter which Statistics to delete.
     * 
    **/
    where: StatisticsWhereUniqueInput
  }


  /**
   * Statistics deleteMany
   */
  export type StatisticsDeleteManyArgs = {
    /**
     * Filter which Statistics to delete
     * 
    **/
    where?: StatisticsWhereInput
  }


  /**
   * Statistics: findUniqueOrThrow
   */
  export type StatisticsFindUniqueOrThrowArgs = StatisticsFindUniqueArgsBase
      

  /**
   * Statistics: findFirstOrThrow
   */
  export type StatisticsFindFirstOrThrowArgs = StatisticsFindFirstArgsBase
      

  /**
   * Statistics without action
   */
  export type StatisticsArgs = {
    /**
     * Select specific fields to fetch from the Statistics
     * 
    **/
    select?: StatisticsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatisticsInclude | null
  }



  /**
   * Model Subscribes
   */


  export type AggregateSubscribes = {
    _count: SubscribesCountAggregateOutputType | null
    _avg: SubscribesAvgAggregateOutputType | null
    _sum: SubscribesSumAggregateOutputType | null
    _min: SubscribesMinAggregateOutputType | null
    _max: SubscribesMaxAggregateOutputType | null
  }

  export type SubscribesAvgAggregateOutputType = {
    id: number | null
    AccountId: number | null
  }

  export type SubscribesSumAggregateOutputType = {
    id: number | null
    AccountId: number | null
  }

  export type SubscribesMinAggregateOutputType = {
    id: number | null
    AccountId: number | null
    fcmToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscribesMaxAggregateOutputType = {
    id: number | null
    AccountId: number | null
    fcmToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscribesCountAggregateOutputType = {
    id: number
    AccountId: number
    fcmToken: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscribesAvgAggregateInputType = {
    id?: true
    AccountId?: true
  }

  export type SubscribesSumAggregateInputType = {
    id?: true
    AccountId?: true
  }

  export type SubscribesMinAggregateInputType = {
    id?: true
    AccountId?: true
    fcmToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscribesMaxAggregateInputType = {
    id?: true
    AccountId?: true
    fcmToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscribesCountAggregateInputType = {
    id?: true
    AccountId?: true
    fcmToken?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscribesAggregateArgs = {
    /**
     * Filter which Subscribes to aggregate.
     * 
    **/
    where?: SubscribesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscribes to fetch.
     * 
    **/
    orderBy?: Enumerable<SubscribesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SubscribesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscribes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscribes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscribes
    **/
    _count?: true | SubscribesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscribesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscribesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscribesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscribesMaxAggregateInputType
  }

  export type GetSubscribesAggregateType<T extends SubscribesAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscribes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscribes[P]>
      : GetScalarType<T[P], AggregateSubscribes[P]>
  }




  export type SubscribesGroupByArgs = {
    where?: SubscribesWhereInput
    orderBy?: Enumerable<SubscribesOrderByWithAggregationInput>
    by: Array<SubscribesScalarFieldEnum>
    having?: SubscribesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscribesCountAggregateInputType | true
    _avg?: SubscribesAvgAggregateInputType
    _sum?: SubscribesSumAggregateInputType
    _min?: SubscribesMinAggregateInputType
    _max?: SubscribesMaxAggregateInputType
  }


  export type SubscribesGroupByOutputType = {
    id: number
    AccountId: number
    fcmToken: string
    createdAt: Date
    updatedAt: Date
    _count: SubscribesCountAggregateOutputType | null
    _avg: SubscribesAvgAggregateOutputType | null
    _sum: SubscribesSumAggregateOutputType | null
    _min: SubscribesMinAggregateOutputType | null
    _max: SubscribesMaxAggregateOutputType | null
  }

  type GetSubscribesGroupByPayload<T extends SubscribesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SubscribesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscribesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscribesGroupByOutputType[P]>
            : GetScalarType<T[P], SubscribesGroupByOutputType[P]>
        }
      >
    >


  export type SubscribesSelect = {
    id?: boolean
    AccountId?: boolean
    fcmToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Accounts?: boolean | AccountsArgs
  }

  export type SubscribesInclude = {
    Accounts?: boolean | AccountsArgs
  }

  export type SubscribesGetPayload<
    S extends boolean | null | undefined | SubscribesArgs,
    U = keyof S
      > = S extends true
        ? Subscribes
    : S extends undefined
    ? never
    : S extends SubscribesArgs | SubscribesFindManyArgs
    ?'include' extends U
    ? Subscribes  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Subscribes ? Subscribes[P] : never
  } 
    : Subscribes
  : Subscribes


  type SubscribesCountArgs = Merge<
    Omit<SubscribesFindManyArgs, 'select' | 'include'> & {
      select?: SubscribesCountAggregateInputType | true
    }
  >

  export interface SubscribesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Subscribes that matches the filter.
     * @param {SubscribesFindUniqueArgs} args - Arguments to find a Subscribes
     * @example
     * // Get one Subscribes
     * const subscribes = await prisma.subscribes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubscribesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubscribesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Subscribes'> extends True ? CheckSelect<T, Prisma__SubscribesClient<Subscribes>, Prisma__SubscribesClient<SubscribesGetPayload<T>>> : CheckSelect<T, Prisma__SubscribesClient<Subscribes | null, null>, Prisma__SubscribesClient<SubscribesGetPayload<T> | null, null>>

    /**
     * Find the first Subscribes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscribesFindFirstArgs} args - Arguments to find a Subscribes
     * @example
     * // Get one Subscribes
     * const subscribes = await prisma.subscribes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubscribesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubscribesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Subscribes'> extends True ? CheckSelect<T, Prisma__SubscribesClient<Subscribes>, Prisma__SubscribesClient<SubscribesGetPayload<T>>> : CheckSelect<T, Prisma__SubscribesClient<Subscribes | null, null>, Prisma__SubscribesClient<SubscribesGetPayload<T> | null, null>>

    /**
     * Find zero or more Subscribes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscribesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscribes
     * const subscribes = await prisma.subscribes.findMany()
     * 
     * // Get first 10 Subscribes
     * const subscribes = await prisma.subscribes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscribesWithIdOnly = await prisma.subscribes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubscribesFindManyArgs>(
      args?: SelectSubset<T, SubscribesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Subscribes>>, PrismaPromise<Array<SubscribesGetPayload<T>>>>

    /**
     * Create a Subscribes.
     * @param {SubscribesCreateArgs} args - Arguments to create a Subscribes.
     * @example
     * // Create one Subscribes
     * const Subscribes = await prisma.subscribes.create({
     *   data: {
     *     // ... data to create a Subscribes
     *   }
     * })
     * 
    **/
    create<T extends SubscribesCreateArgs>(
      args: SelectSubset<T, SubscribesCreateArgs>
    ): CheckSelect<T, Prisma__SubscribesClient<Subscribes>, Prisma__SubscribesClient<SubscribesGetPayload<T>>>

    /**
     * Create many Subscribes.
     *     @param {SubscribesCreateManyArgs} args - Arguments to create many Subscribes.
     *     @example
     *     // Create many Subscribes
     *     const subscribes = await prisma.subscribes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubscribesCreateManyArgs>(
      args?: SelectSubset<T, SubscribesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Subscribes.
     * @param {SubscribesDeleteArgs} args - Arguments to delete one Subscribes.
     * @example
     * // Delete one Subscribes
     * const Subscribes = await prisma.subscribes.delete({
     *   where: {
     *     // ... filter to delete one Subscribes
     *   }
     * })
     * 
    **/
    delete<T extends SubscribesDeleteArgs>(
      args: SelectSubset<T, SubscribesDeleteArgs>
    ): CheckSelect<T, Prisma__SubscribesClient<Subscribes>, Prisma__SubscribesClient<SubscribesGetPayload<T>>>

    /**
     * Update one Subscribes.
     * @param {SubscribesUpdateArgs} args - Arguments to update one Subscribes.
     * @example
     * // Update one Subscribes
     * const subscribes = await prisma.subscribes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubscribesUpdateArgs>(
      args: SelectSubset<T, SubscribesUpdateArgs>
    ): CheckSelect<T, Prisma__SubscribesClient<Subscribes>, Prisma__SubscribesClient<SubscribesGetPayload<T>>>

    /**
     * Delete zero or more Subscribes.
     * @param {SubscribesDeleteManyArgs} args - Arguments to filter Subscribes to delete.
     * @example
     * // Delete a few Subscribes
     * const { count } = await prisma.subscribes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubscribesDeleteManyArgs>(
      args?: SelectSubset<T, SubscribesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscribes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscribesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscribes
     * const subscribes = await prisma.subscribes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubscribesUpdateManyArgs>(
      args: SelectSubset<T, SubscribesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscribes.
     * @param {SubscribesUpsertArgs} args - Arguments to update or create a Subscribes.
     * @example
     * // Update or create a Subscribes
     * const subscribes = await prisma.subscribes.upsert({
     *   create: {
     *     // ... data to create a Subscribes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscribes we want to update
     *   }
     * })
    **/
    upsert<T extends SubscribesUpsertArgs>(
      args: SelectSubset<T, SubscribesUpsertArgs>
    ): CheckSelect<T, Prisma__SubscribesClient<Subscribes>, Prisma__SubscribesClient<SubscribesGetPayload<T>>>

    /**
     * Find one Subscribes that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SubscribesFindUniqueOrThrowArgs} args - Arguments to find a Subscribes
     * @example
     * // Get one Subscribes
     * const subscribes = await prisma.subscribes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubscribesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SubscribesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SubscribesClient<Subscribes>, Prisma__SubscribesClient<SubscribesGetPayload<T>>>

    /**
     * Find the first Subscribes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscribesFindFirstOrThrowArgs} args - Arguments to find a Subscribes
     * @example
     * // Get one Subscribes
     * const subscribes = await prisma.subscribes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubscribesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SubscribesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SubscribesClient<Subscribes>, Prisma__SubscribesClient<SubscribesGetPayload<T>>>

    /**
     * Count the number of Subscribes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscribesCountArgs} args - Arguments to filter Subscribes to count.
     * @example
     * // Count the number of Subscribes
     * const count = await prisma.subscribes.count({
     *   where: {
     *     // ... the filter for the Subscribes we want to count
     *   }
     * })
    **/
    count<T extends SubscribesCountArgs>(
      args?: Subset<T, SubscribesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscribesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscribes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscribesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscribesAggregateArgs>(args: Subset<T, SubscribesAggregateArgs>): PrismaPromise<GetSubscribesAggregateType<T>>

    /**
     * Group by Subscribes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscribesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscribesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscribesGroupByArgs['orderBy'] }
        : { orderBy?: SubscribesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscribesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscribesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscribes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubscribesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Accounts<T extends AccountsArgs = {}>(args?: Subset<T, AccountsArgs>): CheckSelect<T, Prisma__AccountsClient<Accounts | Null>, Prisma__AccountsClient<AccountsGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Subscribes base type for findUnique actions
   */
  export type SubscribesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Subscribes
     * 
    **/
    select?: SubscribesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscribesInclude | null
    /**
     * Filter, which Subscribes to fetch.
     * 
    **/
    where: SubscribesWhereUniqueInput
  }

  /**
   * Subscribes: findUnique
   */
  export interface SubscribesFindUniqueArgs extends SubscribesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Subscribes base type for findFirst actions
   */
  export type SubscribesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Subscribes
     * 
    **/
    select?: SubscribesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscribesInclude | null
    /**
     * Filter, which Subscribes to fetch.
     * 
    **/
    where?: SubscribesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscribes to fetch.
     * 
    **/
    orderBy?: Enumerable<SubscribesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscribes.
     * 
    **/
    cursor?: SubscribesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscribes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscribes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscribes.
     * 
    **/
    distinct?: Enumerable<SubscribesScalarFieldEnum>
  }

  /**
   * Subscribes: findFirst
   */
  export interface SubscribesFindFirstArgs extends SubscribesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Subscribes findMany
   */
  export type SubscribesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Subscribes
     * 
    **/
    select?: SubscribesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscribesInclude | null
    /**
     * Filter, which Subscribes to fetch.
     * 
    **/
    where?: SubscribesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscribes to fetch.
     * 
    **/
    orderBy?: Enumerable<SubscribesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscribes.
     * 
    **/
    cursor?: SubscribesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscribes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscribes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SubscribesScalarFieldEnum>
  }


  /**
   * Subscribes create
   */
  export type SubscribesCreateArgs = {
    /**
     * Select specific fields to fetch from the Subscribes
     * 
    **/
    select?: SubscribesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscribesInclude | null
    /**
     * The data needed to create a Subscribes.
     * 
    **/
    data: XOR<SubscribesCreateInput, SubscribesUncheckedCreateInput>
  }


  /**
   * Subscribes createMany
   */
  export type SubscribesCreateManyArgs = {
    /**
     * The data used to create many Subscribes.
     * 
    **/
    data: Enumerable<SubscribesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Subscribes update
   */
  export type SubscribesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Subscribes
     * 
    **/
    select?: SubscribesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscribesInclude | null
    /**
     * The data needed to update a Subscribes.
     * 
    **/
    data: XOR<SubscribesUpdateInput, SubscribesUncheckedUpdateInput>
    /**
     * Choose, which Subscribes to update.
     * 
    **/
    where: SubscribesWhereUniqueInput
  }


  /**
   * Subscribes updateMany
   */
  export type SubscribesUpdateManyArgs = {
    /**
     * The data used to update Subscribes.
     * 
    **/
    data: XOR<SubscribesUpdateManyMutationInput, SubscribesUncheckedUpdateManyInput>
    /**
     * Filter which Subscribes to update
     * 
    **/
    where?: SubscribesWhereInput
  }


  /**
   * Subscribes upsert
   */
  export type SubscribesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Subscribes
     * 
    **/
    select?: SubscribesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscribesInclude | null
    /**
     * The filter to search for the Subscribes to update in case it exists.
     * 
    **/
    where: SubscribesWhereUniqueInput
    /**
     * In case the Subscribes found by the `where` argument doesn't exist, create a new Subscribes with this data.
     * 
    **/
    create: XOR<SubscribesCreateInput, SubscribesUncheckedCreateInput>
    /**
     * In case the Subscribes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SubscribesUpdateInput, SubscribesUncheckedUpdateInput>
  }


  /**
   * Subscribes delete
   */
  export type SubscribesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Subscribes
     * 
    **/
    select?: SubscribesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscribesInclude | null
    /**
     * Filter which Subscribes to delete.
     * 
    **/
    where: SubscribesWhereUniqueInput
  }


  /**
   * Subscribes deleteMany
   */
  export type SubscribesDeleteManyArgs = {
    /**
     * Filter which Subscribes to delete
     * 
    **/
    where?: SubscribesWhereInput
  }


  /**
   * Subscribes: findUniqueOrThrow
   */
  export type SubscribesFindUniqueOrThrowArgs = SubscribesFindUniqueArgsBase
      

  /**
   * Subscribes: findFirstOrThrow
   */
  export type SubscribesFindFirstOrThrowArgs = SubscribesFindFirstArgsBase
      

  /**
   * Subscribes without action
   */
  export type SubscribesArgs = {
    /**
     * Select specific fields to fetch from the Subscribes
     * 
    **/
    select?: SubscribesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscribesInclude | null
  }



  /**
   * Model TaskDetailResources
   */


  export type AggregateTaskDetailResources = {
    _count: TaskDetailResourcesCountAggregateOutputType | null
    _avg: TaskDetailResourcesAvgAggregateOutputType | null
    _sum: TaskDetailResourcesSumAggregateOutputType | null
    _min: TaskDetailResourcesMinAggregateOutputType | null
    _max: TaskDetailResourcesMaxAggregateOutputType | null
  }

  export type TaskDetailResourcesAvgAggregateOutputType = {
    id: number | null
    TaskDetailId: number | null
    AccountId: number | null
  }

  export type TaskDetailResourcesSumAggregateOutputType = {
    id: number | null
    TaskDetailId: number | null
    AccountId: number | null
  }

  export type TaskDetailResourcesMinAggregateOutputType = {
    id: number | null
    content: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
    TaskDetailId: number | null
    AccountId: number | null
    group: string | null
  }

  export type TaskDetailResourcesMaxAggregateOutputType = {
    id: number | null
    content: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
    TaskDetailId: number | null
    AccountId: number | null
    group: string | null
  }

  export type TaskDetailResourcesCountAggregateOutputType = {
    id: number
    content: number
    type: number
    createdAt: number
    updatedAt: number
    TaskDetailId: number
    AccountId: number
    group: number
    _all: number
  }


  export type TaskDetailResourcesAvgAggregateInputType = {
    id?: true
    TaskDetailId?: true
    AccountId?: true
  }

  export type TaskDetailResourcesSumAggregateInputType = {
    id?: true
    TaskDetailId?: true
    AccountId?: true
  }

  export type TaskDetailResourcesMinAggregateInputType = {
    id?: true
    content?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    TaskDetailId?: true
    AccountId?: true
    group?: true
  }

  export type TaskDetailResourcesMaxAggregateInputType = {
    id?: true
    content?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    TaskDetailId?: true
    AccountId?: true
    group?: true
  }

  export type TaskDetailResourcesCountAggregateInputType = {
    id?: true
    content?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    TaskDetailId?: true
    AccountId?: true
    group?: true
    _all?: true
  }

  export type TaskDetailResourcesAggregateArgs = {
    /**
     * Filter which TaskDetailResources to aggregate.
     * 
    **/
    where?: TaskDetailResourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDetailResources to fetch.
     * 
    **/
    orderBy?: Enumerable<TaskDetailResourcesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TaskDetailResourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDetailResources from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDetailResources.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskDetailResources
    **/
    _count?: true | TaskDetailResourcesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskDetailResourcesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskDetailResourcesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskDetailResourcesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskDetailResourcesMaxAggregateInputType
  }

  export type GetTaskDetailResourcesAggregateType<T extends TaskDetailResourcesAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskDetailResources]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskDetailResources[P]>
      : GetScalarType<T[P], AggregateTaskDetailResources[P]>
  }




  export type TaskDetailResourcesGroupByArgs = {
    where?: TaskDetailResourcesWhereInput
    orderBy?: Enumerable<TaskDetailResourcesOrderByWithAggregationInput>
    by: Array<TaskDetailResourcesScalarFieldEnum>
    having?: TaskDetailResourcesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskDetailResourcesCountAggregateInputType | true
    _avg?: TaskDetailResourcesAvgAggregateInputType
    _sum?: TaskDetailResourcesSumAggregateInputType
    _min?: TaskDetailResourcesMinAggregateInputType
    _max?: TaskDetailResourcesMaxAggregateInputType
  }


  export type TaskDetailResourcesGroupByOutputType = {
    id: number
    content: string | null
    type: string | null
    createdAt: Date
    updatedAt: Date
    TaskDetailId: number | null
    AccountId: number | null
    group: string | null
    _count: TaskDetailResourcesCountAggregateOutputType | null
    _avg: TaskDetailResourcesAvgAggregateOutputType | null
    _sum: TaskDetailResourcesSumAggregateOutputType | null
    _min: TaskDetailResourcesMinAggregateOutputType | null
    _max: TaskDetailResourcesMaxAggregateOutputType | null
  }

  type GetTaskDetailResourcesGroupByPayload<T extends TaskDetailResourcesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TaskDetailResourcesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskDetailResourcesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskDetailResourcesGroupByOutputType[P]>
            : GetScalarType<T[P], TaskDetailResourcesGroupByOutputType[P]>
        }
      >
    >


  export type TaskDetailResourcesSelect = {
    id?: boolean
    content?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    TaskDetailId?: boolean
    AccountId?: boolean
    group?: boolean
    Accounts?: boolean | AccountsArgs
    TaskDetails?: boolean | TaskDetailsArgs
  }

  export type TaskDetailResourcesInclude = {
    Accounts?: boolean | AccountsArgs
    TaskDetails?: boolean | TaskDetailsArgs
  }

  export type TaskDetailResourcesGetPayload<
    S extends boolean | null | undefined | TaskDetailResourcesArgs,
    U = keyof S
      > = S extends true
        ? TaskDetailResources
    : S extends undefined
    ? never
    : S extends TaskDetailResourcesArgs | TaskDetailResourcesFindManyArgs
    ?'include' extends U
    ? TaskDetailResources  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'TaskDetails' ? TaskDetailsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'TaskDetails' ? TaskDetailsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof TaskDetailResources ? TaskDetailResources[P] : never
  } 
    : TaskDetailResources
  : TaskDetailResources


  type TaskDetailResourcesCountArgs = Merge<
    Omit<TaskDetailResourcesFindManyArgs, 'select' | 'include'> & {
      select?: TaskDetailResourcesCountAggregateInputType | true
    }
  >

  export interface TaskDetailResourcesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one TaskDetailResources that matches the filter.
     * @param {TaskDetailResourcesFindUniqueArgs} args - Arguments to find a TaskDetailResources
     * @example
     * // Get one TaskDetailResources
     * const taskDetailResources = await prisma.taskDetailResources.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TaskDetailResourcesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TaskDetailResourcesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TaskDetailResources'> extends True ? CheckSelect<T, Prisma__TaskDetailResourcesClient<TaskDetailResources>, Prisma__TaskDetailResourcesClient<TaskDetailResourcesGetPayload<T>>> : CheckSelect<T, Prisma__TaskDetailResourcesClient<TaskDetailResources | null, null>, Prisma__TaskDetailResourcesClient<TaskDetailResourcesGetPayload<T> | null, null>>

    /**
     * Find the first TaskDetailResources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailResourcesFindFirstArgs} args - Arguments to find a TaskDetailResources
     * @example
     * // Get one TaskDetailResources
     * const taskDetailResources = await prisma.taskDetailResources.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TaskDetailResourcesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TaskDetailResourcesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TaskDetailResources'> extends True ? CheckSelect<T, Prisma__TaskDetailResourcesClient<TaskDetailResources>, Prisma__TaskDetailResourcesClient<TaskDetailResourcesGetPayload<T>>> : CheckSelect<T, Prisma__TaskDetailResourcesClient<TaskDetailResources | null, null>, Prisma__TaskDetailResourcesClient<TaskDetailResourcesGetPayload<T> | null, null>>

    /**
     * Find zero or more TaskDetailResources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailResourcesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskDetailResources
     * const taskDetailResources = await prisma.taskDetailResources.findMany()
     * 
     * // Get first 10 TaskDetailResources
     * const taskDetailResources = await prisma.taskDetailResources.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskDetailResourcesWithIdOnly = await prisma.taskDetailResources.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TaskDetailResourcesFindManyArgs>(
      args?: SelectSubset<T, TaskDetailResourcesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TaskDetailResources>>, PrismaPromise<Array<TaskDetailResourcesGetPayload<T>>>>

    /**
     * Create a TaskDetailResources.
     * @param {TaskDetailResourcesCreateArgs} args - Arguments to create a TaskDetailResources.
     * @example
     * // Create one TaskDetailResources
     * const TaskDetailResources = await prisma.taskDetailResources.create({
     *   data: {
     *     // ... data to create a TaskDetailResources
     *   }
     * })
     * 
    **/
    create<T extends TaskDetailResourcesCreateArgs>(
      args: SelectSubset<T, TaskDetailResourcesCreateArgs>
    ): CheckSelect<T, Prisma__TaskDetailResourcesClient<TaskDetailResources>, Prisma__TaskDetailResourcesClient<TaskDetailResourcesGetPayload<T>>>

    /**
     * Create many TaskDetailResources.
     *     @param {TaskDetailResourcesCreateManyArgs} args - Arguments to create many TaskDetailResources.
     *     @example
     *     // Create many TaskDetailResources
     *     const taskDetailResources = await prisma.taskDetailResources.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TaskDetailResourcesCreateManyArgs>(
      args?: SelectSubset<T, TaskDetailResourcesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TaskDetailResources.
     * @param {TaskDetailResourcesDeleteArgs} args - Arguments to delete one TaskDetailResources.
     * @example
     * // Delete one TaskDetailResources
     * const TaskDetailResources = await prisma.taskDetailResources.delete({
     *   where: {
     *     // ... filter to delete one TaskDetailResources
     *   }
     * })
     * 
    **/
    delete<T extends TaskDetailResourcesDeleteArgs>(
      args: SelectSubset<T, TaskDetailResourcesDeleteArgs>
    ): CheckSelect<T, Prisma__TaskDetailResourcesClient<TaskDetailResources>, Prisma__TaskDetailResourcesClient<TaskDetailResourcesGetPayload<T>>>

    /**
     * Update one TaskDetailResources.
     * @param {TaskDetailResourcesUpdateArgs} args - Arguments to update one TaskDetailResources.
     * @example
     * // Update one TaskDetailResources
     * const taskDetailResources = await prisma.taskDetailResources.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TaskDetailResourcesUpdateArgs>(
      args: SelectSubset<T, TaskDetailResourcesUpdateArgs>
    ): CheckSelect<T, Prisma__TaskDetailResourcesClient<TaskDetailResources>, Prisma__TaskDetailResourcesClient<TaskDetailResourcesGetPayload<T>>>

    /**
     * Delete zero or more TaskDetailResources.
     * @param {TaskDetailResourcesDeleteManyArgs} args - Arguments to filter TaskDetailResources to delete.
     * @example
     * // Delete a few TaskDetailResources
     * const { count } = await prisma.taskDetailResources.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TaskDetailResourcesDeleteManyArgs>(
      args?: SelectSubset<T, TaskDetailResourcesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskDetailResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailResourcesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskDetailResources
     * const taskDetailResources = await prisma.taskDetailResources.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TaskDetailResourcesUpdateManyArgs>(
      args: SelectSubset<T, TaskDetailResourcesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskDetailResources.
     * @param {TaskDetailResourcesUpsertArgs} args - Arguments to update or create a TaskDetailResources.
     * @example
     * // Update or create a TaskDetailResources
     * const taskDetailResources = await prisma.taskDetailResources.upsert({
     *   create: {
     *     // ... data to create a TaskDetailResources
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskDetailResources we want to update
     *   }
     * })
    **/
    upsert<T extends TaskDetailResourcesUpsertArgs>(
      args: SelectSubset<T, TaskDetailResourcesUpsertArgs>
    ): CheckSelect<T, Prisma__TaskDetailResourcesClient<TaskDetailResources>, Prisma__TaskDetailResourcesClient<TaskDetailResourcesGetPayload<T>>>

    /**
     * Find one TaskDetailResources that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {TaskDetailResourcesFindUniqueOrThrowArgs} args - Arguments to find a TaskDetailResources
     * @example
     * // Get one TaskDetailResources
     * const taskDetailResources = await prisma.taskDetailResources.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TaskDetailResourcesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TaskDetailResourcesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__TaskDetailResourcesClient<TaskDetailResources>, Prisma__TaskDetailResourcesClient<TaskDetailResourcesGetPayload<T>>>

    /**
     * Find the first TaskDetailResources that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailResourcesFindFirstOrThrowArgs} args - Arguments to find a TaskDetailResources
     * @example
     * // Get one TaskDetailResources
     * const taskDetailResources = await prisma.taskDetailResources.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TaskDetailResourcesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TaskDetailResourcesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__TaskDetailResourcesClient<TaskDetailResources>, Prisma__TaskDetailResourcesClient<TaskDetailResourcesGetPayload<T>>>

    /**
     * Count the number of TaskDetailResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailResourcesCountArgs} args - Arguments to filter TaskDetailResources to count.
     * @example
     * // Count the number of TaskDetailResources
     * const count = await prisma.taskDetailResources.count({
     *   where: {
     *     // ... the filter for the TaskDetailResources we want to count
     *   }
     * })
    **/
    count<T extends TaskDetailResourcesCountArgs>(
      args?: Subset<T, TaskDetailResourcesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskDetailResourcesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskDetailResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailResourcesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskDetailResourcesAggregateArgs>(args: Subset<T, TaskDetailResourcesAggregateArgs>): PrismaPromise<GetTaskDetailResourcesAggregateType<T>>

    /**
     * Group by TaskDetailResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailResourcesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskDetailResourcesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskDetailResourcesGroupByArgs['orderBy'] }
        : { orderBy?: TaskDetailResourcesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskDetailResourcesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskDetailResourcesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskDetailResources.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TaskDetailResourcesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Accounts<T extends AccountsArgs = {}>(args?: Subset<T, AccountsArgs>): CheckSelect<T, Prisma__AccountsClient<Accounts | Null>, Prisma__AccountsClient<AccountsGetPayload<T> | Null>>;

    TaskDetails<T extends TaskDetailsArgs = {}>(args?: Subset<T, TaskDetailsArgs>): CheckSelect<T, Prisma__TaskDetailsClient<TaskDetails | Null>, Prisma__TaskDetailsClient<TaskDetailsGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TaskDetailResources base type for findUnique actions
   */
  export type TaskDetailResourcesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TaskDetailResources
     * 
    **/
    select?: TaskDetailResourcesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskDetailResourcesInclude | null
    /**
     * Filter, which TaskDetailResources to fetch.
     * 
    **/
    where: TaskDetailResourcesWhereUniqueInput
  }

  /**
   * TaskDetailResources: findUnique
   */
  export interface TaskDetailResourcesFindUniqueArgs extends TaskDetailResourcesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TaskDetailResources base type for findFirst actions
   */
  export type TaskDetailResourcesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TaskDetailResources
     * 
    **/
    select?: TaskDetailResourcesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskDetailResourcesInclude | null
    /**
     * Filter, which TaskDetailResources to fetch.
     * 
    **/
    where?: TaskDetailResourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDetailResources to fetch.
     * 
    **/
    orderBy?: Enumerable<TaskDetailResourcesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskDetailResources.
     * 
    **/
    cursor?: TaskDetailResourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDetailResources from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDetailResources.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskDetailResources.
     * 
    **/
    distinct?: Enumerable<TaskDetailResourcesScalarFieldEnum>
  }

  /**
   * TaskDetailResources: findFirst
   */
  export interface TaskDetailResourcesFindFirstArgs extends TaskDetailResourcesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TaskDetailResources findMany
   */
  export type TaskDetailResourcesFindManyArgs = {
    /**
     * Select specific fields to fetch from the TaskDetailResources
     * 
    **/
    select?: TaskDetailResourcesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskDetailResourcesInclude | null
    /**
     * Filter, which TaskDetailResources to fetch.
     * 
    **/
    where?: TaskDetailResourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDetailResources to fetch.
     * 
    **/
    orderBy?: Enumerable<TaskDetailResourcesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskDetailResources.
     * 
    **/
    cursor?: TaskDetailResourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDetailResources from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDetailResources.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TaskDetailResourcesScalarFieldEnum>
  }


  /**
   * TaskDetailResources create
   */
  export type TaskDetailResourcesCreateArgs = {
    /**
     * Select specific fields to fetch from the TaskDetailResources
     * 
    **/
    select?: TaskDetailResourcesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskDetailResourcesInclude | null
    /**
     * The data needed to create a TaskDetailResources.
     * 
    **/
    data: XOR<TaskDetailResourcesCreateInput, TaskDetailResourcesUncheckedCreateInput>
  }


  /**
   * TaskDetailResources createMany
   */
  export type TaskDetailResourcesCreateManyArgs = {
    /**
     * The data used to create many TaskDetailResources.
     * 
    **/
    data: Enumerable<TaskDetailResourcesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TaskDetailResources update
   */
  export type TaskDetailResourcesUpdateArgs = {
    /**
     * Select specific fields to fetch from the TaskDetailResources
     * 
    **/
    select?: TaskDetailResourcesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskDetailResourcesInclude | null
    /**
     * The data needed to update a TaskDetailResources.
     * 
    **/
    data: XOR<TaskDetailResourcesUpdateInput, TaskDetailResourcesUncheckedUpdateInput>
    /**
     * Choose, which TaskDetailResources to update.
     * 
    **/
    where: TaskDetailResourcesWhereUniqueInput
  }


  /**
   * TaskDetailResources updateMany
   */
  export type TaskDetailResourcesUpdateManyArgs = {
    /**
     * The data used to update TaskDetailResources.
     * 
    **/
    data: XOR<TaskDetailResourcesUpdateManyMutationInput, TaskDetailResourcesUncheckedUpdateManyInput>
    /**
     * Filter which TaskDetailResources to update
     * 
    **/
    where?: TaskDetailResourcesWhereInput
  }


  /**
   * TaskDetailResources upsert
   */
  export type TaskDetailResourcesUpsertArgs = {
    /**
     * Select specific fields to fetch from the TaskDetailResources
     * 
    **/
    select?: TaskDetailResourcesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskDetailResourcesInclude | null
    /**
     * The filter to search for the TaskDetailResources to update in case it exists.
     * 
    **/
    where: TaskDetailResourcesWhereUniqueInput
    /**
     * In case the TaskDetailResources found by the `where` argument doesn't exist, create a new TaskDetailResources with this data.
     * 
    **/
    create: XOR<TaskDetailResourcesCreateInput, TaskDetailResourcesUncheckedCreateInput>
    /**
     * In case the TaskDetailResources was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TaskDetailResourcesUpdateInput, TaskDetailResourcesUncheckedUpdateInput>
  }


  /**
   * TaskDetailResources delete
   */
  export type TaskDetailResourcesDeleteArgs = {
    /**
     * Select specific fields to fetch from the TaskDetailResources
     * 
    **/
    select?: TaskDetailResourcesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskDetailResourcesInclude | null
    /**
     * Filter which TaskDetailResources to delete.
     * 
    **/
    where: TaskDetailResourcesWhereUniqueInput
  }


  /**
   * TaskDetailResources deleteMany
   */
  export type TaskDetailResourcesDeleteManyArgs = {
    /**
     * Filter which TaskDetailResources to delete
     * 
    **/
    where?: TaskDetailResourcesWhereInput
  }


  /**
   * TaskDetailResources: findUniqueOrThrow
   */
  export type TaskDetailResourcesFindUniqueOrThrowArgs = TaskDetailResourcesFindUniqueArgsBase
      

  /**
   * TaskDetailResources: findFirstOrThrow
   */
  export type TaskDetailResourcesFindFirstOrThrowArgs = TaskDetailResourcesFindFirstArgsBase
      

  /**
   * TaskDetailResources without action
   */
  export type TaskDetailResourcesArgs = {
    /**
     * Select specific fields to fetch from the TaskDetailResources
     * 
    **/
    select?: TaskDetailResourcesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskDetailResourcesInclude | null
  }



  /**
   * Model TaskDetails
   */


  export type AggregateTaskDetails = {
    _count: TaskDetailsCountAggregateOutputType | null
    _avg: TaskDetailsAvgAggregateOutputType | null
    _sum: TaskDetailsSumAggregateOutputType | null
    _min: TaskDetailsMinAggregateOutputType | null
    _max: TaskDetailsMaxAggregateOutputType | null
  }

  export type TaskDetailsAvgAggregateOutputType = {
    id: number | null
    AccountId: number | null
    TaskId: number | null
    assignedDays: number | null
    TeamId: number | null
    area: Decimal | null
  }

  export type TaskDetailsSumAggregateOutputType = {
    id: number | null
    AccountId: number | null
    TaskId: number | null
    assignedDays: number | null
    TeamId: number | null
    area: Decimal | null
  }

  export type TaskDetailsMinAggregateOutputType = {
    id: number | null
    AccountId: number | null
    TaskId: number | null
    type: string | null
    address: string | null
    villageName: string | null
    pushUser: string | null
    category: string | null
    etc: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    assignedDays: number | null
    assignedUser: string | null
    TeamId: number | null
    y: string | null
    x: string | null
    area: Decimal | null
    pushPhone: string | null
    startedAt: Date | null
    endedAt: Date | null
    memo: string | null
  }

  export type TaskDetailsMaxAggregateOutputType = {
    id: number | null
    AccountId: number | null
    TaskId: number | null
    type: string | null
    address: string | null
    villageName: string | null
    pushUser: string | null
    category: string | null
    etc: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    assignedDays: number | null
    assignedUser: string | null
    TeamId: number | null
    y: string | null
    x: string | null
    area: Decimal | null
    pushPhone: string | null
    startedAt: Date | null
    endedAt: Date | null
    memo: string | null
  }

  export type TaskDetailsCountAggregateOutputType = {
    id: number
    AccountId: number
    TaskId: number
    type: number
    address: number
    villageName: number
    pushUser: number
    category: number
    etc: number
    status: number
    geometry: number
    createdAt: number
    updatedAt: number
    assignedDays: number
    assignedUser: number
    TeamId: number
    y: number
    x: number
    area: number
    pushPhone: number
    startedAt: number
    endedAt: number
    memo: number
    extra: number
    _all: number
  }


  export type TaskDetailsAvgAggregateInputType = {
    id?: true
    AccountId?: true
    TaskId?: true
    assignedDays?: true
    TeamId?: true
    area?: true
  }

  export type TaskDetailsSumAggregateInputType = {
    id?: true
    AccountId?: true
    TaskId?: true
    assignedDays?: true
    TeamId?: true
    area?: true
  }

  export type TaskDetailsMinAggregateInputType = {
    id?: true
    AccountId?: true
    TaskId?: true
    type?: true
    address?: true
    villageName?: true
    pushUser?: true
    category?: true
    etc?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    assignedDays?: true
    assignedUser?: true
    TeamId?: true
    y?: true
    x?: true
    area?: true
    pushPhone?: true
    startedAt?: true
    endedAt?: true
    memo?: true
  }

  export type TaskDetailsMaxAggregateInputType = {
    id?: true
    AccountId?: true
    TaskId?: true
    type?: true
    address?: true
    villageName?: true
    pushUser?: true
    category?: true
    etc?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    assignedDays?: true
    assignedUser?: true
    TeamId?: true
    y?: true
    x?: true
    area?: true
    pushPhone?: true
    startedAt?: true
    endedAt?: true
    memo?: true
  }

  export type TaskDetailsCountAggregateInputType = {
    id?: true
    AccountId?: true
    TaskId?: true
    type?: true
    address?: true
    villageName?: true
    pushUser?: true
    category?: true
    etc?: true
    status?: true
    geometry?: true
    createdAt?: true
    updatedAt?: true
    assignedDays?: true
    assignedUser?: true
    TeamId?: true
    y?: true
    x?: true
    area?: true
    pushPhone?: true
    startedAt?: true
    endedAt?: true
    memo?: true
    extra?: true
    _all?: true
  }

  export type TaskDetailsAggregateArgs = {
    /**
     * Filter which TaskDetails to aggregate.
     * 
    **/
    where?: TaskDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<TaskDetailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TaskDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDetails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskDetails
    **/
    _count?: true | TaskDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskDetailsMaxAggregateInputType
  }

  export type GetTaskDetailsAggregateType<T extends TaskDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskDetails[P]>
      : GetScalarType<T[P], AggregateTaskDetails[P]>
  }




  export type TaskDetailsGroupByArgs = {
    where?: TaskDetailsWhereInput
    orderBy?: Enumerable<TaskDetailsOrderByWithAggregationInput>
    by: Array<TaskDetailsScalarFieldEnum>
    having?: TaskDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskDetailsCountAggregateInputType | true
    _avg?: TaskDetailsAvgAggregateInputType
    _sum?: TaskDetailsSumAggregateInputType
    _min?: TaskDetailsMinAggregateInputType
    _max?: TaskDetailsMaxAggregateInputType
  }


  export type TaskDetailsGroupByOutputType = {
    id: number
    AccountId: number | null
    TaskId: number | null
    type: string | null
    address: string | null
    villageName: string | null
    pushUser: string | null
    category: string | null
    etc: string | null
    status: string | null
    geometry: JsonValue | null
    createdAt: Date
    updatedAt: Date
    assignedDays: number | null
    assignedUser: string | null
    TeamId: number | null
    y: string | null
    x: string | null
    area: Decimal | null
    pushPhone: string | null
    startedAt: Date | null
    endedAt: Date | null
    memo: string | null
    extra: JsonValue | null
    _count: TaskDetailsCountAggregateOutputType | null
    _avg: TaskDetailsAvgAggregateOutputType | null
    _sum: TaskDetailsSumAggregateOutputType | null
    _min: TaskDetailsMinAggregateOutputType | null
    _max: TaskDetailsMaxAggregateOutputType | null
  }

  type GetTaskDetailsGroupByPayload<T extends TaskDetailsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TaskDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], TaskDetailsGroupByOutputType[P]>
        }
      >
    >


  export type TaskDetailsSelect = {
    id?: boolean
    AccountId?: boolean
    TaskId?: boolean
    type?: boolean
    address?: boolean
    villageName?: boolean
    pushUser?: boolean
    category?: boolean
    etc?: boolean
    status?: boolean
    geometry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedDays?: boolean
    assignedUser?: boolean
    TeamId?: boolean
    y?: boolean
    x?: boolean
    area?: boolean
    pushPhone?: boolean
    startedAt?: boolean
    endedAt?: boolean
    memo?: boolean
    extra?: boolean
    Accounts?: boolean | AccountsArgs
    Tasks?: boolean | TasksArgs
    Teams?: boolean | TeamsArgs
    TaskDetailResources?: boolean | TaskDetailResourcesFindManyArgs
    _count?: boolean | TaskDetailsCountOutputTypeArgs
  }

  export type TaskDetailsInclude = {
    Accounts?: boolean | AccountsArgs
    Tasks?: boolean | TasksArgs
    Teams?: boolean | TeamsArgs
    TaskDetailResources?: boolean | TaskDetailResourcesFindManyArgs
    _count?: boolean | TaskDetailsCountOutputTypeArgs
  }

  export type TaskDetailsGetPayload<
    S extends boolean | null | undefined | TaskDetailsArgs,
    U = keyof S
      > = S extends true
        ? TaskDetails
    : S extends undefined
    ? never
    : S extends TaskDetailsArgs | TaskDetailsFindManyArgs
    ?'include' extends U
    ? TaskDetails  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'Tasks' ? TasksGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'Teams' ? TeamsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'TaskDetailResources' ? Array < TaskDetailResourcesGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? TaskDetailsCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'Tasks' ? TasksGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'Teams' ? TeamsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'TaskDetailResources' ? Array < TaskDetailResourcesGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? TaskDetailsCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof TaskDetails ? TaskDetails[P] : never
  } 
    : TaskDetails
  : TaskDetails


  type TaskDetailsCountArgs = Merge<
    Omit<TaskDetailsFindManyArgs, 'select' | 'include'> & {
      select?: TaskDetailsCountAggregateInputType | true
    }
  >

  export interface TaskDetailsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one TaskDetails that matches the filter.
     * @param {TaskDetailsFindUniqueArgs} args - Arguments to find a TaskDetails
     * @example
     * // Get one TaskDetails
     * const taskDetails = await prisma.taskDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TaskDetailsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TaskDetailsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TaskDetails'> extends True ? CheckSelect<T, Prisma__TaskDetailsClient<TaskDetails>, Prisma__TaskDetailsClient<TaskDetailsGetPayload<T>>> : CheckSelect<T, Prisma__TaskDetailsClient<TaskDetails | null, null>, Prisma__TaskDetailsClient<TaskDetailsGetPayload<T> | null, null>>

    /**
     * Find the first TaskDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailsFindFirstArgs} args - Arguments to find a TaskDetails
     * @example
     * // Get one TaskDetails
     * const taskDetails = await prisma.taskDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TaskDetailsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TaskDetailsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TaskDetails'> extends True ? CheckSelect<T, Prisma__TaskDetailsClient<TaskDetails>, Prisma__TaskDetailsClient<TaskDetailsGetPayload<T>>> : CheckSelect<T, Prisma__TaskDetailsClient<TaskDetails | null, null>, Prisma__TaskDetailsClient<TaskDetailsGetPayload<T> | null, null>>

    /**
     * Find zero or more TaskDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskDetails
     * const taskDetails = await prisma.taskDetails.findMany()
     * 
     * // Get first 10 TaskDetails
     * const taskDetails = await prisma.taskDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskDetailsWithIdOnly = await prisma.taskDetails.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TaskDetailsFindManyArgs>(
      args?: SelectSubset<T, TaskDetailsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TaskDetails>>, PrismaPromise<Array<TaskDetailsGetPayload<T>>>>

    /**
     * Create a TaskDetails.
     * @param {TaskDetailsCreateArgs} args - Arguments to create a TaskDetails.
     * @example
     * // Create one TaskDetails
     * const TaskDetails = await prisma.taskDetails.create({
     *   data: {
     *     // ... data to create a TaskDetails
     *   }
     * })
     * 
    **/
    create<T extends TaskDetailsCreateArgs>(
      args: SelectSubset<T, TaskDetailsCreateArgs>
    ): CheckSelect<T, Prisma__TaskDetailsClient<TaskDetails>, Prisma__TaskDetailsClient<TaskDetailsGetPayload<T>>>

    /**
     * Create many TaskDetails.
     *     @param {TaskDetailsCreateManyArgs} args - Arguments to create many TaskDetails.
     *     @example
     *     // Create many TaskDetails
     *     const taskDetails = await prisma.taskDetails.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TaskDetailsCreateManyArgs>(
      args?: SelectSubset<T, TaskDetailsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TaskDetails.
     * @param {TaskDetailsDeleteArgs} args - Arguments to delete one TaskDetails.
     * @example
     * // Delete one TaskDetails
     * const TaskDetails = await prisma.taskDetails.delete({
     *   where: {
     *     // ... filter to delete one TaskDetails
     *   }
     * })
     * 
    **/
    delete<T extends TaskDetailsDeleteArgs>(
      args: SelectSubset<T, TaskDetailsDeleteArgs>
    ): CheckSelect<T, Prisma__TaskDetailsClient<TaskDetails>, Prisma__TaskDetailsClient<TaskDetailsGetPayload<T>>>

    /**
     * Update one TaskDetails.
     * @param {TaskDetailsUpdateArgs} args - Arguments to update one TaskDetails.
     * @example
     * // Update one TaskDetails
     * const taskDetails = await prisma.taskDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TaskDetailsUpdateArgs>(
      args: SelectSubset<T, TaskDetailsUpdateArgs>
    ): CheckSelect<T, Prisma__TaskDetailsClient<TaskDetails>, Prisma__TaskDetailsClient<TaskDetailsGetPayload<T>>>

    /**
     * Delete zero or more TaskDetails.
     * @param {TaskDetailsDeleteManyArgs} args - Arguments to filter TaskDetails to delete.
     * @example
     * // Delete a few TaskDetails
     * const { count } = await prisma.taskDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TaskDetailsDeleteManyArgs>(
      args?: SelectSubset<T, TaskDetailsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskDetails
     * const taskDetails = await prisma.taskDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TaskDetailsUpdateManyArgs>(
      args: SelectSubset<T, TaskDetailsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskDetails.
     * @param {TaskDetailsUpsertArgs} args - Arguments to update or create a TaskDetails.
     * @example
     * // Update or create a TaskDetails
     * const taskDetails = await prisma.taskDetails.upsert({
     *   create: {
     *     // ... data to create a TaskDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskDetails we want to update
     *   }
     * })
    **/
    upsert<T extends TaskDetailsUpsertArgs>(
      args: SelectSubset<T, TaskDetailsUpsertArgs>
    ): CheckSelect<T, Prisma__TaskDetailsClient<TaskDetails>, Prisma__TaskDetailsClient<TaskDetailsGetPayload<T>>>

    /**
     * Find one TaskDetails that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {TaskDetailsFindUniqueOrThrowArgs} args - Arguments to find a TaskDetails
     * @example
     * // Get one TaskDetails
     * const taskDetails = await prisma.taskDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TaskDetailsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TaskDetailsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__TaskDetailsClient<TaskDetails>, Prisma__TaskDetailsClient<TaskDetailsGetPayload<T>>>

    /**
     * Find the first TaskDetails that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailsFindFirstOrThrowArgs} args - Arguments to find a TaskDetails
     * @example
     * // Get one TaskDetails
     * const taskDetails = await prisma.taskDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TaskDetailsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TaskDetailsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__TaskDetailsClient<TaskDetails>, Prisma__TaskDetailsClient<TaskDetailsGetPayload<T>>>

    /**
     * Count the number of TaskDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailsCountArgs} args - Arguments to filter TaskDetails to count.
     * @example
     * // Count the number of TaskDetails
     * const count = await prisma.taskDetails.count({
     *   where: {
     *     // ... the filter for the TaskDetails we want to count
     *   }
     * })
    **/
    count<T extends TaskDetailsCountArgs>(
      args?: Subset<T, TaskDetailsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskDetailsAggregateArgs>(args: Subset<T, TaskDetailsAggregateArgs>): PrismaPromise<GetTaskDetailsAggregateType<T>>

    /**
     * Group by TaskDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskDetailsGroupByArgs['orderBy'] }
        : { orderBy?: TaskDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskDetailsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TaskDetailsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Accounts<T extends AccountsArgs = {}>(args?: Subset<T, AccountsArgs>): CheckSelect<T, Prisma__AccountsClient<Accounts | Null>, Prisma__AccountsClient<AccountsGetPayload<T> | Null>>;

    Tasks<T extends TasksArgs = {}>(args?: Subset<T, TasksArgs>): CheckSelect<T, Prisma__TasksClient<Tasks | Null>, Prisma__TasksClient<TasksGetPayload<T> | Null>>;

    Teams<T extends TeamsArgs = {}>(args?: Subset<T, TeamsArgs>): CheckSelect<T, Prisma__TeamsClient<Teams | Null>, Prisma__TeamsClient<TeamsGetPayload<T> | Null>>;

    TaskDetailResources<T extends TaskDetailResourcesFindManyArgs = {}>(args?: Subset<T, TaskDetailResourcesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<TaskDetailResources>| Null>, PrismaPromise<Array<TaskDetailResourcesGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TaskDetails base type for findUnique actions
   */
  export type TaskDetailsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TaskDetails
     * 
    **/
    select?: TaskDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskDetailsInclude | null
    /**
     * Filter, which TaskDetails to fetch.
     * 
    **/
    where: TaskDetailsWhereUniqueInput
  }

  /**
   * TaskDetails: findUnique
   */
  export interface TaskDetailsFindUniqueArgs extends TaskDetailsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TaskDetails base type for findFirst actions
   */
  export type TaskDetailsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TaskDetails
     * 
    **/
    select?: TaskDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskDetailsInclude | null
    /**
     * Filter, which TaskDetails to fetch.
     * 
    **/
    where?: TaskDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<TaskDetailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskDetails.
     * 
    **/
    cursor?: TaskDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDetails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskDetails.
     * 
    **/
    distinct?: Enumerable<TaskDetailsScalarFieldEnum>
  }

  /**
   * TaskDetails: findFirst
   */
  export interface TaskDetailsFindFirstArgs extends TaskDetailsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TaskDetails findMany
   */
  export type TaskDetailsFindManyArgs = {
    /**
     * Select specific fields to fetch from the TaskDetails
     * 
    **/
    select?: TaskDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskDetailsInclude | null
    /**
     * Filter, which TaskDetails to fetch.
     * 
    **/
    where?: TaskDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<TaskDetailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskDetails.
     * 
    **/
    cursor?: TaskDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDetails.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TaskDetailsScalarFieldEnum>
  }


  /**
   * TaskDetails create
   */
  export type TaskDetailsCreateArgs = {
    /**
     * Select specific fields to fetch from the TaskDetails
     * 
    **/
    select?: TaskDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskDetailsInclude | null
    /**
     * The data needed to create a TaskDetails.
     * 
    **/
    data: XOR<TaskDetailsCreateInput, TaskDetailsUncheckedCreateInput>
  }


  /**
   * TaskDetails createMany
   */
  export type TaskDetailsCreateManyArgs = {
    /**
     * The data used to create many TaskDetails.
     * 
    **/
    data: Enumerable<TaskDetailsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TaskDetails update
   */
  export type TaskDetailsUpdateArgs = {
    /**
     * Select specific fields to fetch from the TaskDetails
     * 
    **/
    select?: TaskDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskDetailsInclude | null
    /**
     * The data needed to update a TaskDetails.
     * 
    **/
    data: XOR<TaskDetailsUpdateInput, TaskDetailsUncheckedUpdateInput>
    /**
     * Choose, which TaskDetails to update.
     * 
    **/
    where: TaskDetailsWhereUniqueInput
  }


  /**
   * TaskDetails updateMany
   */
  export type TaskDetailsUpdateManyArgs = {
    /**
     * The data used to update TaskDetails.
     * 
    **/
    data: XOR<TaskDetailsUpdateManyMutationInput, TaskDetailsUncheckedUpdateManyInput>
    /**
     * Filter which TaskDetails to update
     * 
    **/
    where?: TaskDetailsWhereInput
  }


  /**
   * TaskDetails upsert
   */
  export type TaskDetailsUpsertArgs = {
    /**
     * Select specific fields to fetch from the TaskDetails
     * 
    **/
    select?: TaskDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskDetailsInclude | null
    /**
     * The filter to search for the TaskDetails to update in case it exists.
     * 
    **/
    where: TaskDetailsWhereUniqueInput
    /**
     * In case the TaskDetails found by the `where` argument doesn't exist, create a new TaskDetails with this data.
     * 
    **/
    create: XOR<TaskDetailsCreateInput, TaskDetailsUncheckedCreateInput>
    /**
     * In case the TaskDetails was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TaskDetailsUpdateInput, TaskDetailsUncheckedUpdateInput>
  }


  /**
   * TaskDetails delete
   */
  export type TaskDetailsDeleteArgs = {
    /**
     * Select specific fields to fetch from the TaskDetails
     * 
    **/
    select?: TaskDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskDetailsInclude | null
    /**
     * Filter which TaskDetails to delete.
     * 
    **/
    where: TaskDetailsWhereUniqueInput
  }


  /**
   * TaskDetails deleteMany
   */
  export type TaskDetailsDeleteManyArgs = {
    /**
     * Filter which TaskDetails to delete
     * 
    **/
    where?: TaskDetailsWhereInput
  }


  /**
   * TaskDetails: findUniqueOrThrow
   */
  export type TaskDetailsFindUniqueOrThrowArgs = TaskDetailsFindUniqueArgsBase
      

  /**
   * TaskDetails: findFirstOrThrow
   */
  export type TaskDetailsFindFirstOrThrowArgs = TaskDetailsFindFirstArgsBase
      

  /**
   * TaskDetails without action
   */
  export type TaskDetailsArgs = {
    /**
     * Select specific fields to fetch from the TaskDetails
     * 
    **/
    select?: TaskDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskDetailsInclude | null
  }



  /**
   * Model TaskGroups
   */


  export type AggregateTaskGroups = {
    _count: TaskGroupsCountAggregateOutputType | null
    _avg: TaskGroupsAvgAggregateOutputType | null
    _sum: TaskGroupsSumAggregateOutputType | null
    _min: TaskGroupsMinAggregateOutputType | null
    _max: TaskGroupsMaxAggregateOutputType | null
  }

  export type TaskGroupsAvgAggregateOutputType = {
    id: number | null
    AccountId: number | null
    area: Decimal | null
  }

  export type TaskGroupsSumAggregateOutputType = {
    id: number | null
    AccountId: number | null
    area: Decimal | null
  }

  export type TaskGroupsMinAggregateOutputType = {
    id: number | null
    path: string | null
    name: string | null
    status: string | null
    AccountId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    area: Decimal | null
    createType: string | null
  }

  export type TaskGroupsMaxAggregateOutputType = {
    id: number | null
    path: string | null
    name: string | null
    status: string | null
    AccountId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    area: Decimal | null
    createType: string | null
  }

  export type TaskGroupsCountAggregateOutputType = {
    id: number
    path: number
    name: number
    status: number
    AccountId: number
    createdAt: number
    updatedAt: number
    area: number
    createType: number
    extra: number
    _all: number
  }


  export type TaskGroupsAvgAggregateInputType = {
    id?: true
    AccountId?: true
    area?: true
  }

  export type TaskGroupsSumAggregateInputType = {
    id?: true
    AccountId?: true
    area?: true
  }

  export type TaskGroupsMinAggregateInputType = {
    id?: true
    path?: true
    name?: true
    status?: true
    AccountId?: true
    createdAt?: true
    updatedAt?: true
    area?: true
    createType?: true
  }

  export type TaskGroupsMaxAggregateInputType = {
    id?: true
    path?: true
    name?: true
    status?: true
    AccountId?: true
    createdAt?: true
    updatedAt?: true
    area?: true
    createType?: true
  }

  export type TaskGroupsCountAggregateInputType = {
    id?: true
    path?: true
    name?: true
    status?: true
    AccountId?: true
    createdAt?: true
    updatedAt?: true
    area?: true
    createType?: true
    extra?: true
    _all?: true
  }

  export type TaskGroupsAggregateArgs = {
    /**
     * Filter which TaskGroups to aggregate.
     * 
    **/
    where?: TaskGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<TaskGroupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TaskGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskGroups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskGroups
    **/
    _count?: true | TaskGroupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskGroupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskGroupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskGroupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskGroupsMaxAggregateInputType
  }

  export type GetTaskGroupsAggregateType<T extends TaskGroupsAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskGroups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskGroups[P]>
      : GetScalarType<T[P], AggregateTaskGroups[P]>
  }




  export type TaskGroupsGroupByArgs = {
    where?: TaskGroupsWhereInput
    orderBy?: Enumerable<TaskGroupsOrderByWithAggregationInput>
    by: Array<TaskGroupsScalarFieldEnum>
    having?: TaskGroupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskGroupsCountAggregateInputType | true
    _avg?: TaskGroupsAvgAggregateInputType
    _sum?: TaskGroupsSumAggregateInputType
    _min?: TaskGroupsMinAggregateInputType
    _max?: TaskGroupsMaxAggregateInputType
  }


  export type TaskGroupsGroupByOutputType = {
    id: number
    path: string | null
    name: string | null
    status: string | null
    AccountId: number | null
    createdAt: Date
    updatedAt: Date
    area: Decimal | null
    createType: string | null
    extra: JsonValue | null
    _count: TaskGroupsCountAggregateOutputType | null
    _avg: TaskGroupsAvgAggregateOutputType | null
    _sum: TaskGroupsSumAggregateOutputType | null
    _min: TaskGroupsMinAggregateOutputType | null
    _max: TaskGroupsMaxAggregateOutputType | null
  }

  type GetTaskGroupsGroupByPayload<T extends TaskGroupsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TaskGroupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupsGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupsGroupByOutputType[P]>
        }
      >
    >


  export type TaskGroupsSelect = {
    id?: boolean
    path?: boolean
    name?: boolean
    status?: boolean
    AccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    area?: boolean
    createType?: boolean
    extra?: boolean
    Accounts?: boolean | AccountsArgs
    Tasks?: boolean | TasksFindManyArgs
    _count?: boolean | TaskGroupsCountOutputTypeArgs
  }

  export type TaskGroupsInclude = {
    Accounts?: boolean | AccountsArgs
    Tasks?: boolean | TasksFindManyArgs
    _count?: boolean | TaskGroupsCountOutputTypeArgs
  }

  export type TaskGroupsGetPayload<
    S extends boolean | null | undefined | TaskGroupsArgs,
    U = keyof S
      > = S extends true
        ? TaskGroups
    : S extends undefined
    ? never
    : S extends TaskGroupsArgs | TaskGroupsFindManyArgs
    ?'include' extends U
    ? TaskGroups  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'Tasks' ? Array < TasksGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? TaskGroupsCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'Tasks' ? Array < TasksGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? TaskGroupsCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof TaskGroups ? TaskGroups[P] : never
  } 
    : TaskGroups
  : TaskGroups


  type TaskGroupsCountArgs = Merge<
    Omit<TaskGroupsFindManyArgs, 'select' | 'include'> & {
      select?: TaskGroupsCountAggregateInputType | true
    }
  >

  export interface TaskGroupsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one TaskGroups that matches the filter.
     * @param {TaskGroupsFindUniqueArgs} args - Arguments to find a TaskGroups
     * @example
     * // Get one TaskGroups
     * const taskGroups = await prisma.taskGroups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TaskGroupsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TaskGroupsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TaskGroups'> extends True ? CheckSelect<T, Prisma__TaskGroupsClient<TaskGroups>, Prisma__TaskGroupsClient<TaskGroupsGetPayload<T>>> : CheckSelect<T, Prisma__TaskGroupsClient<TaskGroups | null, null>, Prisma__TaskGroupsClient<TaskGroupsGetPayload<T> | null, null>>

    /**
     * Find the first TaskGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupsFindFirstArgs} args - Arguments to find a TaskGroups
     * @example
     * // Get one TaskGroups
     * const taskGroups = await prisma.taskGroups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TaskGroupsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TaskGroupsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TaskGroups'> extends True ? CheckSelect<T, Prisma__TaskGroupsClient<TaskGroups>, Prisma__TaskGroupsClient<TaskGroupsGetPayload<T>>> : CheckSelect<T, Prisma__TaskGroupsClient<TaskGroups | null, null>, Prisma__TaskGroupsClient<TaskGroupsGetPayload<T> | null, null>>

    /**
     * Find zero or more TaskGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskGroups
     * const taskGroups = await prisma.taskGroups.findMany()
     * 
     * // Get first 10 TaskGroups
     * const taskGroups = await prisma.taskGroups.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskGroupsWithIdOnly = await prisma.taskGroups.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TaskGroupsFindManyArgs>(
      args?: SelectSubset<T, TaskGroupsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TaskGroups>>, PrismaPromise<Array<TaskGroupsGetPayload<T>>>>

    /**
     * Create a TaskGroups.
     * @param {TaskGroupsCreateArgs} args - Arguments to create a TaskGroups.
     * @example
     * // Create one TaskGroups
     * const TaskGroups = await prisma.taskGroups.create({
     *   data: {
     *     // ... data to create a TaskGroups
     *   }
     * })
     * 
    **/
    create<T extends TaskGroupsCreateArgs>(
      args: SelectSubset<T, TaskGroupsCreateArgs>
    ): CheckSelect<T, Prisma__TaskGroupsClient<TaskGroups>, Prisma__TaskGroupsClient<TaskGroupsGetPayload<T>>>

    /**
     * Create many TaskGroups.
     *     @param {TaskGroupsCreateManyArgs} args - Arguments to create many TaskGroups.
     *     @example
     *     // Create many TaskGroups
     *     const taskGroups = await prisma.taskGroups.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TaskGroupsCreateManyArgs>(
      args?: SelectSubset<T, TaskGroupsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TaskGroups.
     * @param {TaskGroupsDeleteArgs} args - Arguments to delete one TaskGroups.
     * @example
     * // Delete one TaskGroups
     * const TaskGroups = await prisma.taskGroups.delete({
     *   where: {
     *     // ... filter to delete one TaskGroups
     *   }
     * })
     * 
    **/
    delete<T extends TaskGroupsDeleteArgs>(
      args: SelectSubset<T, TaskGroupsDeleteArgs>
    ): CheckSelect<T, Prisma__TaskGroupsClient<TaskGroups>, Prisma__TaskGroupsClient<TaskGroupsGetPayload<T>>>

    /**
     * Update one TaskGroups.
     * @param {TaskGroupsUpdateArgs} args - Arguments to update one TaskGroups.
     * @example
     * // Update one TaskGroups
     * const taskGroups = await prisma.taskGroups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TaskGroupsUpdateArgs>(
      args: SelectSubset<T, TaskGroupsUpdateArgs>
    ): CheckSelect<T, Prisma__TaskGroupsClient<TaskGroups>, Prisma__TaskGroupsClient<TaskGroupsGetPayload<T>>>

    /**
     * Delete zero or more TaskGroups.
     * @param {TaskGroupsDeleteManyArgs} args - Arguments to filter TaskGroups to delete.
     * @example
     * // Delete a few TaskGroups
     * const { count } = await prisma.taskGroups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TaskGroupsDeleteManyArgs>(
      args?: SelectSubset<T, TaskGroupsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskGroups
     * const taskGroups = await prisma.taskGroups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TaskGroupsUpdateManyArgs>(
      args: SelectSubset<T, TaskGroupsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskGroups.
     * @param {TaskGroupsUpsertArgs} args - Arguments to update or create a TaskGroups.
     * @example
     * // Update or create a TaskGroups
     * const taskGroups = await prisma.taskGroups.upsert({
     *   create: {
     *     // ... data to create a TaskGroups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskGroups we want to update
     *   }
     * })
    **/
    upsert<T extends TaskGroupsUpsertArgs>(
      args: SelectSubset<T, TaskGroupsUpsertArgs>
    ): CheckSelect<T, Prisma__TaskGroupsClient<TaskGroups>, Prisma__TaskGroupsClient<TaskGroupsGetPayload<T>>>

    /**
     * Find one TaskGroups that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {TaskGroupsFindUniqueOrThrowArgs} args - Arguments to find a TaskGroups
     * @example
     * // Get one TaskGroups
     * const taskGroups = await prisma.taskGroups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TaskGroupsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TaskGroupsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__TaskGroupsClient<TaskGroups>, Prisma__TaskGroupsClient<TaskGroupsGetPayload<T>>>

    /**
     * Find the first TaskGroups that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupsFindFirstOrThrowArgs} args - Arguments to find a TaskGroups
     * @example
     * // Get one TaskGroups
     * const taskGroups = await prisma.taskGroups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TaskGroupsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TaskGroupsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__TaskGroupsClient<TaskGroups>, Prisma__TaskGroupsClient<TaskGroupsGetPayload<T>>>

    /**
     * Count the number of TaskGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupsCountArgs} args - Arguments to filter TaskGroups to count.
     * @example
     * // Count the number of TaskGroups
     * const count = await prisma.taskGroups.count({
     *   where: {
     *     // ... the filter for the TaskGroups we want to count
     *   }
     * })
    **/
    count<T extends TaskGroupsCountArgs>(
      args?: Subset<T, TaskGroupsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskGroupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskGroupsAggregateArgs>(args: Subset<T, TaskGroupsAggregateArgs>): PrismaPromise<GetTaskGroupsAggregateType<T>>

    /**
     * Group by TaskGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupsGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskGroups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TaskGroupsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Accounts<T extends AccountsArgs = {}>(args?: Subset<T, AccountsArgs>): CheckSelect<T, Prisma__AccountsClient<Accounts | Null>, Prisma__AccountsClient<AccountsGetPayload<T> | Null>>;

    Tasks<T extends TasksFindManyArgs = {}>(args?: Subset<T, TasksFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Tasks>| Null>, PrismaPromise<Array<TasksGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TaskGroups base type for findUnique actions
   */
  export type TaskGroupsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TaskGroups
     * 
    **/
    select?: TaskGroupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskGroupsInclude | null
    /**
     * Filter, which TaskGroups to fetch.
     * 
    **/
    where: TaskGroupsWhereUniqueInput
  }

  /**
   * TaskGroups: findUnique
   */
  export interface TaskGroupsFindUniqueArgs extends TaskGroupsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TaskGroups base type for findFirst actions
   */
  export type TaskGroupsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TaskGroups
     * 
    **/
    select?: TaskGroupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskGroupsInclude | null
    /**
     * Filter, which TaskGroups to fetch.
     * 
    **/
    where?: TaskGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<TaskGroupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskGroups.
     * 
    **/
    cursor?: TaskGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskGroups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskGroups.
     * 
    **/
    distinct?: Enumerable<TaskGroupsScalarFieldEnum>
  }

  /**
   * TaskGroups: findFirst
   */
  export interface TaskGroupsFindFirstArgs extends TaskGroupsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TaskGroups findMany
   */
  export type TaskGroupsFindManyArgs = {
    /**
     * Select specific fields to fetch from the TaskGroups
     * 
    **/
    select?: TaskGroupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskGroupsInclude | null
    /**
     * Filter, which TaskGroups to fetch.
     * 
    **/
    where?: TaskGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<TaskGroupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskGroups.
     * 
    **/
    cursor?: TaskGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskGroups.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TaskGroupsScalarFieldEnum>
  }


  /**
   * TaskGroups create
   */
  export type TaskGroupsCreateArgs = {
    /**
     * Select specific fields to fetch from the TaskGroups
     * 
    **/
    select?: TaskGroupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskGroupsInclude | null
    /**
     * The data needed to create a TaskGroups.
     * 
    **/
    data: XOR<TaskGroupsCreateInput, TaskGroupsUncheckedCreateInput>
  }


  /**
   * TaskGroups createMany
   */
  export type TaskGroupsCreateManyArgs = {
    /**
     * The data used to create many TaskGroups.
     * 
    **/
    data: Enumerable<TaskGroupsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TaskGroups update
   */
  export type TaskGroupsUpdateArgs = {
    /**
     * Select specific fields to fetch from the TaskGroups
     * 
    **/
    select?: TaskGroupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskGroupsInclude | null
    /**
     * The data needed to update a TaskGroups.
     * 
    **/
    data: XOR<TaskGroupsUpdateInput, TaskGroupsUncheckedUpdateInput>
    /**
     * Choose, which TaskGroups to update.
     * 
    **/
    where: TaskGroupsWhereUniqueInput
  }


  /**
   * TaskGroups updateMany
   */
  export type TaskGroupsUpdateManyArgs = {
    /**
     * The data used to update TaskGroups.
     * 
    **/
    data: XOR<TaskGroupsUpdateManyMutationInput, TaskGroupsUncheckedUpdateManyInput>
    /**
     * Filter which TaskGroups to update
     * 
    **/
    where?: TaskGroupsWhereInput
  }


  /**
   * TaskGroups upsert
   */
  export type TaskGroupsUpsertArgs = {
    /**
     * Select specific fields to fetch from the TaskGroups
     * 
    **/
    select?: TaskGroupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskGroupsInclude | null
    /**
     * The filter to search for the TaskGroups to update in case it exists.
     * 
    **/
    where: TaskGroupsWhereUniqueInput
    /**
     * In case the TaskGroups found by the `where` argument doesn't exist, create a new TaskGroups with this data.
     * 
    **/
    create: XOR<TaskGroupsCreateInput, TaskGroupsUncheckedCreateInput>
    /**
     * In case the TaskGroups was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TaskGroupsUpdateInput, TaskGroupsUncheckedUpdateInput>
  }


  /**
   * TaskGroups delete
   */
  export type TaskGroupsDeleteArgs = {
    /**
     * Select specific fields to fetch from the TaskGroups
     * 
    **/
    select?: TaskGroupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskGroupsInclude | null
    /**
     * Filter which TaskGroups to delete.
     * 
    **/
    where: TaskGroupsWhereUniqueInput
  }


  /**
   * TaskGroups deleteMany
   */
  export type TaskGroupsDeleteManyArgs = {
    /**
     * Filter which TaskGroups to delete
     * 
    **/
    where?: TaskGroupsWhereInput
  }


  /**
   * TaskGroups: findUniqueOrThrow
   */
  export type TaskGroupsFindUniqueOrThrowArgs = TaskGroupsFindUniqueArgsBase
      

  /**
   * TaskGroups: findFirstOrThrow
   */
  export type TaskGroupsFindFirstOrThrowArgs = TaskGroupsFindFirstArgsBase
      

  /**
   * TaskGroups without action
   */
  export type TaskGroupsArgs = {
    /**
     * Select specific fields to fetch from the TaskGroups
     * 
    **/
    select?: TaskGroupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TaskGroupsInclude | null
  }



  /**
   * Model Tasks
   */


  export type AggregateTasks = {
    _count: TasksCountAggregateOutputType | null
    _avg: TasksAvgAggregateOutputType | null
    _sum: TasksSumAggregateOutputType | null
    _min: TasksMinAggregateOutputType | null
    _max: TasksMaxAggregateOutputType | null
  }

  export type TasksAvgAggregateOutputType = {
    id: number | null
    AccountId: number | null
    workingDays: number | null
    workingTeamsCnt: number | null
    TaskGroupId: number | null
    area: Decimal | null
    real_area: Decimal | null
  }

  export type TasksSumAggregateOutputType = {
    id: number | null
    AccountId: number | null
    workingDays: number | null
    workingTeamsCnt: number | null
    TaskGroupId: number | null
    area: Decimal | null
    real_area: Decimal | null
  }

  export type TasksMinAggregateOutputType = {
    id: number | null
    name: string | null
    status: string | null
    AccountId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    workingDays: number | null
    workingTeamsCnt: number | null
    TaskGroupId: number | null
    startDate: Date | null
    endDate: Date | null
    area: Decimal | null
    isPaid: boolean | null
    createType: string | null
    real_area: Decimal | null
  }

  export type TasksMaxAggregateOutputType = {
    id: number | null
    name: string | null
    status: string | null
    AccountId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    workingDays: number | null
    workingTeamsCnt: number | null
    TaskGroupId: number | null
    startDate: Date | null
    endDate: Date | null
    area: Decimal | null
    isPaid: boolean | null
    createType: string | null
    real_area: Decimal | null
  }

  export type TasksCountAggregateOutputType = {
    id: number
    name: number
    status: number
    AccountId: number
    createdAt: number
    updatedAt: number
    workingDays: number
    workingTeamsCnt: number
    TaskGroupId: number
    startDate: number
    endDate: number
    area: number
    isPaid: number
    createType: number
    extra: number
    real_area: number
    _all: number
  }


  export type TasksAvgAggregateInputType = {
    id?: true
    AccountId?: true
    workingDays?: true
    workingTeamsCnt?: true
    TaskGroupId?: true
    area?: true
    real_area?: true
  }

  export type TasksSumAggregateInputType = {
    id?: true
    AccountId?: true
    workingDays?: true
    workingTeamsCnt?: true
    TaskGroupId?: true
    area?: true
    real_area?: true
  }

  export type TasksMinAggregateInputType = {
    id?: true
    name?: true
    status?: true
    AccountId?: true
    createdAt?: true
    updatedAt?: true
    workingDays?: true
    workingTeamsCnt?: true
    TaskGroupId?: true
    startDate?: true
    endDate?: true
    area?: true
    isPaid?: true
    createType?: true
    real_area?: true
  }

  export type TasksMaxAggregateInputType = {
    id?: true
    name?: true
    status?: true
    AccountId?: true
    createdAt?: true
    updatedAt?: true
    workingDays?: true
    workingTeamsCnt?: true
    TaskGroupId?: true
    startDate?: true
    endDate?: true
    area?: true
    isPaid?: true
    createType?: true
    real_area?: true
  }

  export type TasksCountAggregateInputType = {
    id?: true
    name?: true
    status?: true
    AccountId?: true
    createdAt?: true
    updatedAt?: true
    workingDays?: true
    workingTeamsCnt?: true
    TaskGroupId?: true
    startDate?: true
    endDate?: true
    area?: true
    isPaid?: true
    createType?: true
    extra?: true
    real_area?: true
    _all?: true
  }

  export type TasksAggregateArgs = {
    /**
     * Filter which Tasks to aggregate.
     * 
    **/
    where?: TasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     * 
    **/
    orderBy?: Enumerable<TasksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TasksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TasksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TasksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TasksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TasksMaxAggregateInputType
  }

  export type GetTasksAggregateType<T extends TasksAggregateArgs> = {
        [P in keyof T & keyof AggregateTasks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTasks[P]>
      : GetScalarType<T[P], AggregateTasks[P]>
  }




  export type TasksGroupByArgs = {
    where?: TasksWhereInput
    orderBy?: Enumerable<TasksOrderByWithAggregationInput>
    by: Array<TasksScalarFieldEnum>
    having?: TasksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TasksCountAggregateInputType | true
    _avg?: TasksAvgAggregateInputType
    _sum?: TasksSumAggregateInputType
    _min?: TasksMinAggregateInputType
    _max?: TasksMaxAggregateInputType
  }


  export type TasksGroupByOutputType = {
    id: number
    name: string | null
    status: string | null
    AccountId: number | null
    createdAt: Date
    updatedAt: Date
    workingDays: number | null
    workingTeamsCnt: number | null
    TaskGroupId: number | null
    startDate: Date | null
    endDate: Date | null
    area: Decimal | null
    isPaid: boolean | null
    createType: string | null
    extra: JsonValue | null
    real_area: Decimal | null
    _count: TasksCountAggregateOutputType | null
    _avg: TasksAvgAggregateOutputType | null
    _sum: TasksSumAggregateOutputType | null
    _min: TasksMinAggregateOutputType | null
    _max: TasksMaxAggregateOutputType | null
  }

  type GetTasksGroupByPayload<T extends TasksGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TasksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TasksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TasksGroupByOutputType[P]>
            : GetScalarType<T[P], TasksGroupByOutputType[P]>
        }
      >
    >


  export type TasksSelect = {
    id?: boolean
    name?: boolean
    status?: boolean
    AccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workingDays?: boolean
    workingTeamsCnt?: boolean
    TaskGroupId?: boolean
    startDate?: boolean
    endDate?: boolean
    area?: boolean
    isPaid?: boolean
    createType?: boolean
    extra?: boolean
    real_area?: boolean
    Accounts?: boolean | AccountsArgs
    TaskGroups?: boolean | TaskGroupsArgs
    Reports?: boolean | ReportsFindManyArgs
    Statistics?: boolean | StatisticsFindManyArgs
    TaskDetails?: boolean | TaskDetailsFindManyArgs
    Teams?: boolean | TeamsFindManyArgs
    _count?: boolean | TasksCountOutputTypeArgs
  }

  export type TasksInclude = {
    Accounts?: boolean | AccountsArgs
    TaskGroups?: boolean | TaskGroupsArgs
    Reports?: boolean | ReportsFindManyArgs
    Statistics?: boolean | StatisticsFindManyArgs
    TaskDetails?: boolean | TaskDetailsFindManyArgs
    Teams?: boolean | TeamsFindManyArgs
    _count?: boolean | TasksCountOutputTypeArgs
  }

  export type TasksGetPayload<
    S extends boolean | null | undefined | TasksArgs,
    U = keyof S
      > = S extends true
        ? Tasks
    : S extends undefined
    ? never
    : S extends TasksArgs | TasksFindManyArgs
    ?'include' extends U
    ? Tasks  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'TaskGroups' ? TaskGroupsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'Reports' ? Array < ReportsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Statistics' ? Array < StatisticsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'TaskDetails' ? Array < TaskDetailsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Teams' ? Array < TeamsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? TasksCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'TaskGroups' ? TaskGroupsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'Reports' ? Array < ReportsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Statistics' ? Array < StatisticsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'TaskDetails' ? Array < TaskDetailsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Teams' ? Array < TeamsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? TasksCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Tasks ? Tasks[P] : never
  } 
    : Tasks
  : Tasks


  type TasksCountArgs = Merge<
    Omit<TasksFindManyArgs, 'select' | 'include'> & {
      select?: TasksCountAggregateInputType | true
    }
  >

  export interface TasksDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Tasks that matches the filter.
     * @param {TasksFindUniqueArgs} args - Arguments to find a Tasks
     * @example
     * // Get one Tasks
     * const tasks = await prisma.tasks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TasksFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TasksFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Tasks'> extends True ? CheckSelect<T, Prisma__TasksClient<Tasks>, Prisma__TasksClient<TasksGetPayload<T>>> : CheckSelect<T, Prisma__TasksClient<Tasks | null, null>, Prisma__TasksClient<TasksGetPayload<T> | null, null>>

    /**
     * Find the first Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksFindFirstArgs} args - Arguments to find a Tasks
     * @example
     * // Get one Tasks
     * const tasks = await prisma.tasks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TasksFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TasksFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Tasks'> extends True ? CheckSelect<T, Prisma__TasksClient<Tasks>, Prisma__TasksClient<TasksGetPayload<T>>> : CheckSelect<T, Prisma__TasksClient<Tasks | null, null>, Prisma__TasksClient<TasksGetPayload<T> | null, null>>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.tasks.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.tasks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tasksWithIdOnly = await prisma.tasks.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TasksFindManyArgs>(
      args?: SelectSubset<T, TasksFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Tasks>>, PrismaPromise<Array<TasksGetPayload<T>>>>

    /**
     * Create a Tasks.
     * @param {TasksCreateArgs} args - Arguments to create a Tasks.
     * @example
     * // Create one Tasks
     * const Tasks = await prisma.tasks.create({
     *   data: {
     *     // ... data to create a Tasks
     *   }
     * })
     * 
    **/
    create<T extends TasksCreateArgs>(
      args: SelectSubset<T, TasksCreateArgs>
    ): CheckSelect<T, Prisma__TasksClient<Tasks>, Prisma__TasksClient<TasksGetPayload<T>>>

    /**
     * Create many Tasks.
     *     @param {TasksCreateManyArgs} args - Arguments to create many Tasks.
     *     @example
     *     // Create many Tasks
     *     const tasks = await prisma.tasks.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TasksCreateManyArgs>(
      args?: SelectSubset<T, TasksCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Tasks.
     * @param {TasksDeleteArgs} args - Arguments to delete one Tasks.
     * @example
     * // Delete one Tasks
     * const Tasks = await prisma.tasks.delete({
     *   where: {
     *     // ... filter to delete one Tasks
     *   }
     * })
     * 
    **/
    delete<T extends TasksDeleteArgs>(
      args: SelectSubset<T, TasksDeleteArgs>
    ): CheckSelect<T, Prisma__TasksClient<Tasks>, Prisma__TasksClient<TasksGetPayload<T>>>

    /**
     * Update one Tasks.
     * @param {TasksUpdateArgs} args - Arguments to update one Tasks.
     * @example
     * // Update one Tasks
     * const tasks = await prisma.tasks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TasksUpdateArgs>(
      args: SelectSubset<T, TasksUpdateArgs>
    ): CheckSelect<T, Prisma__TasksClient<Tasks>, Prisma__TasksClient<TasksGetPayload<T>>>

    /**
     * Delete zero or more Tasks.
     * @param {TasksDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.tasks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TasksDeleteManyArgs>(
      args?: SelectSubset<T, TasksDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const tasks = await prisma.tasks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TasksUpdateManyArgs>(
      args: SelectSubset<T, TasksUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Tasks.
     * @param {TasksUpsertArgs} args - Arguments to update or create a Tasks.
     * @example
     * // Update or create a Tasks
     * const tasks = await prisma.tasks.upsert({
     *   create: {
     *     // ... data to create a Tasks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tasks we want to update
     *   }
     * })
    **/
    upsert<T extends TasksUpsertArgs>(
      args: SelectSubset<T, TasksUpsertArgs>
    ): CheckSelect<T, Prisma__TasksClient<Tasks>, Prisma__TasksClient<TasksGetPayload<T>>>

    /**
     * Find one Tasks that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {TasksFindUniqueOrThrowArgs} args - Arguments to find a Tasks
     * @example
     * // Get one Tasks
     * const tasks = await prisma.tasks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TasksFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TasksFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__TasksClient<Tasks>, Prisma__TasksClient<TasksGetPayload<T>>>

    /**
     * Find the first Tasks that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksFindFirstOrThrowArgs} args - Arguments to find a Tasks
     * @example
     * // Get one Tasks
     * const tasks = await prisma.tasks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TasksFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TasksFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__TasksClient<Tasks>, Prisma__TasksClient<TasksGetPayload<T>>>

    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.tasks.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TasksCountArgs>(
      args?: Subset<T, TasksCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TasksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TasksAggregateArgs>(args: Subset<T, TasksAggregateArgs>): PrismaPromise<GetTasksAggregateType<T>>

    /**
     * Group by Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TasksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TasksGroupByArgs['orderBy'] }
        : { orderBy?: TasksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TasksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTasksGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Tasks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TasksClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Accounts<T extends AccountsArgs = {}>(args?: Subset<T, AccountsArgs>): CheckSelect<T, Prisma__AccountsClient<Accounts | Null>, Prisma__AccountsClient<AccountsGetPayload<T> | Null>>;

    TaskGroups<T extends TaskGroupsArgs = {}>(args?: Subset<T, TaskGroupsArgs>): CheckSelect<T, Prisma__TaskGroupsClient<TaskGroups | Null>, Prisma__TaskGroupsClient<TaskGroupsGetPayload<T> | Null>>;

    Reports<T extends ReportsFindManyArgs = {}>(args?: Subset<T, ReportsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Reports>| Null>, PrismaPromise<Array<ReportsGetPayload<T>>| Null>>;

    Statistics<T extends StatisticsFindManyArgs = {}>(args?: Subset<T, StatisticsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Statistics>| Null>, PrismaPromise<Array<StatisticsGetPayload<T>>| Null>>;

    TaskDetails<T extends TaskDetailsFindManyArgs = {}>(args?: Subset<T, TaskDetailsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<TaskDetails>| Null>, PrismaPromise<Array<TaskDetailsGetPayload<T>>| Null>>;

    Teams<T extends TeamsFindManyArgs = {}>(args?: Subset<T, TeamsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Teams>| Null>, PrismaPromise<Array<TeamsGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Tasks base type for findUnique actions
   */
  export type TasksFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Tasks
     * 
    **/
    select?: TasksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TasksInclude | null
    /**
     * Filter, which Tasks to fetch.
     * 
    **/
    where: TasksWhereUniqueInput
  }

  /**
   * Tasks: findUnique
   */
  export interface TasksFindUniqueArgs extends TasksFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tasks base type for findFirst actions
   */
  export type TasksFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Tasks
     * 
    **/
    select?: TasksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TasksInclude | null
    /**
     * Filter, which Tasks to fetch.
     * 
    **/
    where?: TasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     * 
    **/
    orderBy?: Enumerable<TasksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     * 
    **/
    cursor?: TasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     * 
    **/
    distinct?: Enumerable<TasksScalarFieldEnum>
  }

  /**
   * Tasks: findFirst
   */
  export interface TasksFindFirstArgs extends TasksFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tasks findMany
   */
  export type TasksFindManyArgs = {
    /**
     * Select specific fields to fetch from the Tasks
     * 
    **/
    select?: TasksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TasksInclude | null
    /**
     * Filter, which Tasks to fetch.
     * 
    **/
    where?: TasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     * 
    **/
    orderBy?: Enumerable<TasksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     * 
    **/
    cursor?: TasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TasksScalarFieldEnum>
  }


  /**
   * Tasks create
   */
  export type TasksCreateArgs = {
    /**
     * Select specific fields to fetch from the Tasks
     * 
    **/
    select?: TasksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TasksInclude | null
    /**
     * The data needed to create a Tasks.
     * 
    **/
    data: XOR<TasksCreateInput, TasksUncheckedCreateInput>
  }


  /**
   * Tasks createMany
   */
  export type TasksCreateManyArgs = {
    /**
     * The data used to create many Tasks.
     * 
    **/
    data: Enumerable<TasksCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Tasks update
   */
  export type TasksUpdateArgs = {
    /**
     * Select specific fields to fetch from the Tasks
     * 
    **/
    select?: TasksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TasksInclude | null
    /**
     * The data needed to update a Tasks.
     * 
    **/
    data: XOR<TasksUpdateInput, TasksUncheckedUpdateInput>
    /**
     * Choose, which Tasks to update.
     * 
    **/
    where: TasksWhereUniqueInput
  }


  /**
   * Tasks updateMany
   */
  export type TasksUpdateManyArgs = {
    /**
     * The data used to update Tasks.
     * 
    **/
    data: XOR<TasksUpdateManyMutationInput, TasksUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     * 
    **/
    where?: TasksWhereInput
  }


  /**
   * Tasks upsert
   */
  export type TasksUpsertArgs = {
    /**
     * Select specific fields to fetch from the Tasks
     * 
    **/
    select?: TasksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TasksInclude | null
    /**
     * The filter to search for the Tasks to update in case it exists.
     * 
    **/
    where: TasksWhereUniqueInput
    /**
     * In case the Tasks found by the `where` argument doesn't exist, create a new Tasks with this data.
     * 
    **/
    create: XOR<TasksCreateInput, TasksUncheckedCreateInput>
    /**
     * In case the Tasks was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TasksUpdateInput, TasksUncheckedUpdateInput>
  }


  /**
   * Tasks delete
   */
  export type TasksDeleteArgs = {
    /**
     * Select specific fields to fetch from the Tasks
     * 
    **/
    select?: TasksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TasksInclude | null
    /**
     * Filter which Tasks to delete.
     * 
    **/
    where: TasksWhereUniqueInput
  }


  /**
   * Tasks deleteMany
   */
  export type TasksDeleteManyArgs = {
    /**
     * Filter which Tasks to delete
     * 
    **/
    where?: TasksWhereInput
  }


  /**
   * Tasks: findUniqueOrThrow
   */
  export type TasksFindUniqueOrThrowArgs = TasksFindUniqueArgsBase
      

  /**
   * Tasks: findFirstOrThrow
   */
  export type TasksFindFirstOrThrowArgs = TasksFindFirstArgsBase
      

  /**
   * Tasks without action
   */
  export type TasksArgs = {
    /**
     * Select specific fields to fetch from the Tasks
     * 
    **/
    select?: TasksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TasksInclude | null
  }



  /**
   * Model TeamAgents
   */


  export type AggregateTeamAgents = {
    _count: TeamAgentsCountAggregateOutputType | null
    _avg: TeamAgentsAvgAggregateOutputType | null
    _sum: TeamAgentsSumAggregateOutputType | null
    _min: TeamAgentsMinAggregateOutputType | null
    _max: TeamAgentsMaxAggregateOutputType | null
  }

  export type TeamAgentsAvgAggregateOutputType = {
    AgentId: number | null
    TeamId: number | null
  }

  export type TeamAgentsSumAggregateOutputType = {
    AgentId: number | null
    TeamId: number | null
  }

  export type TeamAgentsMinAggregateOutputType = {
    AgentId: number | null
    TeamId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamAgentsMaxAggregateOutputType = {
    AgentId: number | null
    TeamId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamAgentsCountAggregateOutputType = {
    AgentId: number
    TeamId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamAgentsAvgAggregateInputType = {
    AgentId?: true
    TeamId?: true
  }

  export type TeamAgentsSumAggregateInputType = {
    AgentId?: true
    TeamId?: true
  }

  export type TeamAgentsMinAggregateInputType = {
    AgentId?: true
    TeamId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamAgentsMaxAggregateInputType = {
    AgentId?: true
    TeamId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamAgentsCountAggregateInputType = {
    AgentId?: true
    TeamId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamAgentsAggregateArgs = {
    /**
     * Filter which TeamAgents to aggregate.
     * 
    **/
    where?: TeamAgentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamAgents to fetch.
     * 
    **/
    orderBy?: Enumerable<TeamAgentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TeamAgentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamAgents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamAgents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamAgents
    **/
    _count?: true | TeamAgentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamAgentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamAgentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamAgentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamAgentsMaxAggregateInputType
  }

  export type GetTeamAgentsAggregateType<T extends TeamAgentsAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamAgents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamAgents[P]>
      : GetScalarType<T[P], AggregateTeamAgents[P]>
  }




  export type TeamAgentsGroupByArgs = {
    where?: TeamAgentsWhereInput
    orderBy?: Enumerable<TeamAgentsOrderByWithAggregationInput>
    by: Array<TeamAgentsScalarFieldEnum>
    having?: TeamAgentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamAgentsCountAggregateInputType | true
    _avg?: TeamAgentsAvgAggregateInputType
    _sum?: TeamAgentsSumAggregateInputType
    _min?: TeamAgentsMinAggregateInputType
    _max?: TeamAgentsMaxAggregateInputType
  }


  export type TeamAgentsGroupByOutputType = {
    AgentId: number
    TeamId: number
    isActive: boolean | null
    createdAt: Date
    updatedAt: Date
    _count: TeamAgentsCountAggregateOutputType | null
    _avg: TeamAgentsAvgAggregateOutputType | null
    _sum: TeamAgentsSumAggregateOutputType | null
    _min: TeamAgentsMinAggregateOutputType | null
    _max: TeamAgentsMaxAggregateOutputType | null
  }

  type GetTeamAgentsGroupByPayload<T extends TeamAgentsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TeamAgentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamAgentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamAgentsGroupByOutputType[P]>
            : GetScalarType<T[P], TeamAgentsGroupByOutputType[P]>
        }
      >
    >


  export type TeamAgentsSelect = {
    AgentId?: boolean
    TeamId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Accounts?: boolean | AccountsArgs
    Teams?: boolean | TeamsArgs
  }

  export type TeamAgentsInclude = {
    Accounts?: boolean | AccountsArgs
    Teams?: boolean | TeamsArgs
  }

  export type TeamAgentsGetPayload<
    S extends boolean | null | undefined | TeamAgentsArgs,
    U = keyof S
      > = S extends true
        ? TeamAgents
    : S extends undefined
    ? never
    : S extends TeamAgentsArgs | TeamAgentsFindManyArgs
    ?'include' extends U
    ? TeamAgents  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'Teams' ? TeamsGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Accounts' ? AccountsGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'Teams' ? TeamsGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof TeamAgents ? TeamAgents[P] : never
  } 
    : TeamAgents
  : TeamAgents


  type TeamAgentsCountArgs = Merge<
    Omit<TeamAgentsFindManyArgs, 'select' | 'include'> & {
      select?: TeamAgentsCountAggregateInputType | true
    }
  >

  export interface TeamAgentsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one TeamAgents that matches the filter.
     * @param {TeamAgentsFindUniqueArgs} args - Arguments to find a TeamAgents
     * @example
     * // Get one TeamAgents
     * const teamAgents = await prisma.teamAgents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeamAgentsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TeamAgentsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TeamAgents'> extends True ? CheckSelect<T, Prisma__TeamAgentsClient<TeamAgents>, Prisma__TeamAgentsClient<TeamAgentsGetPayload<T>>> : CheckSelect<T, Prisma__TeamAgentsClient<TeamAgents | null, null>, Prisma__TeamAgentsClient<TeamAgentsGetPayload<T> | null, null>>

    /**
     * Find the first TeamAgents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAgentsFindFirstArgs} args - Arguments to find a TeamAgents
     * @example
     * // Get one TeamAgents
     * const teamAgents = await prisma.teamAgents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeamAgentsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TeamAgentsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TeamAgents'> extends True ? CheckSelect<T, Prisma__TeamAgentsClient<TeamAgents>, Prisma__TeamAgentsClient<TeamAgentsGetPayload<T>>> : CheckSelect<T, Prisma__TeamAgentsClient<TeamAgents | null, null>, Prisma__TeamAgentsClient<TeamAgentsGetPayload<T> | null, null>>

    /**
     * Find zero or more TeamAgents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAgentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamAgents
     * const teamAgents = await prisma.teamAgents.findMany()
     * 
     * // Get first 10 TeamAgents
     * const teamAgents = await prisma.teamAgents.findMany({ take: 10 })
     * 
     * // Only select the `AgentId`
     * const teamAgentsWithAgentIdOnly = await prisma.teamAgents.findMany({ select: { AgentId: true } })
     * 
    **/
    findMany<T extends TeamAgentsFindManyArgs>(
      args?: SelectSubset<T, TeamAgentsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TeamAgents>>, PrismaPromise<Array<TeamAgentsGetPayload<T>>>>

    /**
     * Create a TeamAgents.
     * @param {TeamAgentsCreateArgs} args - Arguments to create a TeamAgents.
     * @example
     * // Create one TeamAgents
     * const TeamAgents = await prisma.teamAgents.create({
     *   data: {
     *     // ... data to create a TeamAgents
     *   }
     * })
     * 
    **/
    create<T extends TeamAgentsCreateArgs>(
      args: SelectSubset<T, TeamAgentsCreateArgs>
    ): CheckSelect<T, Prisma__TeamAgentsClient<TeamAgents>, Prisma__TeamAgentsClient<TeamAgentsGetPayload<T>>>

    /**
     * Create many TeamAgents.
     *     @param {TeamAgentsCreateManyArgs} args - Arguments to create many TeamAgents.
     *     @example
     *     // Create many TeamAgents
     *     const teamAgents = await prisma.teamAgents.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TeamAgentsCreateManyArgs>(
      args?: SelectSubset<T, TeamAgentsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TeamAgents.
     * @param {TeamAgentsDeleteArgs} args - Arguments to delete one TeamAgents.
     * @example
     * // Delete one TeamAgents
     * const TeamAgents = await prisma.teamAgents.delete({
     *   where: {
     *     // ... filter to delete one TeamAgents
     *   }
     * })
     * 
    **/
    delete<T extends TeamAgentsDeleteArgs>(
      args: SelectSubset<T, TeamAgentsDeleteArgs>
    ): CheckSelect<T, Prisma__TeamAgentsClient<TeamAgents>, Prisma__TeamAgentsClient<TeamAgentsGetPayload<T>>>

    /**
     * Update one TeamAgents.
     * @param {TeamAgentsUpdateArgs} args - Arguments to update one TeamAgents.
     * @example
     * // Update one TeamAgents
     * const teamAgents = await prisma.teamAgents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeamAgentsUpdateArgs>(
      args: SelectSubset<T, TeamAgentsUpdateArgs>
    ): CheckSelect<T, Prisma__TeamAgentsClient<TeamAgents>, Prisma__TeamAgentsClient<TeamAgentsGetPayload<T>>>

    /**
     * Delete zero or more TeamAgents.
     * @param {TeamAgentsDeleteManyArgs} args - Arguments to filter TeamAgents to delete.
     * @example
     * // Delete a few TeamAgents
     * const { count } = await prisma.teamAgents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeamAgentsDeleteManyArgs>(
      args?: SelectSubset<T, TeamAgentsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAgentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamAgents
     * const teamAgents = await prisma.teamAgents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeamAgentsUpdateManyArgs>(
      args: SelectSubset<T, TeamAgentsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TeamAgents.
     * @param {TeamAgentsUpsertArgs} args - Arguments to update or create a TeamAgents.
     * @example
     * // Update or create a TeamAgents
     * const teamAgents = await prisma.teamAgents.upsert({
     *   create: {
     *     // ... data to create a TeamAgents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamAgents we want to update
     *   }
     * })
    **/
    upsert<T extends TeamAgentsUpsertArgs>(
      args: SelectSubset<T, TeamAgentsUpsertArgs>
    ): CheckSelect<T, Prisma__TeamAgentsClient<TeamAgents>, Prisma__TeamAgentsClient<TeamAgentsGetPayload<T>>>

    /**
     * Find one TeamAgents that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {TeamAgentsFindUniqueOrThrowArgs} args - Arguments to find a TeamAgents
     * @example
     * // Get one TeamAgents
     * const teamAgents = await prisma.teamAgents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TeamAgentsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TeamAgentsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__TeamAgentsClient<TeamAgents>, Prisma__TeamAgentsClient<TeamAgentsGetPayload<T>>>

    /**
     * Find the first TeamAgents that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAgentsFindFirstOrThrowArgs} args - Arguments to find a TeamAgents
     * @example
     * // Get one TeamAgents
     * const teamAgents = await prisma.teamAgents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TeamAgentsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TeamAgentsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__TeamAgentsClient<TeamAgents>, Prisma__TeamAgentsClient<TeamAgentsGetPayload<T>>>

    /**
     * Count the number of TeamAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAgentsCountArgs} args - Arguments to filter TeamAgents to count.
     * @example
     * // Count the number of TeamAgents
     * const count = await prisma.teamAgents.count({
     *   where: {
     *     // ... the filter for the TeamAgents we want to count
     *   }
     * })
    **/
    count<T extends TeamAgentsCountArgs>(
      args?: Subset<T, TeamAgentsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamAgentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAgentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAgentsAggregateArgs>(args: Subset<T, TeamAgentsAggregateArgs>): PrismaPromise<GetTeamAgentsAggregateType<T>>

    /**
     * Group by TeamAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAgentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamAgentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamAgentsGroupByArgs['orderBy'] }
        : { orderBy?: TeamAgentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamAgentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamAgentsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamAgents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TeamAgentsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Accounts<T extends AccountsArgs = {}>(args?: Subset<T, AccountsArgs>): CheckSelect<T, Prisma__AccountsClient<Accounts | Null>, Prisma__AccountsClient<AccountsGetPayload<T> | Null>>;

    Teams<T extends TeamsArgs = {}>(args?: Subset<T, TeamsArgs>): CheckSelect<T, Prisma__TeamsClient<Teams | Null>, Prisma__TeamsClient<TeamsGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TeamAgents base type for findUnique actions
   */
  export type TeamAgentsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TeamAgents
     * 
    **/
    select?: TeamAgentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamAgentsInclude | null
    /**
     * Filter, which TeamAgents to fetch.
     * 
    **/
    where: TeamAgentsWhereUniqueInput
  }

  /**
   * TeamAgents: findUnique
   */
  export interface TeamAgentsFindUniqueArgs extends TeamAgentsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TeamAgents base type for findFirst actions
   */
  export type TeamAgentsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TeamAgents
     * 
    **/
    select?: TeamAgentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamAgentsInclude | null
    /**
     * Filter, which TeamAgents to fetch.
     * 
    **/
    where?: TeamAgentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamAgents to fetch.
     * 
    **/
    orderBy?: Enumerable<TeamAgentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamAgents.
     * 
    **/
    cursor?: TeamAgentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamAgents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamAgents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamAgents.
     * 
    **/
    distinct?: Enumerable<TeamAgentsScalarFieldEnum>
  }

  /**
   * TeamAgents: findFirst
   */
  export interface TeamAgentsFindFirstArgs extends TeamAgentsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TeamAgents findMany
   */
  export type TeamAgentsFindManyArgs = {
    /**
     * Select specific fields to fetch from the TeamAgents
     * 
    **/
    select?: TeamAgentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamAgentsInclude | null
    /**
     * Filter, which TeamAgents to fetch.
     * 
    **/
    where?: TeamAgentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamAgents to fetch.
     * 
    **/
    orderBy?: Enumerable<TeamAgentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamAgents.
     * 
    **/
    cursor?: TeamAgentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamAgents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamAgents.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TeamAgentsScalarFieldEnum>
  }


  /**
   * TeamAgents create
   */
  export type TeamAgentsCreateArgs = {
    /**
     * Select specific fields to fetch from the TeamAgents
     * 
    **/
    select?: TeamAgentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamAgentsInclude | null
    /**
     * The data needed to create a TeamAgents.
     * 
    **/
    data: XOR<TeamAgentsCreateInput, TeamAgentsUncheckedCreateInput>
  }


  /**
   * TeamAgents createMany
   */
  export type TeamAgentsCreateManyArgs = {
    /**
     * The data used to create many TeamAgents.
     * 
    **/
    data: Enumerable<TeamAgentsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TeamAgents update
   */
  export type TeamAgentsUpdateArgs = {
    /**
     * Select specific fields to fetch from the TeamAgents
     * 
    **/
    select?: TeamAgentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamAgentsInclude | null
    /**
     * The data needed to update a TeamAgents.
     * 
    **/
    data: XOR<TeamAgentsUpdateInput, TeamAgentsUncheckedUpdateInput>
    /**
     * Choose, which TeamAgents to update.
     * 
    **/
    where: TeamAgentsWhereUniqueInput
  }


  /**
   * TeamAgents updateMany
   */
  export type TeamAgentsUpdateManyArgs = {
    /**
     * The data used to update TeamAgents.
     * 
    **/
    data: XOR<TeamAgentsUpdateManyMutationInput, TeamAgentsUncheckedUpdateManyInput>
    /**
     * Filter which TeamAgents to update
     * 
    **/
    where?: TeamAgentsWhereInput
  }


  /**
   * TeamAgents upsert
   */
  export type TeamAgentsUpsertArgs = {
    /**
     * Select specific fields to fetch from the TeamAgents
     * 
    **/
    select?: TeamAgentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamAgentsInclude | null
    /**
     * The filter to search for the TeamAgents to update in case it exists.
     * 
    **/
    where: TeamAgentsWhereUniqueInput
    /**
     * In case the TeamAgents found by the `where` argument doesn't exist, create a new TeamAgents with this data.
     * 
    **/
    create: XOR<TeamAgentsCreateInput, TeamAgentsUncheckedCreateInput>
    /**
     * In case the TeamAgents was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TeamAgentsUpdateInput, TeamAgentsUncheckedUpdateInput>
  }


  /**
   * TeamAgents delete
   */
  export type TeamAgentsDeleteArgs = {
    /**
     * Select specific fields to fetch from the TeamAgents
     * 
    **/
    select?: TeamAgentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamAgentsInclude | null
    /**
     * Filter which TeamAgents to delete.
     * 
    **/
    where: TeamAgentsWhereUniqueInput
  }


  /**
   * TeamAgents deleteMany
   */
  export type TeamAgentsDeleteManyArgs = {
    /**
     * Filter which TeamAgents to delete
     * 
    **/
    where?: TeamAgentsWhereInput
  }


  /**
   * TeamAgents: findUniqueOrThrow
   */
  export type TeamAgentsFindUniqueOrThrowArgs = TeamAgentsFindUniqueArgsBase
      

  /**
   * TeamAgents: findFirstOrThrow
   */
  export type TeamAgentsFindFirstOrThrowArgs = TeamAgentsFindFirstArgsBase
      

  /**
   * TeamAgents without action
   */
  export type TeamAgentsArgs = {
    /**
     * Select specific fields to fetch from the TeamAgents
     * 
    **/
    select?: TeamAgentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamAgentsInclude | null
  }



  /**
   * Model Teams
   */


  export type AggregateTeams = {
    _count: TeamsCountAggregateOutputType | null
    _avg: TeamsAvgAggregateOutputType | null
    _sum: TeamsSumAggregateOutputType | null
    _min: TeamsMinAggregateOutputType | null
    _max: TeamsMaxAggregateOutputType | null
  }

  export type TeamsAvgAggregateOutputType = {
    id: number | null
    AccountId: number | null
    AgentId: number | null
    TaskId: number | null
    area: Decimal | null
  }

  export type TeamsSumAggregateOutputType = {
    id: number | null
    AccountId: number | null
    AgentId: number | null
    TaskId: number | null
    area: Decimal | null
  }

  export type TeamsMinAggregateOutputType = {
    id: number | null
    name: string | null
    AccountId: number | null
    AgentId: number | null
    TaskId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
    area: Decimal | null
    alias: string | null
  }

  export type TeamsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    AccountId: number | null
    AgentId: number | null
    TaskId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
    area: Decimal | null
    alias: string | null
  }

  export type TeamsCountAggregateOutputType = {
    id: number
    name: number
    AccountId: number
    AgentId: number
    TaskId: number
    createdAt: number
    updatedAt: number
    status: number
    area: number
    alias: number
    _all: number
  }


  export type TeamsAvgAggregateInputType = {
    id?: true
    AccountId?: true
    AgentId?: true
    TaskId?: true
    area?: true
  }

  export type TeamsSumAggregateInputType = {
    id?: true
    AccountId?: true
    AgentId?: true
    TaskId?: true
    area?: true
  }

  export type TeamsMinAggregateInputType = {
    id?: true
    name?: true
    AccountId?: true
    AgentId?: true
    TaskId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    area?: true
    alias?: true
  }

  export type TeamsMaxAggregateInputType = {
    id?: true
    name?: true
    AccountId?: true
    AgentId?: true
    TaskId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    area?: true
    alias?: true
  }

  export type TeamsCountAggregateInputType = {
    id?: true
    name?: true
    AccountId?: true
    AgentId?: true
    TaskId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    area?: true
    alias?: true
    _all?: true
  }

  export type TeamsAggregateArgs = {
    /**
     * Filter which Teams to aggregate.
     * 
    **/
    where?: TeamsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     * 
    **/
    orderBy?: Enumerable<TeamsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TeamsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamsMaxAggregateInputType
  }

  export type GetTeamsAggregateType<T extends TeamsAggregateArgs> = {
        [P in keyof T & keyof AggregateTeams]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeams[P]>
      : GetScalarType<T[P], AggregateTeams[P]>
  }




  export type TeamsGroupByArgs = {
    where?: TeamsWhereInput
    orderBy?: Enumerable<TeamsOrderByWithAggregationInput>
    by: Array<TeamsScalarFieldEnum>
    having?: TeamsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamsCountAggregateInputType | true
    _avg?: TeamsAvgAggregateInputType
    _sum?: TeamsSumAggregateInputType
    _min?: TeamsMinAggregateInputType
    _max?: TeamsMaxAggregateInputType
  }


  export type TeamsGroupByOutputType = {
    id: number
    name: string | null
    AccountId: number | null
    AgentId: number | null
    TaskId: number | null
    createdAt: Date
    updatedAt: Date
    status: string | null
    area: Decimal | null
    alias: string | null
    _count: TeamsCountAggregateOutputType | null
    _avg: TeamsAvgAggregateOutputType | null
    _sum: TeamsSumAggregateOutputType | null
    _min: TeamsMinAggregateOutputType | null
    _max: TeamsMaxAggregateOutputType | null
  }

  type GetTeamsGroupByPayload<T extends TeamsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TeamsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamsGroupByOutputType[P]>
            : GetScalarType<T[P], TeamsGroupByOutputType[P]>
        }
      >
    >


  export type TeamsSelect = {
    id?: boolean
    name?: boolean
    AccountId?: boolean
    AgentId?: boolean
    TaskId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    area?: boolean
    alias?: boolean
    Accounts_AccountsToTeams_AccountId?: boolean | AccountsArgs
    Accounts_AccountsToTeams_AgentId?: boolean | AccountsArgs
    Tasks?: boolean | TasksArgs
    Statistics?: boolean | StatisticsFindManyArgs
    TaskDetails?: boolean | TaskDetailsFindManyArgs
    TeamAgents?: boolean | TeamAgentsFindManyArgs
    _count?: boolean | TeamsCountOutputTypeArgs
  }

  export type TeamsInclude = {
    Accounts_AccountsToTeams_AccountId?: boolean | AccountsArgs
    Accounts_AccountsToTeams_AgentId?: boolean | AccountsArgs
    Tasks?: boolean | TasksArgs
    Statistics?: boolean | StatisticsFindManyArgs
    TaskDetails?: boolean | TaskDetailsFindManyArgs
    TeamAgents?: boolean | TeamAgentsFindManyArgs
    _count?: boolean | TeamsCountOutputTypeArgs
  }

  export type TeamsGetPayload<
    S extends boolean | null | undefined | TeamsArgs,
    U = keyof S
      > = S extends true
        ? Teams
    : S extends undefined
    ? never
    : S extends TeamsArgs | TeamsFindManyArgs
    ?'include' extends U
    ? Teams  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Accounts_AccountsToTeams_AccountId' ? AccountsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'Accounts_AccountsToTeams_AgentId' ? AccountsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'Tasks' ? TasksGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'Statistics' ? Array < StatisticsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'TaskDetails' ? Array < TaskDetailsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'TeamAgents' ? Array < TeamAgentsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? TeamsCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Accounts_AccountsToTeams_AccountId' ? AccountsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'Accounts_AccountsToTeams_AgentId' ? AccountsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'Tasks' ? TasksGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'Statistics' ? Array < StatisticsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'TaskDetails' ? Array < TaskDetailsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'TeamAgents' ? Array < TeamAgentsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? TeamsCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Teams ? Teams[P] : never
  } 
    : Teams
  : Teams


  type TeamsCountArgs = Merge<
    Omit<TeamsFindManyArgs, 'select' | 'include'> & {
      select?: TeamsCountAggregateInputType | true
    }
  >

  export interface TeamsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Teams that matches the filter.
     * @param {TeamsFindUniqueArgs} args - Arguments to find a Teams
     * @example
     * // Get one Teams
     * const teams = await prisma.teams.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeamsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TeamsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Teams'> extends True ? CheckSelect<T, Prisma__TeamsClient<Teams>, Prisma__TeamsClient<TeamsGetPayload<T>>> : CheckSelect<T, Prisma__TeamsClient<Teams | null, null>, Prisma__TeamsClient<TeamsGetPayload<T> | null, null>>

    /**
     * Find the first Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamsFindFirstArgs} args - Arguments to find a Teams
     * @example
     * // Get one Teams
     * const teams = await prisma.teams.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeamsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TeamsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Teams'> extends True ? CheckSelect<T, Prisma__TeamsClient<Teams>, Prisma__TeamsClient<TeamsGetPayload<T>>> : CheckSelect<T, Prisma__TeamsClient<Teams | null, null>, Prisma__TeamsClient<TeamsGetPayload<T> | null, null>>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.teams.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.teams.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamsWithIdOnly = await prisma.teams.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TeamsFindManyArgs>(
      args?: SelectSubset<T, TeamsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Teams>>, PrismaPromise<Array<TeamsGetPayload<T>>>>

    /**
     * Create a Teams.
     * @param {TeamsCreateArgs} args - Arguments to create a Teams.
     * @example
     * // Create one Teams
     * const Teams = await prisma.teams.create({
     *   data: {
     *     // ... data to create a Teams
     *   }
     * })
     * 
    **/
    create<T extends TeamsCreateArgs>(
      args: SelectSubset<T, TeamsCreateArgs>
    ): CheckSelect<T, Prisma__TeamsClient<Teams>, Prisma__TeamsClient<TeamsGetPayload<T>>>

    /**
     * Create many Teams.
     *     @param {TeamsCreateManyArgs} args - Arguments to create many Teams.
     *     @example
     *     // Create many Teams
     *     const teams = await prisma.teams.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TeamsCreateManyArgs>(
      args?: SelectSubset<T, TeamsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Teams.
     * @param {TeamsDeleteArgs} args - Arguments to delete one Teams.
     * @example
     * // Delete one Teams
     * const Teams = await prisma.teams.delete({
     *   where: {
     *     // ... filter to delete one Teams
     *   }
     * })
     * 
    **/
    delete<T extends TeamsDeleteArgs>(
      args: SelectSubset<T, TeamsDeleteArgs>
    ): CheckSelect<T, Prisma__TeamsClient<Teams>, Prisma__TeamsClient<TeamsGetPayload<T>>>

    /**
     * Update one Teams.
     * @param {TeamsUpdateArgs} args - Arguments to update one Teams.
     * @example
     * // Update one Teams
     * const teams = await prisma.teams.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeamsUpdateArgs>(
      args: SelectSubset<T, TeamsUpdateArgs>
    ): CheckSelect<T, Prisma__TeamsClient<Teams>, Prisma__TeamsClient<TeamsGetPayload<T>>>

    /**
     * Delete zero or more Teams.
     * @param {TeamsDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.teams.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeamsDeleteManyArgs>(
      args?: SelectSubset<T, TeamsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const teams = await prisma.teams.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeamsUpdateManyArgs>(
      args: SelectSubset<T, TeamsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Teams.
     * @param {TeamsUpsertArgs} args - Arguments to update or create a Teams.
     * @example
     * // Update or create a Teams
     * const teams = await prisma.teams.upsert({
     *   create: {
     *     // ... data to create a Teams
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teams we want to update
     *   }
     * })
    **/
    upsert<T extends TeamsUpsertArgs>(
      args: SelectSubset<T, TeamsUpsertArgs>
    ): CheckSelect<T, Prisma__TeamsClient<Teams>, Prisma__TeamsClient<TeamsGetPayload<T>>>

    /**
     * Find one Teams that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {TeamsFindUniqueOrThrowArgs} args - Arguments to find a Teams
     * @example
     * // Get one Teams
     * const teams = await prisma.teams.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TeamsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TeamsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__TeamsClient<Teams>, Prisma__TeamsClient<TeamsGetPayload<T>>>

    /**
     * Find the first Teams that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamsFindFirstOrThrowArgs} args - Arguments to find a Teams
     * @example
     * // Get one Teams
     * const teams = await prisma.teams.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TeamsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TeamsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__TeamsClient<Teams>, Prisma__TeamsClient<TeamsGetPayload<T>>>

    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamsCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.teams.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamsCountArgs>(
      args?: Subset<T, TeamsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamsAggregateArgs>(args: Subset<T, TeamsAggregateArgs>): PrismaPromise<GetTeamsAggregateType<T>>

    /**
     * Group by Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamsGroupByArgs['orderBy'] }
        : { orderBy?: TeamsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Teams.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TeamsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Accounts_AccountsToTeams_AccountId<T extends AccountsArgs = {}>(args?: Subset<T, AccountsArgs>): CheckSelect<T, Prisma__AccountsClient<Accounts | Null>, Prisma__AccountsClient<AccountsGetPayload<T> | Null>>;

    Accounts_AccountsToTeams_AgentId<T extends AccountsArgs = {}>(args?: Subset<T, AccountsArgs>): CheckSelect<T, Prisma__AccountsClient<Accounts | Null>, Prisma__AccountsClient<AccountsGetPayload<T> | Null>>;

    Tasks<T extends TasksArgs = {}>(args?: Subset<T, TasksArgs>): CheckSelect<T, Prisma__TasksClient<Tasks | Null>, Prisma__TasksClient<TasksGetPayload<T> | Null>>;

    Statistics<T extends StatisticsFindManyArgs = {}>(args?: Subset<T, StatisticsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Statistics>| Null>, PrismaPromise<Array<StatisticsGetPayload<T>>| Null>>;

    TaskDetails<T extends TaskDetailsFindManyArgs = {}>(args?: Subset<T, TaskDetailsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<TaskDetails>| Null>, PrismaPromise<Array<TaskDetailsGetPayload<T>>| Null>>;

    TeamAgents<T extends TeamAgentsFindManyArgs = {}>(args?: Subset<T, TeamAgentsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<TeamAgents>| Null>, PrismaPromise<Array<TeamAgentsGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Teams base type for findUnique actions
   */
  export type TeamsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Teams
     * 
    **/
    select?: TeamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamsInclude | null
    /**
     * Filter, which Teams to fetch.
     * 
    **/
    where: TeamsWhereUniqueInput
  }

  /**
   * Teams: findUnique
   */
  export interface TeamsFindUniqueArgs extends TeamsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Teams base type for findFirst actions
   */
  export type TeamsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Teams
     * 
    **/
    select?: TeamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamsInclude | null
    /**
     * Filter, which Teams to fetch.
     * 
    **/
    where?: TeamsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     * 
    **/
    orderBy?: Enumerable<TeamsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     * 
    **/
    cursor?: TeamsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     * 
    **/
    distinct?: Enumerable<TeamsScalarFieldEnum>
  }

  /**
   * Teams: findFirst
   */
  export interface TeamsFindFirstArgs extends TeamsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Teams findMany
   */
  export type TeamsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Teams
     * 
    **/
    select?: TeamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamsInclude | null
    /**
     * Filter, which Teams to fetch.
     * 
    **/
    where?: TeamsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     * 
    **/
    orderBy?: Enumerable<TeamsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     * 
    **/
    cursor?: TeamsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TeamsScalarFieldEnum>
  }


  /**
   * Teams create
   */
  export type TeamsCreateArgs = {
    /**
     * Select specific fields to fetch from the Teams
     * 
    **/
    select?: TeamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamsInclude | null
    /**
     * The data needed to create a Teams.
     * 
    **/
    data: XOR<TeamsCreateInput, TeamsUncheckedCreateInput>
  }


  /**
   * Teams createMany
   */
  export type TeamsCreateManyArgs = {
    /**
     * The data used to create many Teams.
     * 
    **/
    data: Enumerable<TeamsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Teams update
   */
  export type TeamsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Teams
     * 
    **/
    select?: TeamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamsInclude | null
    /**
     * The data needed to update a Teams.
     * 
    **/
    data: XOR<TeamsUpdateInput, TeamsUncheckedUpdateInput>
    /**
     * Choose, which Teams to update.
     * 
    **/
    where: TeamsWhereUniqueInput
  }


  /**
   * Teams updateMany
   */
  export type TeamsUpdateManyArgs = {
    /**
     * The data used to update Teams.
     * 
    **/
    data: XOR<TeamsUpdateManyMutationInput, TeamsUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     * 
    **/
    where?: TeamsWhereInput
  }


  /**
   * Teams upsert
   */
  export type TeamsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Teams
     * 
    **/
    select?: TeamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamsInclude | null
    /**
     * The filter to search for the Teams to update in case it exists.
     * 
    **/
    where: TeamsWhereUniqueInput
    /**
     * In case the Teams found by the `where` argument doesn't exist, create a new Teams with this data.
     * 
    **/
    create: XOR<TeamsCreateInput, TeamsUncheckedCreateInput>
    /**
     * In case the Teams was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TeamsUpdateInput, TeamsUncheckedUpdateInput>
  }


  /**
   * Teams delete
   */
  export type TeamsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Teams
     * 
    **/
    select?: TeamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamsInclude | null
    /**
     * Filter which Teams to delete.
     * 
    **/
    where: TeamsWhereUniqueInput
  }


  /**
   * Teams deleteMany
   */
  export type TeamsDeleteManyArgs = {
    /**
     * Filter which Teams to delete
     * 
    **/
    where?: TeamsWhereInput
  }


  /**
   * Teams: findUniqueOrThrow
   */
  export type TeamsFindUniqueOrThrowArgs = TeamsFindUniqueArgsBase
      

  /**
   * Teams: findFirstOrThrow
   */
  export type TeamsFindFirstOrThrowArgs = TeamsFindFirstArgsBase
      

  /**
   * Teams without action
   */
  export type TeamsArgs = {
    /**
     * Select specific fields to fetch from the Teams
     * 
    **/
    select?: TeamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamsInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AccountsScalarFieldEnum: {
    id: 'id',
    phone: 'phone',
    verifyToken: 'verifyToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    profile: 'profile',
    isAdmin: 'isAdmin',
    email: 'email',
    password: 'password',
    name: 'name',
    isVerify: 'isVerify',
    isApprove: 'isApprove',
    ServiceKey: 'ServiceKey'
  };

  export type AccountsScalarFieldEnum = (typeof AccountsScalarFieldEnum)[keyof typeof AccountsScalarFieldEnum]


  export const AlertsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    type: 'type',
    category: 'category',
    AccountId: 'AccountId',
    ReferenceId: 'ReferenceId',
    isRead: 'isRead',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    data: 'data'
  };

  export type AlertsScalarFieldEnum = (typeof AlertsScalarFieldEnum)[keyof typeof AlertsScalarFieldEnum]


  export const CareersScalarFieldEnum: {
    id: 'id',
    AccountId: 'AccountId',
    title: 'title',
    startDate: 'startDate',
    endDate: 'endDate',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CareersScalarFieldEnum = (typeof CareersScalarFieldEnum)[keyof typeof CareersScalarFieldEnum]


  export const CouponsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    quantity: 'quantity',
    maxRetry: 'maxRetry',
    unit: 'unit',
    value: 'value',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    createdAt: 'createdAt',
    extra: 'extra',
    updatedAt: 'updatedAt'
  };

  export type CouponsScalarFieldEnum = (typeof CouponsScalarFieldEnum)[keyof typeof CouponsScalarFieldEnum]


  export const CustomerTaskDetailsScalarFieldEnum: {
    id: 'id',
    AccountId: 'AccountId',
    CustomerId: 'CustomerId',
    type: 'type',
    address: 'address',
    villageName: 'villageName',
    category: 'category',
    etc: 'etc',
    geometry: 'geometry',
    x: 'x',
    y: 'y',
    area: 'area',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerTaskDetailsScalarFieldEnum = (typeof CustomerTaskDetailsScalarFieldEnum)[keyof typeof CustomerTaskDetailsScalarFieldEnum]


  export const CustomersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    crops: 'crops',
    AccountId: 'AccountId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomersScalarFieldEnum = (typeof CustomersScalarFieldEnum)[keyof typeof CustomersScalarFieldEnum]


  export const DiscountsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    AccountId: 'AccountId',
    OrderId: 'OrderId',
    CouponId: 'CouponId',
    ProductId: 'ProductId',
    filters: 'filters'
  };

  export type DiscountsScalarFieldEnum = (typeof DiscountsScalarFieldEnum)[keyof typeof DiscountsScalarFieldEnum]


  export const EventsScalarFieldEnum: {
    id: 'id',
    table: 'table',
    action: 'action',
    createdBy: 'createdBy',
    data: 'data',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventsScalarFieldEnum = (typeof EventsScalarFieldEnum)[keyof typeof EventsScalarFieldEnum]


  export const GeosScalarFieldEnum: {
    id: 'id',
    address: 'address',
    geometry: 'geometry',
    x: 'x',
    y: 'y',
    pnu: 'pnu',
    area: 'area',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GeosScalarFieldEnum = (typeof GeosScalarFieldEnum)[keyof typeof GeosScalarFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const LandsScalarFieldEnum: {
    id: 'id',
    AccountId: 'AccountId',
    is_active: 'is_active',
    type: 'type',
    villageName: 'villageName',
    status: 'status',
    geometry: 'geometry',
    x: 'x',
    y: 'y',
    area: 'area',
    extra: 'extra',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LandsScalarFieldEnum = (typeof LandsScalarFieldEnum)[keyof typeof LandsScalarFieldEnum]


  export const NoticesScalarFieldEnum: {
    id: 'id',
    startDate: 'startDate',
    endDate: 'endDate',
    imageURL: 'imageURL',
    externalURL: 'externalURL',
    order: 'order',
    active: 'active',
    deletedDate: 'deletedDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name'
  };

  export type NoticesScalarFieldEnum = (typeof NoticesScalarFieldEnum)[keyof typeof NoticesScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    id: 'id',
    AccountId: 'AccountId',
    fcmToken: 'fcmToken',
    sendedAt: 'sendedAt',
    isSuccess: 'isSuccess',
    failReason: 'failReason',
    eventCode: 'eventCode',
    sendCode: 'sendCode',
    reservationCode: 'reservationCode',
    sendCycleCode: 'sendCycleCode',
    title: 'title',
    message: 'message',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const OrderHistoriesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    payment: 'payment',
    paymentMethod: 'paymentMethod',
    externalUid: 'externalUid',
    customerUid: 'customerUid',
    merchantUid: 'merchantUid',
    reqAmount: 'reqAmount',
    paidAmount: 'paidAmount',
    status: 'status',
    extra: 'extra',
    AccountId: 'AccountId',
    ProductId: 'ProductId',
    OrderId: 'OrderId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderHistoriesScalarFieldEnum = (typeof OrderHistoriesScalarFieldEnum)[keyof typeof OrderHistoriesScalarFieldEnum]


  export const OrdersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    payment: 'payment',
    paymentMethod: 'paymentMethod',
    externalUid: 'externalUid',
    customerUid: 'customerUid',
    merchantUid: 'merchantUid',
    reqAmount: 'reqAmount',
    paidAmount: 'paidAmount',
    status: 'status',
    extra: 'extra',
    AccountId: 'AccountId',
    ProductId: 'ProductId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    expiredAt: 'expiredAt',
    isSubscribe: 'isSubscribe',
    issuedAt: 'issuedAt'
  };

  export type OrdersScalarFieldEnum = (typeof OrdersScalarFieldEnum)[keyof typeof OrdersScalarFieldEnum]


  export const PermissionsScalarFieldEnum: {
    id: 'id',
    resource: 'resource',
    key: 'key',
    resourceId: 'resourceId',
    AccountId: 'AccountId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PermissionsScalarFieldEnum = (typeof PermissionsScalarFieldEnum)[keyof typeof PermissionsScalarFieldEnum]


  export const PostAccountsScalarFieldEnum: {
    id: 'id',
    AccountId: 'AccountId',
    PostId: 'PostId',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PostAccountsScalarFieldEnum = (typeof PostAccountsScalarFieldEnum)[keyof typeof PostAccountsScalarFieldEnum]


  export const PostsScalarFieldEnum: {
    id: 'id',
    category: 'category',
    type: 'type',
    content: 'content',
    unit: 'unit',
    price: 'price',
    location: 'location',
    area: 'area',
    title: 'title',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    viewCount: 'viewCount',
    AccountId: 'AccountId',
    contactName: 'contactName',
    contactPhone: 'contactPhone',
    contactEmail: 'contactEmail',
    qualifications: 'qualifications'
  };

  export type PostsScalarFieldEnum = (typeof PostsScalarFieldEnum)[keyof typeof PostsScalarFieldEnum]


  export const ProductsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    price: 'price',
    duration: 'duration',
    filters: 'filters',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isSubscribe: 'isSubscribe'
  };

  export type ProductsScalarFieldEnum = (typeof ProductsScalarFieldEnum)[keyof typeof ProductsScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const ReportsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isActive: 'isActive',
    isPrivate: 'isPrivate',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    TaskId: 'TaskId',
    AccountId: 'AccountId'
  };

  export type ReportsScalarFieldEnum = (typeof ReportsScalarFieldEnum)[keyof typeof ReportsScalarFieldEnum]


  export const SequelizeMetaScalarFieldEnum: {
    name: 'name'
  };

  export type SequelizeMetaScalarFieldEnum = (typeof SequelizeMetaScalarFieldEnum)[keyof typeof SequelizeMetaScalarFieldEnum]


  export const ServicesScalarFieldEnum: {
    key: 'key',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServicesScalarFieldEnum = (typeof ServicesScalarFieldEnum)[keyof typeof ServicesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const StatisticsScalarFieldEnum: {
    id: 'id',
    AgentId: 'AgentId',
    TeamId: 'TeamId',
    TaskId: 'TaskId',
    dailyWorkload: 'dailyWorkload',
    completedByOwner: 'completedByOwner',
    completedBySelf: 'completedBySelf',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StatisticsScalarFieldEnum = (typeof StatisticsScalarFieldEnum)[keyof typeof StatisticsScalarFieldEnum]


  export const SubscribesScalarFieldEnum: {
    id: 'id',
    AccountId: 'AccountId',
    fcmToken: 'fcmToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscribesScalarFieldEnum = (typeof SubscribesScalarFieldEnum)[keyof typeof SubscribesScalarFieldEnum]


  export const TaskDetailResourcesScalarFieldEnum: {
    id: 'id',
    content: 'content',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    TaskDetailId: 'TaskDetailId',
    AccountId: 'AccountId',
    group: 'group'
  };

  export type TaskDetailResourcesScalarFieldEnum = (typeof TaskDetailResourcesScalarFieldEnum)[keyof typeof TaskDetailResourcesScalarFieldEnum]


  export const TaskDetailsScalarFieldEnum: {
    id: 'id',
    AccountId: 'AccountId',
    TaskId: 'TaskId',
    type: 'type',
    address: 'address',
    villageName: 'villageName',
    pushUser: 'pushUser',
    category: 'category',
    etc: 'etc',
    status: 'status',
    geometry: 'geometry',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    assignedDays: 'assignedDays',
    assignedUser: 'assignedUser',
    TeamId: 'TeamId',
    y: 'y',
    x: 'x',
    area: 'area',
    pushPhone: 'pushPhone',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    memo: 'memo',
    extra: 'extra'
  };

  export type TaskDetailsScalarFieldEnum = (typeof TaskDetailsScalarFieldEnum)[keyof typeof TaskDetailsScalarFieldEnum]


  export const TaskGroupsScalarFieldEnum: {
    id: 'id',
    path: 'path',
    name: 'name',
    status: 'status',
    AccountId: 'AccountId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    area: 'area',
    createType: 'createType',
    extra: 'extra'
  };

  export type TaskGroupsScalarFieldEnum = (typeof TaskGroupsScalarFieldEnum)[keyof typeof TaskGroupsScalarFieldEnum]


  export const TasksScalarFieldEnum: {
    id: 'id',
    name: 'name',
    status: 'status',
    AccountId: 'AccountId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    workingDays: 'workingDays',
    workingTeamsCnt: 'workingTeamsCnt',
    TaskGroupId: 'TaskGroupId',
    startDate: 'startDate',
    endDate: 'endDate',
    area: 'area',
    isPaid: 'isPaid',
    createType: 'createType',
    extra: 'extra',
    real_area: 'real_area'
  };

  export type TasksScalarFieldEnum = (typeof TasksScalarFieldEnum)[keyof typeof TasksScalarFieldEnum]


  export const TeamAgentsScalarFieldEnum: {
    AgentId: 'AgentId',
    TeamId: 'TeamId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamAgentsScalarFieldEnum = (typeof TeamAgentsScalarFieldEnum)[keyof typeof TeamAgentsScalarFieldEnum]


  export const TeamsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    AccountId: 'AccountId',
    AgentId: 'AgentId',
    TaskId: 'TaskId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status',
    area: 'area',
    alias: 'alias'
  };

  export type TeamsScalarFieldEnum = (typeof TeamsScalarFieldEnum)[keyof typeof TeamsScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  /**
   * Deep Input Types
   */


  export type AccountsWhereInput = {
    AND?: Enumerable<AccountsWhereInput>
    OR?: Enumerable<AccountsWhereInput>
    NOT?: Enumerable<AccountsWhereInput>
    id?: IntFilter | number
    phone?: StringNullableFilter | string | null
    verifyToken?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    profile?: JsonNullableFilter
    isAdmin?: BoolNullableFilter | boolean | null
    email?: StringNullableFilter | string | null
    password?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    isVerify?: BoolNullableFilter | boolean | null
    isApprove?: BoolNullableFilter | boolean | null
    ServiceKey?: StringNullableFilter | string | null
    Services?: XOR<ServicesRelationFilter, ServicesWhereInput> | null
    Alerts?: AlertsListRelationFilter
    Careers?: CareersListRelationFilter
    CustomerTaskDetails?: CustomerTaskDetailsListRelationFilter
    Customers?: CustomersListRelationFilter
    Discounts?: DiscountsListRelationFilter
    Lands?: LandsListRelationFilter
    Notifications?: NotificationsListRelationFilter
    OrderHistories?: OrderHistoriesListRelationFilter
    Orders?: OrdersListRelationFilter
    Permissions?: PermissionsListRelationFilter
    PostAccounts?: PostAccountsListRelationFilter
    Posts?: PostsListRelationFilter
    Reports?: ReportsListRelationFilter
    Statistics?: StatisticsListRelationFilter
    Subscribes?: SubscribesListRelationFilter
    TaskDetailResources?: TaskDetailResourcesListRelationFilter
    TaskDetails?: TaskDetailsListRelationFilter
    TaskGroups?: TaskGroupsListRelationFilter
    Tasks?: TasksListRelationFilter
    TeamAgents?: TeamAgentsListRelationFilter
    Teams_AccountsToTeams_AccountId?: TeamsListRelationFilter
    Teams_AccountsToTeams_AgentId?: TeamsListRelationFilter
  }

  export type AccountsOrderByWithRelationInput = {
    id?: SortOrder
    phone?: SortOrder
    verifyToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: SortOrder
    isAdmin?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    isVerify?: SortOrder
    isApprove?: SortOrder
    ServiceKey?: SortOrder
    Services?: ServicesOrderByWithRelationInput
    Alerts?: AlertsOrderByRelationAggregateInput
    Careers?: CareersOrderByRelationAggregateInput
    CustomerTaskDetails?: CustomerTaskDetailsOrderByRelationAggregateInput
    Customers?: CustomersOrderByRelationAggregateInput
    Discounts?: DiscountsOrderByRelationAggregateInput
    Lands?: LandsOrderByRelationAggregateInput
    Notifications?: NotificationsOrderByRelationAggregateInput
    OrderHistories?: OrderHistoriesOrderByRelationAggregateInput
    Orders?: OrdersOrderByRelationAggregateInput
    Permissions?: PermissionsOrderByRelationAggregateInput
    PostAccounts?: PostAccountsOrderByRelationAggregateInput
    Posts?: PostsOrderByRelationAggregateInput
    Reports?: ReportsOrderByRelationAggregateInput
    Statistics?: StatisticsOrderByRelationAggregateInput
    Subscribes?: SubscribesOrderByRelationAggregateInput
    TaskDetailResources?: TaskDetailResourcesOrderByRelationAggregateInput
    TaskDetails?: TaskDetailsOrderByRelationAggregateInput
    TaskGroups?: TaskGroupsOrderByRelationAggregateInput
    Tasks?: TasksOrderByRelationAggregateInput
    TeamAgents?: TeamAgentsOrderByRelationAggregateInput
    Teams_AccountsToTeams_AccountId?: TeamsOrderByRelationAggregateInput
    Teams_AccountsToTeams_AgentId?: TeamsOrderByRelationAggregateInput
  }

  export type AccountsWhereUniqueInput = {
    id?: number
  }

  export type AccountsOrderByWithAggregationInput = {
    id?: SortOrder
    phone?: SortOrder
    verifyToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: SortOrder
    isAdmin?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    isVerify?: SortOrder
    isApprove?: SortOrder
    ServiceKey?: SortOrder
    _count?: AccountsCountOrderByAggregateInput
    _avg?: AccountsAvgOrderByAggregateInput
    _max?: AccountsMaxOrderByAggregateInput
    _min?: AccountsMinOrderByAggregateInput
    _sum?: AccountsSumOrderByAggregateInput
  }

  export type AccountsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AccountsScalarWhereWithAggregatesInput>
    OR?: Enumerable<AccountsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AccountsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    phone?: StringNullableWithAggregatesFilter | string | null
    verifyToken?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    profile?: JsonNullableWithAggregatesFilter
    isAdmin?: BoolNullableWithAggregatesFilter | boolean | null
    email?: StringNullableWithAggregatesFilter | string | null
    password?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
    isVerify?: BoolNullableWithAggregatesFilter | boolean | null
    isApprove?: BoolNullableWithAggregatesFilter | boolean | null
    ServiceKey?: StringNullableWithAggregatesFilter | string | null
  }

  export type AlertsWhereInput = {
    AND?: Enumerable<AlertsWhereInput>
    OR?: Enumerable<AlertsWhereInput>
    NOT?: Enumerable<AlertsWhereInput>
    id?: BigIntFilter | bigint | number
    title?: StringNullableFilter | string | null
    type?: StringFilter | string
    category?: StringFilter | string
    AccountId?: IntNullableFilter | number | null
    ReferenceId?: IntFilter | number
    isRead?: BoolNullableFilter | boolean | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    data?: JsonNullableFilter
    Accounts?: XOR<AccountsRelationFilter, AccountsWhereInput> | null
  }

  export type AlertsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    category?: SortOrder
    AccountId?: SortOrder
    ReferenceId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    data?: SortOrder
    Accounts?: AccountsOrderByWithRelationInput
  }

  export type AlertsWhereUniqueInput = {
    id?: bigint | number
  }

  export type AlertsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    category?: SortOrder
    AccountId?: SortOrder
    ReferenceId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    data?: SortOrder
    _count?: AlertsCountOrderByAggregateInput
    _avg?: AlertsAvgOrderByAggregateInput
    _max?: AlertsMaxOrderByAggregateInput
    _min?: AlertsMinOrderByAggregateInput
    _sum?: AlertsSumOrderByAggregateInput
  }

  export type AlertsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AlertsScalarWhereWithAggregatesInput>
    OR?: Enumerable<AlertsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AlertsScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    title?: StringNullableWithAggregatesFilter | string | null
    type?: StringWithAggregatesFilter | string
    category?: StringWithAggregatesFilter | string
    AccountId?: IntNullableWithAggregatesFilter | number | null
    ReferenceId?: IntWithAggregatesFilter | number
    isRead?: BoolNullableWithAggregatesFilter | boolean | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    data?: JsonNullableWithAggregatesFilter
  }

  export type CareersWhereInput = {
    AND?: Enumerable<CareersWhereInput>
    OR?: Enumerable<CareersWhereInput>
    NOT?: Enumerable<CareersWhereInput>
    id?: IntFilter | number
    AccountId?: IntNullableFilter | number | null
    title?: StringNullableFilter | string | null
    startDate?: DateTimeNullableFilter | Date | string | null
    endDate?: DateTimeNullableFilter | Date | string | null
    content?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    Accounts?: XOR<AccountsRelationFilter, AccountsWhereInput> | null
  }

  export type CareersOrderByWithRelationInput = {
    id?: SortOrder
    AccountId?: SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Accounts?: AccountsOrderByWithRelationInput
  }

  export type CareersWhereUniqueInput = {
    id?: number
  }

  export type CareersOrderByWithAggregationInput = {
    id?: SortOrder
    AccountId?: SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CareersCountOrderByAggregateInput
    _avg?: CareersAvgOrderByAggregateInput
    _max?: CareersMaxOrderByAggregateInput
    _min?: CareersMinOrderByAggregateInput
    _sum?: CareersSumOrderByAggregateInput
  }

  export type CareersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CareersScalarWhereWithAggregatesInput>
    OR?: Enumerable<CareersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CareersScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    AccountId?: IntNullableWithAggregatesFilter | number | null
    title?: StringNullableWithAggregatesFilter | string | null
    startDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    content?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CouponsWhereInput = {
    AND?: Enumerable<CouponsWhereInput>
    OR?: Enumerable<CouponsWhereInput>
    NOT?: Enumerable<CouponsWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    code?: StringNullableFilter | string | null
    quantity?: IntNullableFilter | number | null
    maxRetry?: IntNullableFilter | number | null
    unit?: StringNullableFilter | string | null
    value?: IntNullableFilter | number | null
    startedAt?: DateTimeNullableFilter | Date | string | null
    endedAt?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    extra?: JsonNullableFilter
    updatedAt?: DateTimeFilter | Date | string
    Discounts?: DiscountsListRelationFilter
  }

  export type CouponsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    quantity?: SortOrder
    maxRetry?: SortOrder
    unit?: SortOrder
    value?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    createdAt?: SortOrder
    extra?: SortOrder
    updatedAt?: SortOrder
    Discounts?: DiscountsOrderByRelationAggregateInput
  }

  export type CouponsWhereUniqueInput = {
    id?: number
  }

  export type CouponsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    quantity?: SortOrder
    maxRetry?: SortOrder
    unit?: SortOrder
    value?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    createdAt?: SortOrder
    extra?: SortOrder
    updatedAt?: SortOrder
    _count?: CouponsCountOrderByAggregateInput
    _avg?: CouponsAvgOrderByAggregateInput
    _max?: CouponsMaxOrderByAggregateInput
    _min?: CouponsMinOrderByAggregateInput
    _sum?: CouponsSumOrderByAggregateInput
  }

  export type CouponsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CouponsScalarWhereWithAggregatesInput>
    OR?: Enumerable<CouponsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CouponsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    code?: StringNullableWithAggregatesFilter | string | null
    quantity?: IntNullableWithAggregatesFilter | number | null
    maxRetry?: IntNullableWithAggregatesFilter | number | null
    unit?: StringNullableWithAggregatesFilter | string | null
    value?: IntNullableWithAggregatesFilter | number | null
    startedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    extra?: JsonNullableWithAggregatesFilter
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CustomerTaskDetailsWhereInput = {
    AND?: Enumerable<CustomerTaskDetailsWhereInput>
    OR?: Enumerable<CustomerTaskDetailsWhereInput>
    NOT?: Enumerable<CustomerTaskDetailsWhereInput>
    id?: IntFilter | number
    AccountId?: IntNullableFilter | number | null
    CustomerId?: IntNullableFilter | number | null
    type?: StringNullableFilter | string | null
    address?: StringNullableFilter | string | null
    villageName?: StringNullableFilter | string | null
    category?: StringNullableFilter | string | null
    etc?: StringNullableFilter | string | null
    geometry?: JsonNullableFilter
    x?: StringNullableFilter | string | null
    y?: StringNullableFilter | string | null
    area?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    Accounts?: XOR<AccountsRelationFilter, AccountsWhereInput> | null
    Customers?: XOR<CustomersRelationFilter, CustomersWhereInput> | null
  }

  export type CustomerTaskDetailsOrderByWithRelationInput = {
    id?: SortOrder
    AccountId?: SortOrder
    CustomerId?: SortOrder
    type?: SortOrder
    address?: SortOrder
    villageName?: SortOrder
    category?: SortOrder
    etc?: SortOrder
    geometry?: SortOrder
    x?: SortOrder
    y?: SortOrder
    area?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Accounts?: AccountsOrderByWithRelationInput
    Customers?: CustomersOrderByWithRelationInput
  }

  export type CustomerTaskDetailsWhereUniqueInput = {
    id?: number
    AccountId_CustomerId_x_y?: CustomerTaskDetailsAccountIdCustomerIdXYCompoundUniqueInput
  }

  export type CustomerTaskDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    AccountId?: SortOrder
    CustomerId?: SortOrder
    type?: SortOrder
    address?: SortOrder
    villageName?: SortOrder
    category?: SortOrder
    etc?: SortOrder
    geometry?: SortOrder
    x?: SortOrder
    y?: SortOrder
    area?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerTaskDetailsCountOrderByAggregateInput
    _avg?: CustomerTaskDetailsAvgOrderByAggregateInput
    _max?: CustomerTaskDetailsMaxOrderByAggregateInput
    _min?: CustomerTaskDetailsMinOrderByAggregateInput
    _sum?: CustomerTaskDetailsSumOrderByAggregateInput
  }

  export type CustomerTaskDetailsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomerTaskDetailsScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomerTaskDetailsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomerTaskDetailsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    AccountId?: IntNullableWithAggregatesFilter | number | null
    CustomerId?: IntNullableWithAggregatesFilter | number | null
    type?: StringNullableWithAggregatesFilter | string | null
    address?: StringNullableWithAggregatesFilter | string | null
    villageName?: StringNullableWithAggregatesFilter | string | null
    category?: StringNullableWithAggregatesFilter | string | null
    etc?: StringNullableWithAggregatesFilter | string | null
    geometry?: JsonNullableWithAggregatesFilter
    x?: StringNullableWithAggregatesFilter | string | null
    y?: StringNullableWithAggregatesFilter | string | null
    area?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CustomersWhereInput = {
    AND?: Enumerable<CustomersWhereInput>
    OR?: Enumerable<CustomersWhereInput>
    NOT?: Enumerable<CustomersWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    crops?: StringNullableListFilter
    AccountId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    Accounts?: XOR<AccountsRelationFilter, AccountsWhereInput> | null
    CustomerTaskDetails?: CustomerTaskDetailsListRelationFilter
  }

  export type CustomersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    crops?: SortOrder
    AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Accounts?: AccountsOrderByWithRelationInput
    CustomerTaskDetails?: CustomerTaskDetailsOrderByRelationAggregateInput
  }

  export type CustomersWhereUniqueInput = {
    id?: number
    AccountId_phone_email?: CustomersAccountIdPhoneEmailCompoundUniqueInput
  }

  export type CustomersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    crops?: SortOrder
    AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomersCountOrderByAggregateInput
    _avg?: CustomersAvgOrderByAggregateInput
    _max?: CustomersMaxOrderByAggregateInput
    _min?: CustomersMinOrderByAggregateInput
    _sum?: CustomersSumOrderByAggregateInput
  }

  export type CustomersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomersScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomersScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    phone?: StringNullableWithAggregatesFilter | string | null
    crops?: StringNullableListFilter
    AccountId?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DiscountsWhereInput = {
    AND?: Enumerable<DiscountsWhereInput>
    OR?: Enumerable<DiscountsWhereInput>
    NOT?: Enumerable<DiscountsWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    price?: FloatNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    AccountId?: IntNullableFilter | number | null
    OrderId?: IntNullableFilter | number | null
    CouponId?: IntNullableFilter | number | null
    ProductId?: IntNullableFilter | number | null
    filters?: JsonNullableFilter
    Accounts?: XOR<AccountsRelationFilter, AccountsWhereInput> | null
    Coupons?: XOR<CouponsRelationFilter, CouponsWhereInput> | null
    Orders?: XOR<OrdersRelationFilter, OrdersWhereInput> | null
    Products?: XOR<ProductsRelationFilter, ProductsWhereInput> | null
  }

  export type DiscountsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    AccountId?: SortOrder
    OrderId?: SortOrder
    CouponId?: SortOrder
    ProductId?: SortOrder
    filters?: SortOrder
    Accounts?: AccountsOrderByWithRelationInput
    Coupons?: CouponsOrderByWithRelationInput
    Orders?: OrdersOrderByWithRelationInput
    Products?: ProductsOrderByWithRelationInput
  }

  export type DiscountsWhereUniqueInput = {
    id?: number
  }

  export type DiscountsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    AccountId?: SortOrder
    OrderId?: SortOrder
    CouponId?: SortOrder
    ProductId?: SortOrder
    filters?: SortOrder
    _count?: DiscountsCountOrderByAggregateInput
    _avg?: DiscountsAvgOrderByAggregateInput
    _max?: DiscountsMaxOrderByAggregateInput
    _min?: DiscountsMinOrderByAggregateInput
    _sum?: DiscountsSumOrderByAggregateInput
  }

  export type DiscountsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DiscountsScalarWhereWithAggregatesInput>
    OR?: Enumerable<DiscountsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DiscountsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    price?: FloatNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    AccountId?: IntNullableWithAggregatesFilter | number | null
    OrderId?: IntNullableWithAggregatesFilter | number | null
    CouponId?: IntNullableWithAggregatesFilter | number | null
    ProductId?: IntNullableWithAggregatesFilter | number | null
    filters?: JsonNullableWithAggregatesFilter
  }

  export type EventsWhereInput = {
    AND?: Enumerable<EventsWhereInput>
    OR?: Enumerable<EventsWhereInput>
    NOT?: Enumerable<EventsWhereInput>
    id?: BigIntFilter | bigint | number
    table?: StringFilter | string
    action?: StringNullableFilter | string | null
    createdBy?: IntNullableFilter | number | null
    data?: JsonNullableFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type EventsOrderByWithRelationInput = {
    id?: SortOrder
    table?: SortOrder
    action?: SortOrder
    createdBy?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventsWhereUniqueInput = {
    id?: bigint | number
  }

  export type EventsOrderByWithAggregationInput = {
    id?: SortOrder
    table?: SortOrder
    action?: SortOrder
    createdBy?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventsCountOrderByAggregateInput
    _avg?: EventsAvgOrderByAggregateInput
    _max?: EventsMaxOrderByAggregateInput
    _min?: EventsMinOrderByAggregateInput
    _sum?: EventsSumOrderByAggregateInput
  }

  export type EventsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EventsScalarWhereWithAggregatesInput>
    OR?: Enumerable<EventsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EventsScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    table?: StringWithAggregatesFilter | string
    action?: StringNullableWithAggregatesFilter | string | null
    createdBy?: IntNullableWithAggregatesFilter | number | null
    data?: JsonNullableWithAggregatesFilter
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type GeosWhereInput = {
    AND?: Enumerable<GeosWhereInput>
    OR?: Enumerable<GeosWhereInput>
    NOT?: Enumerable<GeosWhereInput>
    id?: IntFilter | number
    address?: StringNullableFilter | string | null
    geometry?: JsonNullableFilter
    x?: StringNullableFilter | string | null
    y?: StringNullableFilter | string | null
    pnu?: StringNullableFilter | string | null
    area?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type GeosOrderByWithRelationInput = {
    id?: SortOrder
    address?: SortOrder
    geometry?: SortOrder
    x?: SortOrder
    y?: SortOrder
    pnu?: SortOrder
    area?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GeosWhereUniqueInput = {
    id?: number
  }

  export type GeosOrderByWithAggregationInput = {
    id?: SortOrder
    address?: SortOrder
    geometry?: SortOrder
    x?: SortOrder
    y?: SortOrder
    pnu?: SortOrder
    area?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GeosCountOrderByAggregateInput
    _avg?: GeosAvgOrderByAggregateInput
    _max?: GeosMaxOrderByAggregateInput
    _min?: GeosMinOrderByAggregateInput
    _sum?: GeosSumOrderByAggregateInput
  }

  export type GeosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GeosScalarWhereWithAggregatesInput>
    OR?: Enumerable<GeosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GeosScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    address?: StringNullableWithAggregatesFilter | string | null
    geometry?: JsonNullableWithAggregatesFilter
    x?: StringNullableWithAggregatesFilter | string | null
    y?: StringNullableWithAggregatesFilter | string | null
    pnu?: StringNullableWithAggregatesFilter | string | null
    area?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LandsWhereInput = {
    AND?: Enumerable<LandsWhereInput>
    OR?: Enumerable<LandsWhereInput>
    NOT?: Enumerable<LandsWhereInput>
    id?: BigIntFilter | bigint | number
    AccountId?: IntFilter | number
    is_active?: BoolNullableFilter | boolean | null
    type?: StringNullableFilter | string | null
    villageName?: StringNullableFilter | string | null
    status?: StringNullableFilter | string | null
    geometry?: JsonNullableFilter
    x?: StringNullableFilter | string | null
    y?: StringNullableFilter | string | null
    area?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    extra?: JsonNullableFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    Accounts?: XOR<AccountsRelationFilter, AccountsWhereInput>
  }

  export type LandsOrderByWithRelationInput = {
    id?: SortOrder
    AccountId?: SortOrder
    is_active?: SortOrder
    type?: SortOrder
    villageName?: SortOrder
    status?: SortOrder
    geometry?: SortOrder
    x?: SortOrder
    y?: SortOrder
    area?: SortOrder
    extra?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Accounts?: AccountsOrderByWithRelationInput
  }

  export type LandsWhereUniqueInput = {
    id?: bigint | number
  }

  export type LandsOrderByWithAggregationInput = {
    id?: SortOrder
    AccountId?: SortOrder
    is_active?: SortOrder
    type?: SortOrder
    villageName?: SortOrder
    status?: SortOrder
    geometry?: SortOrder
    x?: SortOrder
    y?: SortOrder
    area?: SortOrder
    extra?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LandsCountOrderByAggregateInput
    _avg?: LandsAvgOrderByAggregateInput
    _max?: LandsMaxOrderByAggregateInput
    _min?: LandsMinOrderByAggregateInput
    _sum?: LandsSumOrderByAggregateInput
  }

  export type LandsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LandsScalarWhereWithAggregatesInput>
    OR?: Enumerable<LandsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LandsScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    AccountId?: IntWithAggregatesFilter | number
    is_active?: BoolNullableWithAggregatesFilter | boolean | null
    type?: StringNullableWithAggregatesFilter | string | null
    villageName?: StringNullableWithAggregatesFilter | string | null
    status?: StringNullableWithAggregatesFilter | string | null
    geometry?: JsonNullableWithAggregatesFilter
    x?: StringNullableWithAggregatesFilter | string | null
    y?: StringNullableWithAggregatesFilter | string | null
    area?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    extra?: JsonNullableWithAggregatesFilter
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type NoticesWhereInput = {
    AND?: Enumerable<NoticesWhereInput>
    OR?: Enumerable<NoticesWhereInput>
    NOT?: Enumerable<NoticesWhereInput>
    id?: IntFilter | number
    startDate?: DateTimeNullableFilter | Date | string | null
    endDate?: DateTimeNullableFilter | Date | string | null
    imageURL?: StringNullableFilter | string | null
    externalURL?: StringNullableFilter | string | null
    order?: IntNullableFilter | number | null
    active?: BoolNullableFilter | boolean | null
    deletedDate?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    name?: StringNullableFilter | string | null
  }

  export type NoticesOrderByWithRelationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    imageURL?: SortOrder
    externalURL?: SortOrder
    order?: SortOrder
    active?: SortOrder
    deletedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
  }

  export type NoticesWhereUniqueInput = {
    id?: number
  }

  export type NoticesOrderByWithAggregationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    imageURL?: SortOrder
    externalURL?: SortOrder
    order?: SortOrder
    active?: SortOrder
    deletedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    _count?: NoticesCountOrderByAggregateInput
    _avg?: NoticesAvgOrderByAggregateInput
    _max?: NoticesMaxOrderByAggregateInput
    _min?: NoticesMinOrderByAggregateInput
    _sum?: NoticesSumOrderByAggregateInput
  }

  export type NoticesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NoticesScalarWhereWithAggregatesInput>
    OR?: Enumerable<NoticesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NoticesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    startDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    imageURL?: StringNullableWithAggregatesFilter | string | null
    externalURL?: StringNullableWithAggregatesFilter | string | null
    order?: IntNullableWithAggregatesFilter | number | null
    active?: BoolNullableWithAggregatesFilter | boolean | null
    deletedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    name?: StringNullableWithAggregatesFilter | string | null
  }

  export type NotificationsWhereInput = {
    AND?: Enumerable<NotificationsWhereInput>
    OR?: Enumerable<NotificationsWhereInput>
    NOT?: Enumerable<NotificationsWhereInput>
    id?: BigIntFilter | bigint | number
    AccountId?: IntFilter | number
    fcmToken?: StringFilter | string
    sendedAt?: DateTimeNullableFilter | Date | string | null
    isSuccess?: BoolNullableFilter | boolean | null
    failReason?: StringNullableFilter | string | null
    eventCode?: StringFilter | string
    sendCode?: StringFilter | string
    reservationCode?: StringFilter | string
    sendCycleCode?: StringFilter | string
    title?: StringFilter | string
    message?: StringFilter | string
    image?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    Accounts?: XOR<AccountsRelationFilter, AccountsWhereInput>
  }

  export type NotificationsOrderByWithRelationInput = {
    id?: SortOrder
    AccountId?: SortOrder
    fcmToken?: SortOrder
    sendedAt?: SortOrder
    isSuccess?: SortOrder
    failReason?: SortOrder
    eventCode?: SortOrder
    sendCode?: SortOrder
    reservationCode?: SortOrder
    sendCycleCode?: SortOrder
    title?: SortOrder
    message?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Accounts?: AccountsOrderByWithRelationInput
  }

  export type NotificationsWhereUniqueInput = {
    id?: bigint | number
  }

  export type NotificationsOrderByWithAggregationInput = {
    id?: SortOrder
    AccountId?: SortOrder
    fcmToken?: SortOrder
    sendedAt?: SortOrder
    isSuccess?: SortOrder
    failReason?: SortOrder
    eventCode?: SortOrder
    sendCode?: SortOrder
    reservationCode?: SortOrder
    sendCycleCode?: SortOrder
    title?: SortOrder
    message?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationsCountOrderByAggregateInput
    _avg?: NotificationsAvgOrderByAggregateInput
    _max?: NotificationsMaxOrderByAggregateInput
    _min?: NotificationsMinOrderByAggregateInput
    _sum?: NotificationsSumOrderByAggregateInput
  }

  export type NotificationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NotificationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<NotificationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NotificationsScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    AccountId?: IntWithAggregatesFilter | number
    fcmToken?: StringWithAggregatesFilter | string
    sendedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    isSuccess?: BoolNullableWithAggregatesFilter | boolean | null
    failReason?: StringNullableWithAggregatesFilter | string | null
    eventCode?: StringWithAggregatesFilter | string
    sendCode?: StringWithAggregatesFilter | string
    reservationCode?: StringWithAggregatesFilter | string
    sendCycleCode?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    message?: StringWithAggregatesFilter | string
    image?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type OrderHistoriesWhereInput = {
    AND?: Enumerable<OrderHistoriesWhereInput>
    OR?: Enumerable<OrderHistoriesWhereInput>
    NOT?: Enumerable<OrderHistoriesWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    payment?: StringNullableFilter | string | null
    paymentMethod?: StringNullableFilter | string | null
    externalUid?: StringNullableFilter | string | null
    customerUid?: StringNullableFilter | string | null
    merchantUid?: StringNullableFilter | string | null
    reqAmount?: IntNullableFilter | number | null
    paidAmount?: IntNullableFilter | number | null
    status?: StringNullableFilter | string | null
    extra?: JsonNullableFilter
    AccountId?: IntNullableFilter | number | null
    ProductId?: IntNullableFilter | number | null
    OrderId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    Accounts?: XOR<AccountsRelationFilter, AccountsWhereInput> | null
    Orders?: XOR<OrdersRelationFilter, OrdersWhereInput> | null
    Products?: XOR<ProductsRelationFilter, ProductsWhereInput> | null
  }

  export type OrderHistoriesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    payment?: SortOrder
    paymentMethod?: SortOrder
    externalUid?: SortOrder
    customerUid?: SortOrder
    merchantUid?: SortOrder
    reqAmount?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    extra?: SortOrder
    AccountId?: SortOrder
    ProductId?: SortOrder
    OrderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Accounts?: AccountsOrderByWithRelationInput
    Orders?: OrdersOrderByWithRelationInput
    Products?: ProductsOrderByWithRelationInput
  }

  export type OrderHistoriesWhereUniqueInput = {
    id?: number
  }

  export type OrderHistoriesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    payment?: SortOrder
    paymentMethod?: SortOrder
    externalUid?: SortOrder
    customerUid?: SortOrder
    merchantUid?: SortOrder
    reqAmount?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    extra?: SortOrder
    AccountId?: SortOrder
    ProductId?: SortOrder
    OrderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderHistoriesCountOrderByAggregateInput
    _avg?: OrderHistoriesAvgOrderByAggregateInput
    _max?: OrderHistoriesMaxOrderByAggregateInput
    _min?: OrderHistoriesMinOrderByAggregateInput
    _sum?: OrderHistoriesSumOrderByAggregateInput
  }

  export type OrderHistoriesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrderHistoriesScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrderHistoriesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrderHistoriesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    payment?: StringNullableWithAggregatesFilter | string | null
    paymentMethod?: StringNullableWithAggregatesFilter | string | null
    externalUid?: StringNullableWithAggregatesFilter | string | null
    customerUid?: StringNullableWithAggregatesFilter | string | null
    merchantUid?: StringNullableWithAggregatesFilter | string | null
    reqAmount?: IntNullableWithAggregatesFilter | number | null
    paidAmount?: IntNullableWithAggregatesFilter | number | null
    status?: StringNullableWithAggregatesFilter | string | null
    extra?: JsonNullableWithAggregatesFilter
    AccountId?: IntNullableWithAggregatesFilter | number | null
    ProductId?: IntNullableWithAggregatesFilter | number | null
    OrderId?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type OrdersWhereInput = {
    AND?: Enumerable<OrdersWhereInput>
    OR?: Enumerable<OrdersWhereInput>
    NOT?: Enumerable<OrdersWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    payment?: StringNullableFilter | string | null
    paymentMethod?: StringNullableFilter | string | null
    externalUid?: StringNullableFilter | string | null
    customerUid?: StringNullableFilter | string | null
    merchantUid?: StringNullableFilter | string | null
    reqAmount?: IntNullableFilter | number | null
    paidAmount?: IntNullableFilter | number | null
    status?: StringNullableFilter | string | null
    extra?: JsonNullableFilter
    AccountId?: IntNullableFilter | number | null
    ProductId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    expiredAt?: DateTimeNullableFilter | Date | string | null
    isSubscribe?: BoolNullableFilter | boolean | null
    issuedAt?: DateTimeNullableFilter | Date | string | null
    Accounts?: XOR<AccountsRelationFilter, AccountsWhereInput> | null
    Products?: XOR<ProductsRelationFilter, ProductsWhereInput> | null
    Discounts?: DiscountsListRelationFilter
    OrderHistories?: OrderHistoriesListRelationFilter
  }

  export type OrdersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    payment?: SortOrder
    paymentMethod?: SortOrder
    externalUid?: SortOrder
    customerUid?: SortOrder
    merchantUid?: SortOrder
    reqAmount?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    extra?: SortOrder
    AccountId?: SortOrder
    ProductId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiredAt?: SortOrder
    isSubscribe?: SortOrder
    issuedAt?: SortOrder
    Accounts?: AccountsOrderByWithRelationInput
    Products?: ProductsOrderByWithRelationInput
    Discounts?: DiscountsOrderByRelationAggregateInput
    OrderHistories?: OrderHistoriesOrderByRelationAggregateInput
  }

  export type OrdersWhereUniqueInput = {
    id?: number
  }

  export type OrdersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    payment?: SortOrder
    paymentMethod?: SortOrder
    externalUid?: SortOrder
    customerUid?: SortOrder
    merchantUid?: SortOrder
    reqAmount?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    extra?: SortOrder
    AccountId?: SortOrder
    ProductId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiredAt?: SortOrder
    isSubscribe?: SortOrder
    issuedAt?: SortOrder
    _count?: OrdersCountOrderByAggregateInput
    _avg?: OrdersAvgOrderByAggregateInput
    _max?: OrdersMaxOrderByAggregateInput
    _min?: OrdersMinOrderByAggregateInput
    _sum?: OrdersSumOrderByAggregateInput
  }

  export type OrdersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrdersScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrdersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrdersScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    payment?: StringNullableWithAggregatesFilter | string | null
    paymentMethod?: StringNullableWithAggregatesFilter | string | null
    externalUid?: StringNullableWithAggregatesFilter | string | null
    customerUid?: StringNullableWithAggregatesFilter | string | null
    merchantUid?: StringNullableWithAggregatesFilter | string | null
    reqAmount?: IntNullableWithAggregatesFilter | number | null
    paidAmount?: IntNullableWithAggregatesFilter | number | null
    status?: StringNullableWithAggregatesFilter | string | null
    extra?: JsonNullableWithAggregatesFilter
    AccountId?: IntNullableWithAggregatesFilter | number | null
    ProductId?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    expiredAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    isSubscribe?: BoolNullableWithAggregatesFilter | boolean | null
    issuedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type PermissionsWhereInput = {
    AND?: Enumerable<PermissionsWhereInput>
    OR?: Enumerable<PermissionsWhereInput>
    NOT?: Enumerable<PermissionsWhereInput>
    id?: IntFilter | number
    resource?: StringFilter | string
    key?: Enumenum_Permissions_keyFilter | enum_Permissions_key
    resourceId?: IntFilter | number
    AccountId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    Accounts?: XOR<AccountsRelationFilter, AccountsWhereInput> | null
  }

  export type PermissionsOrderByWithRelationInput = {
    id?: SortOrder
    resource?: SortOrder
    key?: SortOrder
    resourceId?: SortOrder
    AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Accounts?: AccountsOrderByWithRelationInput
  }

  export type PermissionsWhereUniqueInput = {
    id?: number
  }

  export type PermissionsOrderByWithAggregationInput = {
    id?: SortOrder
    resource?: SortOrder
    key?: SortOrder
    resourceId?: SortOrder
    AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PermissionsCountOrderByAggregateInput
    _avg?: PermissionsAvgOrderByAggregateInput
    _max?: PermissionsMaxOrderByAggregateInput
    _min?: PermissionsMinOrderByAggregateInput
    _sum?: PermissionsSumOrderByAggregateInput
  }

  export type PermissionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PermissionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<PermissionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PermissionsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    resource?: StringWithAggregatesFilter | string
    key?: Enumenum_Permissions_keyWithAggregatesFilter | enum_Permissions_key
    resourceId?: IntWithAggregatesFilter | number
    AccountId?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PostAccountsWhereInput = {
    AND?: Enumerable<PostAccountsWhereInput>
    OR?: Enumerable<PostAccountsWhereInput>
    NOT?: Enumerable<PostAccountsWhereInput>
    id?: IntFilter | number
    AccountId?: IntNullableFilter | number | null
    PostId?: IntNullableFilter | number | null
    type?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    Accounts?: XOR<AccountsRelationFilter, AccountsWhereInput> | null
    Posts?: XOR<PostsRelationFilter, PostsWhereInput> | null
  }

  export type PostAccountsOrderByWithRelationInput = {
    id?: SortOrder
    AccountId?: SortOrder
    PostId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Accounts?: AccountsOrderByWithRelationInput
    Posts?: PostsOrderByWithRelationInput
  }

  export type PostAccountsWhereUniqueInput = {
    id?: number
    type_PostId_AccountId?: PostAccountsTypePostIdAccountIdCompoundUniqueInput
  }

  export type PostAccountsOrderByWithAggregationInput = {
    id?: SortOrder
    AccountId?: SortOrder
    PostId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PostAccountsCountOrderByAggregateInput
    _avg?: PostAccountsAvgOrderByAggregateInput
    _max?: PostAccountsMaxOrderByAggregateInput
    _min?: PostAccountsMinOrderByAggregateInput
    _sum?: PostAccountsSumOrderByAggregateInput
  }

  export type PostAccountsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PostAccountsScalarWhereWithAggregatesInput>
    OR?: Enumerable<PostAccountsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PostAccountsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    AccountId?: IntNullableWithAggregatesFilter | number | null
    PostId?: IntNullableWithAggregatesFilter | number | null
    type?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PostsWhereInput = {
    AND?: Enumerable<PostsWhereInput>
    OR?: Enumerable<PostsWhereInput>
    NOT?: Enumerable<PostsWhereInput>
    id?: IntFilter | number
    category?: StringNullableFilter | string | null
    type?: StringNullableListFilter
    content?: StringNullableFilter | string | null
    unit?: StringNullableFilter | string | null
    price?: IntNullableFilter | number | null
    location?: StringNullableListFilter
    area?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    title?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    startDate?: DateTimeNullableFilter | Date | string | null
    endDate?: DateTimeNullableFilter | Date | string | null
    status?: StringNullableFilter | string | null
    viewCount?: IntNullableFilter | number | null
    AccountId?: IntNullableFilter | number | null
    contactName?: StringNullableFilter | string | null
    contactPhone?: StringNullableFilter | string | null
    contactEmail?: StringNullableFilter | string | null
    qualifications?: StringNullableListFilter
    Accounts?: XOR<AccountsRelationFilter, AccountsWhereInput> | null
    PostAccounts?: PostAccountsListRelationFilter
  }

  export type PostsOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    type?: SortOrder
    content?: SortOrder
    unit?: SortOrder
    price?: SortOrder
    location?: SortOrder
    area?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    viewCount?: SortOrder
    AccountId?: SortOrder
    contactName?: SortOrder
    contactPhone?: SortOrder
    contactEmail?: SortOrder
    qualifications?: SortOrder
    Accounts?: AccountsOrderByWithRelationInput
    PostAccounts?: PostAccountsOrderByRelationAggregateInput
  }

  export type PostsWhereUniqueInput = {
    id?: number
  }

  export type PostsOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    type?: SortOrder
    content?: SortOrder
    unit?: SortOrder
    price?: SortOrder
    location?: SortOrder
    area?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    viewCount?: SortOrder
    AccountId?: SortOrder
    contactName?: SortOrder
    contactPhone?: SortOrder
    contactEmail?: SortOrder
    qualifications?: SortOrder
    _count?: PostsCountOrderByAggregateInput
    _avg?: PostsAvgOrderByAggregateInput
    _max?: PostsMaxOrderByAggregateInput
    _min?: PostsMinOrderByAggregateInput
    _sum?: PostsSumOrderByAggregateInput
  }

  export type PostsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PostsScalarWhereWithAggregatesInput>
    OR?: Enumerable<PostsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PostsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    category?: StringNullableWithAggregatesFilter | string | null
    type?: StringNullableListFilter
    content?: StringNullableWithAggregatesFilter | string | null
    unit?: StringNullableWithAggregatesFilter | string | null
    price?: IntNullableWithAggregatesFilter | number | null
    location?: StringNullableListFilter
    area?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    title?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    startDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    status?: StringNullableWithAggregatesFilter | string | null
    viewCount?: IntNullableWithAggregatesFilter | number | null
    AccountId?: IntNullableWithAggregatesFilter | number | null
    contactName?: StringNullableWithAggregatesFilter | string | null
    contactPhone?: StringNullableWithAggregatesFilter | string | null
    contactEmail?: StringNullableWithAggregatesFilter | string | null
    qualifications?: StringNullableListFilter
  }

  export type ProductsWhereInput = {
    AND?: Enumerable<ProductsWhereInput>
    OR?: Enumerable<ProductsWhereInput>
    NOT?: Enumerable<ProductsWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    price?: IntNullableFilter | number | null
    duration?: IntNullableFilter | number | null
    filters?: JsonNullableFilter
    isActive?: BoolNullableFilter | boolean | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isSubscribe?: BoolNullableFilter | boolean | null
    Discounts?: DiscountsListRelationFilter
    OrderHistories?: OrderHistoriesListRelationFilter
    Orders?: OrdersListRelationFilter
  }

  export type ProductsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    filters?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isSubscribe?: SortOrder
    Discounts?: DiscountsOrderByRelationAggregateInput
    OrderHistories?: OrderHistoriesOrderByRelationAggregateInput
    Orders?: OrdersOrderByRelationAggregateInput
  }

  export type ProductsWhereUniqueInput = {
    id?: number
  }

  export type ProductsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    filters?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isSubscribe?: SortOrder
    _count?: ProductsCountOrderByAggregateInput
    _avg?: ProductsAvgOrderByAggregateInput
    _max?: ProductsMaxOrderByAggregateInput
    _min?: ProductsMinOrderByAggregateInput
    _sum?: ProductsSumOrderByAggregateInput
  }

  export type ProductsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductsScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    price?: IntNullableWithAggregatesFilter | number | null
    duration?: IntNullableWithAggregatesFilter | number | null
    filters?: JsonNullableWithAggregatesFilter
    isActive?: BoolNullableWithAggregatesFilter | boolean | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isSubscribe?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type ReportsWhereInput = {
    AND?: Enumerable<ReportsWhereInput>
    OR?: Enumerable<ReportsWhereInput>
    NOT?: Enumerable<ReportsWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    isActive?: BoolNullableFilter | boolean | null
    isPrivate?: BoolNullableFilter | boolean | null
    password?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    TaskId?: IntNullableFilter | number | null
    AccountId?: IntNullableFilter | number | null
    Accounts?: XOR<AccountsRelationFilter, AccountsWhereInput> | null
    Tasks?: XOR<TasksRelationFilter, TasksWhereInput> | null
  }

  export type ReportsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    isPrivate?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    TaskId?: SortOrder
    AccountId?: SortOrder
    Accounts?: AccountsOrderByWithRelationInput
    Tasks?: TasksOrderByWithRelationInput
  }

  export type ReportsWhereUniqueInput = {
    id?: number
  }

  export type ReportsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    isPrivate?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    TaskId?: SortOrder
    AccountId?: SortOrder
    _count?: ReportsCountOrderByAggregateInput
    _avg?: ReportsAvgOrderByAggregateInput
    _max?: ReportsMaxOrderByAggregateInput
    _min?: ReportsMinOrderByAggregateInput
    _sum?: ReportsSumOrderByAggregateInput
  }

  export type ReportsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReportsScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReportsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReportsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    isActive?: BoolNullableWithAggregatesFilter | boolean | null
    isPrivate?: BoolNullableWithAggregatesFilter | boolean | null
    password?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    TaskId?: IntNullableWithAggregatesFilter | number | null
    AccountId?: IntNullableWithAggregatesFilter | number | null
  }

  export type SequelizeMetaWhereInput = {
    AND?: Enumerable<SequelizeMetaWhereInput>
    OR?: Enumerable<SequelizeMetaWhereInput>
    NOT?: Enumerable<SequelizeMetaWhereInput>
    name?: StringFilter | string
  }

  export type SequelizeMetaOrderByWithRelationInput = {
    name?: SortOrder
  }

  export type SequelizeMetaWhereUniqueInput = {
    name?: string
  }

  export type SequelizeMetaOrderByWithAggregationInput = {
    name?: SortOrder
    _count?: SequelizeMetaCountOrderByAggregateInput
    _max?: SequelizeMetaMaxOrderByAggregateInput
    _min?: SequelizeMetaMinOrderByAggregateInput
  }

  export type SequelizeMetaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SequelizeMetaScalarWhereWithAggregatesInput>
    OR?: Enumerable<SequelizeMetaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SequelizeMetaScalarWhereWithAggregatesInput>
    name?: StringWithAggregatesFilter | string
  }

  export type ServicesWhereInput = {
    AND?: Enumerable<ServicesWhereInput>
    OR?: Enumerable<ServicesWhereInput>
    NOT?: Enumerable<ServicesWhereInput>
    key?: StringFilter | string
    description?: StringNullableFilter | string | null
    isActive?: BoolNullableFilter | boolean | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    Accounts?: AccountsListRelationFilter
  }

  export type ServicesOrderByWithRelationInput = {
    key?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Accounts?: AccountsOrderByRelationAggregateInput
  }

  export type ServicesWhereUniqueInput = {
    key?: string
  }

  export type ServicesOrderByWithAggregationInput = {
    key?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServicesCountOrderByAggregateInput
    _max?: ServicesMaxOrderByAggregateInput
    _min?: ServicesMinOrderByAggregateInput
  }

  export type ServicesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ServicesScalarWhereWithAggregatesInput>
    OR?: Enumerable<ServicesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ServicesScalarWhereWithAggregatesInput>
    key?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    isActive?: BoolNullableWithAggregatesFilter | boolean | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type StatisticsWhereInput = {
    AND?: Enumerable<StatisticsWhereInput>
    OR?: Enumerable<StatisticsWhereInput>
    NOT?: Enumerable<StatisticsWhereInput>
    id?: IntFilter | number
    AgentId?: IntNullableFilter | number | null
    TeamId?: IntNullableFilter | number | null
    TaskId?: IntNullableFilter | number | null
    dailyWorkload?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    completedByOwner?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    completedBySelf?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    Accounts?: XOR<AccountsRelationFilter, AccountsWhereInput> | null
    Tasks?: XOR<TasksRelationFilter, TasksWhereInput> | null
    Teams?: XOR<TeamsRelationFilter, TeamsWhereInput> | null
  }

  export type StatisticsOrderByWithRelationInput = {
    id?: SortOrder
    AgentId?: SortOrder
    TeamId?: SortOrder
    TaskId?: SortOrder
    dailyWorkload?: SortOrder
    completedByOwner?: SortOrder
    completedBySelf?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Accounts?: AccountsOrderByWithRelationInput
    Tasks?: TasksOrderByWithRelationInput
    Teams?: TeamsOrderByWithRelationInput
  }

  export type StatisticsWhereUniqueInput = {
    id?: number
  }

  export type StatisticsOrderByWithAggregationInput = {
    id?: SortOrder
    AgentId?: SortOrder
    TeamId?: SortOrder
    TaskId?: SortOrder
    dailyWorkload?: SortOrder
    completedByOwner?: SortOrder
    completedBySelf?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StatisticsCountOrderByAggregateInput
    _avg?: StatisticsAvgOrderByAggregateInput
    _max?: StatisticsMaxOrderByAggregateInput
    _min?: StatisticsMinOrderByAggregateInput
    _sum?: StatisticsSumOrderByAggregateInput
  }

  export type StatisticsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StatisticsScalarWhereWithAggregatesInput>
    OR?: Enumerable<StatisticsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StatisticsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    AgentId?: IntNullableWithAggregatesFilter | number | null
    TeamId?: IntNullableWithAggregatesFilter | number | null
    TaskId?: IntNullableWithAggregatesFilter | number | null
    dailyWorkload?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    completedByOwner?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    completedBySelf?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SubscribesWhereInput = {
    AND?: Enumerable<SubscribesWhereInput>
    OR?: Enumerable<SubscribesWhereInput>
    NOT?: Enumerable<SubscribesWhereInput>
    id?: IntFilter | number
    AccountId?: IntFilter | number
    fcmToken?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    Accounts?: XOR<AccountsRelationFilter, AccountsWhereInput>
  }

  export type SubscribesOrderByWithRelationInput = {
    id?: SortOrder
    AccountId?: SortOrder
    fcmToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Accounts?: AccountsOrderByWithRelationInput
  }

  export type SubscribesWhereUniqueInput = {
    id?: number
  }

  export type SubscribesOrderByWithAggregationInput = {
    id?: SortOrder
    AccountId?: SortOrder
    fcmToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscribesCountOrderByAggregateInput
    _avg?: SubscribesAvgOrderByAggregateInput
    _max?: SubscribesMaxOrderByAggregateInput
    _min?: SubscribesMinOrderByAggregateInput
    _sum?: SubscribesSumOrderByAggregateInput
  }

  export type SubscribesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubscribesScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubscribesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubscribesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    AccountId?: IntWithAggregatesFilter | number
    fcmToken?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TaskDetailResourcesWhereInput = {
    AND?: Enumerable<TaskDetailResourcesWhereInput>
    OR?: Enumerable<TaskDetailResourcesWhereInput>
    NOT?: Enumerable<TaskDetailResourcesWhereInput>
    id?: IntFilter | number
    content?: StringNullableFilter | string | null
    type?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    TaskDetailId?: IntNullableFilter | number | null
    AccountId?: IntNullableFilter | number | null
    group?: StringNullableFilter | string | null
    Accounts?: XOR<AccountsRelationFilter, AccountsWhereInput> | null
    TaskDetails?: XOR<TaskDetailsRelationFilter, TaskDetailsWhereInput> | null
  }

  export type TaskDetailResourcesOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    TaskDetailId?: SortOrder
    AccountId?: SortOrder
    group?: SortOrder
    Accounts?: AccountsOrderByWithRelationInput
    TaskDetails?: TaskDetailsOrderByWithRelationInput
  }

  export type TaskDetailResourcesWhereUniqueInput = {
    id?: number
  }

  export type TaskDetailResourcesOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    TaskDetailId?: SortOrder
    AccountId?: SortOrder
    group?: SortOrder
    _count?: TaskDetailResourcesCountOrderByAggregateInput
    _avg?: TaskDetailResourcesAvgOrderByAggregateInput
    _max?: TaskDetailResourcesMaxOrderByAggregateInput
    _min?: TaskDetailResourcesMinOrderByAggregateInput
    _sum?: TaskDetailResourcesSumOrderByAggregateInput
  }

  export type TaskDetailResourcesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TaskDetailResourcesScalarWhereWithAggregatesInput>
    OR?: Enumerable<TaskDetailResourcesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TaskDetailResourcesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    content?: StringNullableWithAggregatesFilter | string | null
    type?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    TaskDetailId?: IntNullableWithAggregatesFilter | number | null
    AccountId?: IntNullableWithAggregatesFilter | number | null
    group?: StringNullableWithAggregatesFilter | string | null
  }

  export type TaskDetailsWhereInput = {
    AND?: Enumerable<TaskDetailsWhereInput>
    OR?: Enumerable<TaskDetailsWhereInput>
    NOT?: Enumerable<TaskDetailsWhereInput>
    id?: IntFilter | number
    AccountId?: IntNullableFilter | number | null
    TaskId?: IntNullableFilter | number | null
    type?: StringNullableFilter | string | null
    address?: StringNullableFilter | string | null
    villageName?: StringNullableFilter | string | null
    pushUser?: StringNullableFilter | string | null
    category?: StringNullableFilter | string | null
    etc?: StringNullableFilter | string | null
    status?: StringNullableFilter | string | null
    geometry?: JsonNullableFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    assignedDays?: IntNullableFilter | number | null
    assignedUser?: StringNullableFilter | string | null
    TeamId?: IntNullableFilter | number | null
    y?: StringNullableFilter | string | null
    x?: StringNullableFilter | string | null
    area?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    pushPhone?: StringNullableFilter | string | null
    startedAt?: DateTimeNullableFilter | Date | string | null
    endedAt?: DateTimeNullableFilter | Date | string | null
    memo?: StringNullableFilter | string | null
    extra?: JsonNullableFilter
    Accounts?: XOR<AccountsRelationFilter, AccountsWhereInput> | null
    Tasks?: XOR<TasksRelationFilter, TasksWhereInput> | null
    Teams?: XOR<TeamsRelationFilter, TeamsWhereInput> | null
    TaskDetailResources?: TaskDetailResourcesListRelationFilter
  }

  export type TaskDetailsOrderByWithRelationInput = {
    id?: SortOrder
    AccountId?: SortOrder
    TaskId?: SortOrder
    type?: SortOrder
    address?: SortOrder
    villageName?: SortOrder
    pushUser?: SortOrder
    category?: SortOrder
    etc?: SortOrder
    status?: SortOrder
    geometry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedDays?: SortOrder
    assignedUser?: SortOrder
    TeamId?: SortOrder
    y?: SortOrder
    x?: SortOrder
    area?: SortOrder
    pushPhone?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    memo?: SortOrder
    extra?: SortOrder
    Accounts?: AccountsOrderByWithRelationInput
    Tasks?: TasksOrderByWithRelationInput
    Teams?: TeamsOrderByWithRelationInput
    TaskDetailResources?: TaskDetailResourcesOrderByRelationAggregateInput
  }

  export type TaskDetailsWhereUniqueInput = {
    id?: number
  }

  export type TaskDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    AccountId?: SortOrder
    TaskId?: SortOrder
    type?: SortOrder
    address?: SortOrder
    villageName?: SortOrder
    pushUser?: SortOrder
    category?: SortOrder
    etc?: SortOrder
    status?: SortOrder
    geometry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedDays?: SortOrder
    assignedUser?: SortOrder
    TeamId?: SortOrder
    y?: SortOrder
    x?: SortOrder
    area?: SortOrder
    pushPhone?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    memo?: SortOrder
    extra?: SortOrder
    _count?: TaskDetailsCountOrderByAggregateInput
    _avg?: TaskDetailsAvgOrderByAggregateInput
    _max?: TaskDetailsMaxOrderByAggregateInput
    _min?: TaskDetailsMinOrderByAggregateInput
    _sum?: TaskDetailsSumOrderByAggregateInput
  }

  export type TaskDetailsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TaskDetailsScalarWhereWithAggregatesInput>
    OR?: Enumerable<TaskDetailsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TaskDetailsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    AccountId?: IntNullableWithAggregatesFilter | number | null
    TaskId?: IntNullableWithAggregatesFilter | number | null
    type?: StringNullableWithAggregatesFilter | string | null
    address?: StringNullableWithAggregatesFilter | string | null
    villageName?: StringNullableWithAggregatesFilter | string | null
    pushUser?: StringNullableWithAggregatesFilter | string | null
    category?: StringNullableWithAggregatesFilter | string | null
    etc?: StringNullableWithAggregatesFilter | string | null
    status?: StringNullableWithAggregatesFilter | string | null
    geometry?: JsonNullableWithAggregatesFilter
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    assignedDays?: IntNullableWithAggregatesFilter | number | null
    assignedUser?: StringNullableWithAggregatesFilter | string | null
    TeamId?: IntNullableWithAggregatesFilter | number | null
    y?: StringNullableWithAggregatesFilter | string | null
    x?: StringNullableWithAggregatesFilter | string | null
    area?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    pushPhone?: StringNullableWithAggregatesFilter | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    memo?: StringNullableWithAggregatesFilter | string | null
    extra?: JsonNullableWithAggregatesFilter
  }

  export type TaskGroupsWhereInput = {
    AND?: Enumerable<TaskGroupsWhereInput>
    OR?: Enumerable<TaskGroupsWhereInput>
    NOT?: Enumerable<TaskGroupsWhereInput>
    id?: IntFilter | number
    path?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    status?: StringNullableFilter | string | null
    AccountId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    area?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    createType?: StringNullableFilter | string | null
    extra?: JsonNullableFilter
    Accounts?: XOR<AccountsRelationFilter, AccountsWhereInput> | null
    Tasks?: TasksListRelationFilter
  }

  export type TaskGroupsOrderByWithRelationInput = {
    id?: SortOrder
    path?: SortOrder
    name?: SortOrder
    status?: SortOrder
    AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    area?: SortOrder
    createType?: SortOrder
    extra?: SortOrder
    Accounts?: AccountsOrderByWithRelationInput
    Tasks?: TasksOrderByRelationAggregateInput
  }

  export type TaskGroupsWhereUniqueInput = {
    id?: number
  }

  export type TaskGroupsOrderByWithAggregationInput = {
    id?: SortOrder
    path?: SortOrder
    name?: SortOrder
    status?: SortOrder
    AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    area?: SortOrder
    createType?: SortOrder
    extra?: SortOrder
    _count?: TaskGroupsCountOrderByAggregateInput
    _avg?: TaskGroupsAvgOrderByAggregateInput
    _max?: TaskGroupsMaxOrderByAggregateInput
    _min?: TaskGroupsMinOrderByAggregateInput
    _sum?: TaskGroupsSumOrderByAggregateInput
  }

  export type TaskGroupsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TaskGroupsScalarWhereWithAggregatesInput>
    OR?: Enumerable<TaskGroupsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TaskGroupsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    path?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
    status?: StringNullableWithAggregatesFilter | string | null
    AccountId?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    area?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    createType?: StringNullableWithAggregatesFilter | string | null
    extra?: JsonNullableWithAggregatesFilter
  }

  export type TasksWhereInput = {
    AND?: Enumerable<TasksWhereInput>
    OR?: Enumerable<TasksWhereInput>
    NOT?: Enumerable<TasksWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    status?: StringNullableFilter | string | null
    AccountId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    workingDays?: IntNullableFilter | number | null
    workingTeamsCnt?: IntNullableFilter | number | null
    TaskGroupId?: IntNullableFilter | number | null
    startDate?: DateTimeNullableFilter | Date | string | null
    endDate?: DateTimeNullableFilter | Date | string | null
    area?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    isPaid?: BoolNullableFilter | boolean | null
    createType?: StringNullableFilter | string | null
    extra?: JsonNullableFilter
    real_area?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    Accounts?: XOR<AccountsRelationFilter, AccountsWhereInput> | null
    TaskGroups?: XOR<TaskGroupsRelationFilter, TaskGroupsWhereInput> | null
    Reports?: ReportsListRelationFilter
    Statistics?: StatisticsListRelationFilter
    TaskDetails?: TaskDetailsListRelationFilter
    Teams?: TeamsListRelationFilter
  }

  export type TasksOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workingDays?: SortOrder
    workingTeamsCnt?: SortOrder
    TaskGroupId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    area?: SortOrder
    isPaid?: SortOrder
    createType?: SortOrder
    extra?: SortOrder
    real_area?: SortOrder
    Accounts?: AccountsOrderByWithRelationInput
    TaskGroups?: TaskGroupsOrderByWithRelationInput
    Reports?: ReportsOrderByRelationAggregateInput
    Statistics?: StatisticsOrderByRelationAggregateInput
    TaskDetails?: TaskDetailsOrderByRelationAggregateInput
    Teams?: TeamsOrderByRelationAggregateInput
  }

  export type TasksWhereUniqueInput = {
    id?: number
  }

  export type TasksOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workingDays?: SortOrder
    workingTeamsCnt?: SortOrder
    TaskGroupId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    area?: SortOrder
    isPaid?: SortOrder
    createType?: SortOrder
    extra?: SortOrder
    real_area?: SortOrder
    _count?: TasksCountOrderByAggregateInput
    _avg?: TasksAvgOrderByAggregateInput
    _max?: TasksMaxOrderByAggregateInput
    _min?: TasksMinOrderByAggregateInput
    _sum?: TasksSumOrderByAggregateInput
  }

  export type TasksScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TasksScalarWhereWithAggregatesInput>
    OR?: Enumerable<TasksScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TasksScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    status?: StringNullableWithAggregatesFilter | string | null
    AccountId?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    workingDays?: IntNullableWithAggregatesFilter | number | null
    workingTeamsCnt?: IntNullableWithAggregatesFilter | number | null
    TaskGroupId?: IntNullableWithAggregatesFilter | number | null
    startDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    area?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    isPaid?: BoolNullableWithAggregatesFilter | boolean | null
    createType?: StringNullableWithAggregatesFilter | string | null
    extra?: JsonNullableWithAggregatesFilter
    real_area?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type TeamAgentsWhereInput = {
    AND?: Enumerable<TeamAgentsWhereInput>
    OR?: Enumerable<TeamAgentsWhereInput>
    NOT?: Enumerable<TeamAgentsWhereInput>
    AgentId?: IntFilter | number
    TeamId?: IntFilter | number
    isActive?: BoolNullableFilter | boolean | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    Accounts?: XOR<AccountsRelationFilter, AccountsWhereInput>
    Teams?: XOR<TeamsRelationFilter, TeamsWhereInput>
  }

  export type TeamAgentsOrderByWithRelationInput = {
    AgentId?: SortOrder
    TeamId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Accounts?: AccountsOrderByWithRelationInput
    Teams?: TeamsOrderByWithRelationInput
  }

  export type TeamAgentsWhereUniqueInput = {
    AgentId_TeamId?: TeamAgentsAgentIdTeamIdCompoundUniqueInput
  }

  export type TeamAgentsOrderByWithAggregationInput = {
    AgentId?: SortOrder
    TeamId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamAgentsCountOrderByAggregateInput
    _avg?: TeamAgentsAvgOrderByAggregateInput
    _max?: TeamAgentsMaxOrderByAggregateInput
    _min?: TeamAgentsMinOrderByAggregateInput
    _sum?: TeamAgentsSumOrderByAggregateInput
  }

  export type TeamAgentsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TeamAgentsScalarWhereWithAggregatesInput>
    OR?: Enumerable<TeamAgentsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TeamAgentsScalarWhereWithAggregatesInput>
    AgentId?: IntWithAggregatesFilter | number
    TeamId?: IntWithAggregatesFilter | number
    isActive?: BoolNullableWithAggregatesFilter | boolean | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TeamsWhereInput = {
    AND?: Enumerable<TeamsWhereInput>
    OR?: Enumerable<TeamsWhereInput>
    NOT?: Enumerable<TeamsWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    AccountId?: IntNullableFilter | number | null
    AgentId?: IntNullableFilter | number | null
    TaskId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    status?: StringNullableFilter | string | null
    area?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    alias?: StringNullableFilter | string | null
    Accounts_AccountsToTeams_AccountId?: XOR<AccountsRelationFilter, AccountsWhereInput> | null
    Accounts_AccountsToTeams_AgentId?: XOR<AccountsRelationFilter, AccountsWhereInput> | null
    Tasks?: XOR<TasksRelationFilter, TasksWhereInput> | null
    Statistics?: StatisticsListRelationFilter
    TaskDetails?: TaskDetailsListRelationFilter
    TeamAgents?: TeamAgentsListRelationFilter
  }

  export type TeamsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    AccountId?: SortOrder
    AgentId?: SortOrder
    TaskId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    area?: SortOrder
    alias?: SortOrder
    Accounts_AccountsToTeams_AccountId?: AccountsOrderByWithRelationInput
    Accounts_AccountsToTeams_AgentId?: AccountsOrderByWithRelationInput
    Tasks?: TasksOrderByWithRelationInput
    Statistics?: StatisticsOrderByRelationAggregateInput
    TaskDetails?: TaskDetailsOrderByRelationAggregateInput
    TeamAgents?: TeamAgentsOrderByRelationAggregateInput
  }

  export type TeamsWhereUniqueInput = {
    id?: number
  }

  export type TeamsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    AccountId?: SortOrder
    AgentId?: SortOrder
    TaskId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    area?: SortOrder
    alias?: SortOrder
    _count?: TeamsCountOrderByAggregateInput
    _avg?: TeamsAvgOrderByAggregateInput
    _max?: TeamsMaxOrderByAggregateInput
    _min?: TeamsMinOrderByAggregateInput
    _sum?: TeamsSumOrderByAggregateInput
  }

  export type TeamsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TeamsScalarWhereWithAggregatesInput>
    OR?: Enumerable<TeamsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TeamsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    AccountId?: IntNullableWithAggregatesFilter | number | null
    AgentId?: IntNullableWithAggregatesFilter | number | null
    TaskId?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    status?: StringNullableWithAggregatesFilter | string | null
    area?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    alias?: StringNullableWithAggregatesFilter | string | null
  }

  export type AccountsCreateInput = {
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    Services?: ServicesCreateNestedOneWithoutAccountsInput
    Alerts?: AlertsCreateNestedManyWithoutAccountsInput
    Careers?: CareersCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsCreateNestedManyWithoutAccountsInput
    Customers?: CustomersCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsCreateNestedManyWithoutAccountsInput
    Lands?: LandsCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutAccountsInput
    Orders?: OrdersCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsCreateNestedManyWithoutAccountsInput
    Posts?: PostsCreateNestedManyWithoutAccountsInput
    Reports?: ReportsCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsCreateNestedManyWithoutAccountsInput
    Tasks?: TasksCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsUncheckedCreateInput = {
    id?: number
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    ServiceKey?: string | null
    Alerts?: AlertsUncheckedCreateNestedManyWithoutAccountsInput
    Careers?: CareersUncheckedCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutAccountsInput
    Lands?: LandsUncheckedCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutAccountsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsUncheckedCreateNestedManyWithoutAccountsInput
    Posts?: PostsUncheckedCreateNestedManyWithoutAccountsInput
    Reports?: ReportsUncheckedCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsUncheckedCreateNestedManyWithoutAccountsInput
    Tasks?: TasksUncheckedCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsUncheckedCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsUpdateInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Services?: ServicesUpdateOneWithoutAccountsNestedInput
    Alerts?: AlertsUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ServiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    Alerts?: AlertsUncheckedUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUncheckedUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUncheckedUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUncheckedUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUncheckedUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUncheckedUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUncheckedUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUncheckedUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUncheckedUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUncheckedUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUncheckedUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsCreateManyInput = {
    id?: number
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    ServiceKey?: string | null
  }

  export type AccountsUpdateManyMutationInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type AccountsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ServiceKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertsCreateInput = {
    id?: bigint | number
    title?: string | null
    type: string
    category: string
    ReferenceId: number
    isRead?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    Accounts?: AccountsCreateNestedOneWithoutAlertsInput
  }

  export type AlertsUncheckedCreateInput = {
    id?: bigint | number
    title?: string | null
    type: string
    category: string
    AccountId?: number | null
    ReferenceId: number
    isRead?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AlertsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    ReferenceId?: IntFieldUpdateOperationsInput | number
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    Accounts?: AccountsUpdateOneWithoutAlertsNestedInput
  }

  export type AlertsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    ReferenceId?: IntFieldUpdateOperationsInput | number
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AlertsCreateManyInput = {
    id?: bigint | number
    title?: string | null
    type: string
    category: string
    AccountId?: number | null
    ReferenceId: number
    isRead?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AlertsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    ReferenceId?: IntFieldUpdateOperationsInput | number
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AlertsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    ReferenceId?: IntFieldUpdateOperationsInput | number
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CareersCreateInput = {
    title?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    content?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    Accounts?: AccountsCreateNestedOneWithoutCareersInput
  }

  export type CareersUncheckedCreateInput = {
    id?: number
    AccountId?: number | null
    title?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    content?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CareersUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Accounts?: AccountsUpdateOneWithoutCareersNestedInput
  }

  export type CareersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareersCreateManyInput = {
    id?: number
    AccountId?: number | null
    title?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    content?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CareersUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponsCreateInput = {
    name?: string | null
    code?: string | null
    quantity?: number | null
    maxRetry?: number | null
    unit?: string | null
    value?: number | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt: Date | string
    extra?: NullableJsonNullValueInput | InputJsonValue
    updatedAt: Date | string
    Discounts?: DiscountsCreateNestedManyWithoutCouponsInput
  }

  export type CouponsUncheckedCreateInput = {
    id?: number
    name?: string | null
    code?: string | null
    quantity?: number | null
    maxRetry?: number | null
    unit?: string | null
    value?: number | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt: Date | string
    extra?: NullableJsonNullValueInput | InputJsonValue
    updatedAt: Date | string
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutCouponsInput
  }

  export type CouponsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxRetry?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extra?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Discounts?: DiscountsUpdateManyWithoutCouponsNestedInput
  }

  export type CouponsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxRetry?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extra?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Discounts?: DiscountsUncheckedUpdateManyWithoutCouponsNestedInput
  }

  export type CouponsCreateManyInput = {
    id?: number
    name?: string | null
    code?: string | null
    quantity?: number | null
    maxRetry?: number | null
    unit?: string | null
    value?: number | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt: Date | string
    extra?: NullableJsonNullValueInput | InputJsonValue
    updatedAt: Date | string
  }

  export type CouponsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxRetry?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extra?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxRetry?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extra?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerTaskDetailsCreateInput = {
    type?: string | null
    address?: string | null
    villageName?: string | null
    category?: string | null
    etc?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: string | null
    y?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    createdAt: Date | string
    updatedAt: Date | string
    Accounts?: AccountsCreateNestedOneWithoutCustomerTaskDetailsInput
    Customers?: CustomersCreateNestedOneWithoutCustomerTaskDetailsInput
  }

  export type CustomerTaskDetailsUncheckedCreateInput = {
    id?: number
    AccountId?: number | null
    CustomerId?: number | null
    type?: string | null
    address?: string | null
    villageName?: string | null
    category?: string | null
    etc?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: string | null
    y?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CustomerTaskDetailsUpdateInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    villageName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    etc?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Accounts?: AccountsUpdateOneWithoutCustomerTaskDetailsNestedInput
    Customers?: CustomersUpdateOneWithoutCustomerTaskDetailsNestedInput
  }

  export type CustomerTaskDetailsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    villageName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    etc?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerTaskDetailsCreateManyInput = {
    id?: number
    AccountId?: number | null
    CustomerId?: number | null
    type?: string | null
    address?: string | null
    villageName?: string | null
    category?: string | null
    etc?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: string | null
    y?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CustomerTaskDetailsUpdateManyMutationInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    villageName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    etc?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerTaskDetailsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    villageName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    etc?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomersCreateInput = {
    name?: string | null
    email?: string | null
    phone?: string | null
    crops?: CustomersCreatecropsInput | Enumerable<string>
    createdAt: Date | string
    updatedAt: Date | string
    Accounts?: AccountsCreateNestedOneWithoutCustomersInput
    CustomerTaskDetails?: CustomerTaskDetailsCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateInput = {
    id?: number
    name?: string | null
    email?: string | null
    phone?: string | null
    crops?: CustomersCreatecropsInput | Enumerable<string>
    AccountId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    crops?: CustomersUpdatecropsInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Accounts?: AccountsUpdateOneWithoutCustomersNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    crops?: CustomersUpdatecropsInput | Enumerable<string>
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersCreateManyInput = {
    id?: number
    name?: string | null
    email?: string | null
    phone?: string | null
    crops?: CustomersCreatecropsInput | Enumerable<string>
    AccountId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CustomersUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    crops?: CustomersUpdatecropsInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    crops?: CustomersUpdatecropsInput | Enumerable<string>
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountsCreateInput = {
    name?: string | null
    price?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    Accounts?: AccountsCreateNestedOneWithoutDiscountsInput
    Coupons?: CouponsCreateNestedOneWithoutDiscountsInput
    Orders?: OrdersCreateNestedOneWithoutDiscountsInput
    Products?: ProductsCreateNestedOneWithoutDiscountsInput
  }

  export type DiscountsUncheckedCreateInput = {
    id?: number
    name?: string | null
    price?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    AccountId?: number | null
    OrderId?: number | null
    CouponId?: number | null
    ProductId?: number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DiscountsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    Accounts?: AccountsUpdateOneWithoutDiscountsNestedInput
    Coupons?: CouponsUpdateOneWithoutDiscountsNestedInput
    Orders?: OrdersUpdateOneWithoutDiscountsNestedInput
    Products?: ProductsUpdateOneWithoutDiscountsNestedInput
  }

  export type DiscountsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    OrderId?: NullableIntFieldUpdateOperationsInput | number | null
    CouponId?: NullableIntFieldUpdateOperationsInput | number | null
    ProductId?: NullableIntFieldUpdateOperationsInput | number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DiscountsCreateManyInput = {
    id?: number
    name?: string | null
    price?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    AccountId?: number | null
    OrderId?: number | null
    CouponId?: number | null
    ProductId?: number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DiscountsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filters?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DiscountsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    OrderId?: NullableIntFieldUpdateOperationsInput | number | null
    CouponId?: NullableIntFieldUpdateOperationsInput | number | null
    ProductId?: NullableIntFieldUpdateOperationsInput | number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EventsCreateInput = {
    id?: bigint | number
    table: string
    action?: string | null
    createdBy?: number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type EventsUncheckedCreateInput = {
    id?: bigint | number
    table: string
    action?: string | null
    createdBy?: number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type EventsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    table?: StringFieldUpdateOperationsInput | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    table?: StringFieldUpdateOperationsInput | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventsCreateManyInput = {
    id?: bigint | number
    table: string
    action?: string | null
    createdBy?: number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type EventsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    table?: StringFieldUpdateOperationsInput | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    table?: StringFieldUpdateOperationsInput | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeosCreateInput = {
    address?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: string | null
    y?: string | null
    pnu?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type GeosUncheckedCreateInput = {
    id?: number
    address?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: string | null
    y?: string | null
    pnu?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type GeosUpdateInput = {
    address?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    pnu?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    pnu?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeosCreateManyInput = {
    id?: number
    address?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: string | null
    y?: string | null
    pnu?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type GeosUpdateManyMutationInput = {
    address?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    pnu?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    pnu?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandsCreateInput = {
    id?: bigint | number
    is_active?: boolean | null
    type?: string | null
    villageName?: string | null
    status?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: string | null
    y?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    Accounts: AccountsCreateNestedOneWithoutLandsInput
  }

  export type LandsUncheckedCreateInput = {
    id?: bigint | number
    AccountId: number
    is_active?: boolean | null
    type?: string | null
    villageName?: string | null
    status?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: string | null
    y?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type LandsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    villageName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Accounts?: AccountsUpdateOneRequiredWithoutLandsNestedInput
  }

  export type LandsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    AccountId?: IntFieldUpdateOperationsInput | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    villageName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandsCreateManyInput = {
    id?: bigint | number
    AccountId: number
    is_active?: boolean | null
    type?: string | null
    villageName?: string | null
    status?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: string | null
    y?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type LandsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    villageName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    AccountId?: IntFieldUpdateOperationsInput | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    villageName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticesCreateInput = {
    startDate?: Date | string | null
    endDate?: Date | string | null
    imageURL?: string | null
    externalURL?: string | null
    order?: number | null
    active?: boolean | null
    deletedDate?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
    name?: string | null
  }

  export type NoticesUncheckedCreateInput = {
    id?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    imageURL?: string | null
    externalURL?: string | null
    order?: number | null
    active?: boolean | null
    deletedDate?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
    name?: string | null
  }

  export type NoticesUpdateInput = {
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    imageURL?: NullableStringFieldUpdateOperationsInput | string | null
    externalURL?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NoticesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    imageURL?: NullableStringFieldUpdateOperationsInput | string | null
    externalURL?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NoticesCreateManyInput = {
    id?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    imageURL?: string | null
    externalURL?: string | null
    order?: number | null
    active?: boolean | null
    deletedDate?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
    name?: string | null
  }

  export type NoticesUpdateManyMutationInput = {
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    imageURL?: NullableStringFieldUpdateOperationsInput | string | null
    externalURL?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NoticesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    imageURL?: NullableStringFieldUpdateOperationsInput | string | null
    externalURL?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationsCreateInput = {
    id?: bigint | number
    fcmToken: string
    sendedAt?: Date | string | null
    isSuccess?: boolean | null
    failReason?: string | null
    eventCode: string
    sendCode: string
    reservationCode: string
    sendCycleCode: string
    title: string
    message: string
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    Accounts: AccountsCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationsUncheckedCreateInput = {
    id?: bigint | number
    AccountId: number
    fcmToken: string
    sendedAt?: Date | string | null
    isSuccess?: boolean | null
    failReason?: string | null
    eventCode: string
    sendCode: string
    reservationCode: string
    sendCycleCode: string
    title: string
    message: string
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type NotificationsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fcmToken?: StringFieldUpdateOperationsInput | string
    sendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSuccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    failReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventCode?: StringFieldUpdateOperationsInput | string
    sendCode?: StringFieldUpdateOperationsInput | string
    reservationCode?: StringFieldUpdateOperationsInput | string
    sendCycleCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Accounts?: AccountsUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    AccountId?: IntFieldUpdateOperationsInput | number
    fcmToken?: StringFieldUpdateOperationsInput | string
    sendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSuccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    failReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventCode?: StringFieldUpdateOperationsInput | string
    sendCode?: StringFieldUpdateOperationsInput | string
    reservationCode?: StringFieldUpdateOperationsInput | string
    sendCycleCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsCreateManyInput = {
    id?: bigint | number
    AccountId: number
    fcmToken: string
    sendedAt?: Date | string | null
    isSuccess?: boolean | null
    failReason?: string | null
    eventCode: string
    sendCode: string
    reservationCode: string
    sendCycleCode: string
    title: string
    message: string
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type NotificationsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fcmToken?: StringFieldUpdateOperationsInput | string
    sendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSuccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    failReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventCode?: StringFieldUpdateOperationsInput | string
    sendCode?: StringFieldUpdateOperationsInput | string
    reservationCode?: StringFieldUpdateOperationsInput | string
    sendCycleCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    AccountId?: IntFieldUpdateOperationsInput | number
    fcmToken?: StringFieldUpdateOperationsInput | string
    sendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSuccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    failReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventCode?: StringFieldUpdateOperationsInput | string
    sendCode?: StringFieldUpdateOperationsInput | string
    reservationCode?: StringFieldUpdateOperationsInput | string
    sendCycleCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderHistoriesCreateInput = {
    name?: string | null
    payment?: string | null
    paymentMethod?: string | null
    externalUid?: string | null
    customerUid?: string | null
    merchantUid?: string | null
    reqAmount?: number | null
    paidAmount?: number | null
    status?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    Accounts?: AccountsCreateNestedOneWithoutOrderHistoriesInput
    Orders?: OrdersCreateNestedOneWithoutOrderHistoriesInput
    Products?: ProductsCreateNestedOneWithoutOrderHistoriesInput
  }

  export type OrderHistoriesUncheckedCreateInput = {
    id?: number
    name?: string | null
    payment?: string | null
    paymentMethod?: string | null
    externalUid?: string | null
    customerUid?: string | null
    merchantUid?: string | null
    reqAmount?: number | null
    paidAmount?: number | null
    status?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    AccountId?: number | null
    ProductId?: number | null
    OrderId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type OrderHistoriesUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    externalUid?: NullableStringFieldUpdateOperationsInput | string | null
    customerUid?: NullableStringFieldUpdateOperationsInput | string | null
    merchantUid?: NullableStringFieldUpdateOperationsInput | string | null
    reqAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Accounts?: AccountsUpdateOneWithoutOrderHistoriesNestedInput
    Orders?: OrdersUpdateOneWithoutOrderHistoriesNestedInput
    Products?: ProductsUpdateOneWithoutOrderHistoriesNestedInput
  }

  export type OrderHistoriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    externalUid?: NullableStringFieldUpdateOperationsInput | string | null
    customerUid?: NullableStringFieldUpdateOperationsInput | string | null
    merchantUid?: NullableStringFieldUpdateOperationsInput | string | null
    reqAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    ProductId?: NullableIntFieldUpdateOperationsInput | number | null
    OrderId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderHistoriesCreateManyInput = {
    id?: number
    name?: string | null
    payment?: string | null
    paymentMethod?: string | null
    externalUid?: string | null
    customerUid?: string | null
    merchantUid?: string | null
    reqAmount?: number | null
    paidAmount?: number | null
    status?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    AccountId?: number | null
    ProductId?: number | null
    OrderId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type OrderHistoriesUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    externalUid?: NullableStringFieldUpdateOperationsInput | string | null
    customerUid?: NullableStringFieldUpdateOperationsInput | string | null
    merchantUid?: NullableStringFieldUpdateOperationsInput | string | null
    reqAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderHistoriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    externalUid?: NullableStringFieldUpdateOperationsInput | string | null
    customerUid?: NullableStringFieldUpdateOperationsInput | string | null
    merchantUid?: NullableStringFieldUpdateOperationsInput | string | null
    reqAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    ProductId?: NullableIntFieldUpdateOperationsInput | number | null
    OrderId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrdersCreateInput = {
    name?: string | null
    payment?: string | null
    paymentMethod?: string | null
    externalUid?: string | null
    customerUid?: string | null
    merchantUid?: string | null
    reqAmount?: number | null
    paidAmount?: number | null
    status?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    expiredAt?: Date | string | null
    isSubscribe?: boolean | null
    issuedAt?: Date | string | null
    Accounts?: AccountsCreateNestedOneWithoutOrdersInput
    Products?: ProductsCreateNestedOneWithoutOrdersInput
    Discounts?: DiscountsCreateNestedManyWithoutOrdersInput
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutOrdersInput
  }

  export type OrdersUncheckedCreateInput = {
    id?: number
    name?: string | null
    payment?: string | null
    paymentMethod?: string | null
    externalUid?: string | null
    customerUid?: string | null
    merchantUid?: string | null
    reqAmount?: number | null
    paidAmount?: number | null
    status?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    AccountId?: number | null
    ProductId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    expiredAt?: Date | string | null
    isSubscribe?: boolean | null
    issuedAt?: Date | string | null
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutOrdersInput
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type OrdersUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    externalUid?: NullableStringFieldUpdateOperationsInput | string | null
    customerUid?: NullableStringFieldUpdateOperationsInput | string | null
    merchantUid?: NullableStringFieldUpdateOperationsInput | string | null
    reqAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Accounts?: AccountsUpdateOneWithoutOrdersNestedInput
    Products?: ProductsUpdateOneWithoutOrdersNestedInput
    Discounts?: DiscountsUpdateManyWithoutOrdersNestedInput
    OrderHistories?: OrderHistoriesUpdateManyWithoutOrdersNestedInput
  }

  export type OrdersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    externalUid?: NullableStringFieldUpdateOperationsInput | string | null
    customerUid?: NullableStringFieldUpdateOperationsInput | string | null
    merchantUid?: NullableStringFieldUpdateOperationsInput | string | null
    reqAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    ProductId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Discounts?: DiscountsUncheckedUpdateManyWithoutOrdersNestedInput
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type OrdersCreateManyInput = {
    id?: number
    name?: string | null
    payment?: string | null
    paymentMethod?: string | null
    externalUid?: string | null
    customerUid?: string | null
    merchantUid?: string | null
    reqAmount?: number | null
    paidAmount?: number | null
    status?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    AccountId?: number | null
    ProductId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    expiredAt?: Date | string | null
    isSubscribe?: boolean | null
    issuedAt?: Date | string | null
  }

  export type OrdersUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    externalUid?: NullableStringFieldUpdateOperationsInput | string | null
    customerUid?: NullableStringFieldUpdateOperationsInput | string | null
    merchantUid?: NullableStringFieldUpdateOperationsInput | string | null
    reqAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrdersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    externalUid?: NullableStringFieldUpdateOperationsInput | string | null
    customerUid?: NullableStringFieldUpdateOperationsInput | string | null
    merchantUid?: NullableStringFieldUpdateOperationsInput | string | null
    reqAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    ProductId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PermissionsCreateInput = {
    resource: string
    key: enum_Permissions_key
    resourceId: number
    createdAt: Date | string
    updatedAt: Date | string
    Accounts?: AccountsCreateNestedOneWithoutPermissionsInput
  }

  export type PermissionsUncheckedCreateInput = {
    id?: number
    resource: string
    key: enum_Permissions_key
    resourceId: number
    AccountId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type PermissionsUpdateInput = {
    resource?: StringFieldUpdateOperationsInput | string
    key?: Enumenum_Permissions_keyFieldUpdateOperationsInput | enum_Permissions_key
    resourceId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Accounts?: AccountsUpdateOneWithoutPermissionsNestedInput
  }

  export type PermissionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    resource?: StringFieldUpdateOperationsInput | string
    key?: Enumenum_Permissions_keyFieldUpdateOperationsInput | enum_Permissions_key
    resourceId?: IntFieldUpdateOperationsInput | number
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionsCreateManyInput = {
    id?: number
    resource: string
    key: enum_Permissions_key
    resourceId: number
    AccountId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type PermissionsUpdateManyMutationInput = {
    resource?: StringFieldUpdateOperationsInput | string
    key?: Enumenum_Permissions_keyFieldUpdateOperationsInput | enum_Permissions_key
    resourceId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    resource?: StringFieldUpdateOperationsInput | string
    key?: Enumenum_Permissions_keyFieldUpdateOperationsInput | enum_Permissions_key
    resourceId?: IntFieldUpdateOperationsInput | number
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAccountsCreateInput = {
    type?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    Accounts?: AccountsCreateNestedOneWithoutPostAccountsInput
    Posts?: PostsCreateNestedOneWithoutPostAccountsInput
  }

  export type PostAccountsUncheckedCreateInput = {
    id?: number
    AccountId?: number | null
    PostId?: number | null
    type?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type PostAccountsUpdateInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Accounts?: AccountsUpdateOneWithoutPostAccountsNestedInput
    Posts?: PostsUpdateOneWithoutPostAccountsNestedInput
  }

  export type PostAccountsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    PostId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAccountsCreateManyInput = {
    id?: number
    AccountId?: number | null
    PostId?: number | null
    type?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type PostAccountsUpdateManyMutationInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAccountsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    PostId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostsCreateInput = {
    category?: string | null
    type?: PostsCreatetypeInput | Enumerable<string>
    content?: string | null
    unit?: string | null
    price?: number | null
    location?: PostsCreatelocationInput | Enumerable<string>
    area?: Decimal | DecimalJsLike | number | string | null
    title?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: string | null
    viewCount?: number | null
    contactName?: string | null
    contactPhone?: string | null
    contactEmail?: string | null
    qualifications?: PostsCreatequalificationsInput | Enumerable<string>
    Accounts?: AccountsCreateNestedOneWithoutPostsInput
    PostAccounts?: PostAccountsCreateNestedManyWithoutPostsInput
  }

  export type PostsUncheckedCreateInput = {
    id?: number
    category?: string | null
    type?: PostsCreatetypeInput | Enumerable<string>
    content?: string | null
    unit?: string | null
    price?: number | null
    location?: PostsCreatelocationInput | Enumerable<string>
    area?: Decimal | DecimalJsLike | number | string | null
    title?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: string | null
    viewCount?: number | null
    AccountId?: number | null
    contactName?: string | null
    contactPhone?: string | null
    contactEmail?: string | null
    qualifications?: PostsCreatequalificationsInput | Enumerable<string>
    PostAccounts?: PostAccountsUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostsUpdateInput = {
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: PostsUpdatetypeInput | Enumerable<string>
    content?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    location?: PostsUpdatelocationInput | Enumerable<string>
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: PostsUpdatequalificationsInput | Enumerable<string>
    Accounts?: AccountsUpdateOneWithoutPostsNestedInput
    PostAccounts?: PostAccountsUpdateManyWithoutPostsNestedInput
  }

  export type PostsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: PostsUpdatetypeInput | Enumerable<string>
    content?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    location?: PostsUpdatelocationInput | Enumerable<string>
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: PostsUpdatequalificationsInput | Enumerable<string>
    PostAccounts?: PostAccountsUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type PostsCreateManyInput = {
    id?: number
    category?: string | null
    type?: PostsCreatetypeInput | Enumerable<string>
    content?: string | null
    unit?: string | null
    price?: number | null
    location?: PostsCreatelocationInput | Enumerable<string>
    area?: Decimal | DecimalJsLike | number | string | null
    title?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: string | null
    viewCount?: number | null
    AccountId?: number | null
    contactName?: string | null
    contactPhone?: string | null
    contactEmail?: string | null
    qualifications?: PostsCreatequalificationsInput | Enumerable<string>
  }

  export type PostsUpdateManyMutationInput = {
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: PostsUpdatetypeInput | Enumerable<string>
    content?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    location?: PostsUpdatelocationInput | Enumerable<string>
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: PostsUpdatequalificationsInput | Enumerable<string>
  }

  export type PostsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: PostsUpdatetypeInput | Enumerable<string>
    content?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    location?: PostsUpdatelocationInput | Enumerable<string>
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: PostsUpdatequalificationsInput | Enumerable<string>
  }

  export type ProductsCreateInput = {
    name?: string | null
    description?: string | null
    price?: number | null
    duration?: number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    isSubscribe?: boolean | null
    Discounts?: DiscountsCreateNestedManyWithoutProductsInput
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutProductsInput
    Orders?: OrdersCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateInput = {
    id?: number
    name?: string | null
    description?: string | null
    price?: number | null
    duration?: number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    isSubscribe?: boolean | null
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutProductsInput
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutProductsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSubscribe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Discounts?: DiscountsUpdateManyWithoutProductsNestedInput
    OrderHistories?: OrderHistoriesUpdateManyWithoutProductsNestedInput
    Orders?: OrdersUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSubscribe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Discounts?: DiscountsUncheckedUpdateManyWithoutProductsNestedInput
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutProductsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductsCreateManyInput = {
    id?: number
    name?: string | null
    description?: string | null
    price?: number | null
    duration?: number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    isSubscribe?: boolean | null
  }

  export type ProductsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSubscribe?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ProductsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSubscribe?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ReportsCreateInput = {
    name?: string | null
    isActive?: boolean | null
    isPrivate?: boolean | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    Accounts?: AccountsCreateNestedOneWithoutReportsInput
    Tasks?: TasksCreateNestedOneWithoutReportsInput
  }

  export type ReportsUncheckedCreateInput = {
    id?: number
    name?: string | null
    isActive?: boolean | null
    isPrivate?: boolean | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    TaskId?: number | null
    AccountId?: number | null
  }

  export type ReportsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPrivate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Accounts?: AccountsUpdateOneWithoutReportsNestedInput
    Tasks?: TasksUpdateOneWithoutReportsNestedInput
  }

  export type ReportsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPrivate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TaskId?: NullableIntFieldUpdateOperationsInput | number | null
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReportsCreateManyInput = {
    id?: number
    name?: string | null
    isActive?: boolean | null
    isPrivate?: boolean | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    TaskId?: number | null
    AccountId?: number | null
  }

  export type ReportsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPrivate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPrivate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TaskId?: NullableIntFieldUpdateOperationsInput | number | null
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SequelizeMetaCreateInput = {
    name: string
  }

  export type SequelizeMetaUncheckedCreateInput = {
    name: string
  }

  export type SequelizeMetaUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SequelizeMetaUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SequelizeMetaCreateManyInput = {
    name: string
  }

  export type SequelizeMetaUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SequelizeMetaUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ServicesCreateInput = {
    key: string
    description?: string | null
    isActive?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    Accounts?: AccountsCreateNestedManyWithoutServicesInput
  }

  export type ServicesUncheckedCreateInput = {
    key: string
    description?: string | null
    isActive?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    Accounts?: AccountsUncheckedCreateNestedManyWithoutServicesInput
  }

  export type ServicesUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Accounts?: AccountsUpdateManyWithoutServicesNestedInput
  }

  export type ServicesUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Accounts?: AccountsUncheckedUpdateManyWithoutServicesNestedInput
  }

  export type ServicesCreateManyInput = {
    key: string
    description?: string | null
    isActive?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ServicesUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatisticsCreateInput = {
    dailyWorkload?: Decimal | DecimalJsLike | number | string | null
    completedByOwner?: Decimal | DecimalJsLike | number | string | null
    completedBySelf?: Decimal | DecimalJsLike | number | string | null
    createdAt: Date | string
    updatedAt: Date | string
    Accounts?: AccountsCreateNestedOneWithoutStatisticsInput
    Tasks?: TasksCreateNestedOneWithoutStatisticsInput
    Teams?: TeamsCreateNestedOneWithoutStatisticsInput
  }

  export type StatisticsUncheckedCreateInput = {
    id?: number
    AgentId?: number | null
    TeamId?: number | null
    TaskId?: number | null
    dailyWorkload?: Decimal | DecimalJsLike | number | string | null
    completedByOwner?: Decimal | DecimalJsLike | number | string | null
    completedBySelf?: Decimal | DecimalJsLike | number | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type StatisticsUpdateInput = {
    dailyWorkload?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedByOwner?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedBySelf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Accounts?: AccountsUpdateOneWithoutStatisticsNestedInput
    Tasks?: TasksUpdateOneWithoutStatisticsNestedInput
    Teams?: TeamsUpdateOneWithoutStatisticsNestedInput
  }

  export type StatisticsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    AgentId?: NullableIntFieldUpdateOperationsInput | number | null
    TeamId?: NullableIntFieldUpdateOperationsInput | number | null
    TaskId?: NullableIntFieldUpdateOperationsInput | number | null
    dailyWorkload?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedByOwner?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedBySelf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatisticsCreateManyInput = {
    id?: number
    AgentId?: number | null
    TeamId?: number | null
    TaskId?: number | null
    dailyWorkload?: Decimal | DecimalJsLike | number | string | null
    completedByOwner?: Decimal | DecimalJsLike | number | string | null
    completedBySelf?: Decimal | DecimalJsLike | number | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type StatisticsUpdateManyMutationInput = {
    dailyWorkload?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedByOwner?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedBySelf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatisticsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    AgentId?: NullableIntFieldUpdateOperationsInput | number | null
    TeamId?: NullableIntFieldUpdateOperationsInput | number | null
    TaskId?: NullableIntFieldUpdateOperationsInput | number | null
    dailyWorkload?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedByOwner?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedBySelf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscribesCreateInput = {
    fcmToken: string
    createdAt: Date | string
    updatedAt: Date | string
    Accounts: AccountsCreateNestedOneWithoutSubscribesInput
  }

  export type SubscribesUncheckedCreateInput = {
    id?: number
    AccountId: number
    fcmToken: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type SubscribesUpdateInput = {
    fcmToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Accounts?: AccountsUpdateOneRequiredWithoutSubscribesNestedInput
  }

  export type SubscribesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    AccountId?: IntFieldUpdateOperationsInput | number
    fcmToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscribesCreateManyInput = {
    id?: number
    AccountId: number
    fcmToken: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type SubscribesUpdateManyMutationInput = {
    fcmToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscribesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    AccountId?: IntFieldUpdateOperationsInput | number
    fcmToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskDetailResourcesCreateInput = {
    content?: string | null
    type?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    group?: string | null
    Accounts?: AccountsCreateNestedOneWithoutTaskDetailResourcesInput
    TaskDetails?: TaskDetailsCreateNestedOneWithoutTaskDetailResourcesInput
  }

  export type TaskDetailResourcesUncheckedCreateInput = {
    id?: number
    content?: string | null
    type?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    TaskDetailId?: number | null
    AccountId?: number | null
    group?: string | null
  }

  export type TaskDetailResourcesUpdateInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    Accounts?: AccountsUpdateOneWithoutTaskDetailResourcesNestedInput
    TaskDetails?: TaskDetailsUpdateOneWithoutTaskDetailResourcesNestedInput
  }

  export type TaskDetailResourcesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TaskDetailId?: NullableIntFieldUpdateOperationsInput | number | null
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    group?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskDetailResourcesCreateManyInput = {
    id?: number
    content?: string | null
    type?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    TaskDetailId?: number | null
    AccountId?: number | null
    group?: string | null
  }

  export type TaskDetailResourcesUpdateManyMutationInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskDetailResourcesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TaskDetailId?: NullableIntFieldUpdateOperationsInput | number | null
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    group?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskDetailsCreateInput = {
    type?: string | null
    address?: string | null
    villageName?: string | null
    pushUser?: string | null
    category?: string | null
    etc?: string | null
    status?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    assignedDays?: number | null
    assignedUser?: string | null
    y?: string | null
    x?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    pushPhone?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    memo?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    Accounts?: AccountsCreateNestedOneWithoutTaskDetailsInput
    Tasks?: TasksCreateNestedOneWithoutTaskDetailsInput
    Teams?: TeamsCreateNestedOneWithoutTaskDetailsInput
    TaskDetailResources?: TaskDetailResourcesCreateNestedManyWithoutTaskDetailsInput
  }

  export type TaskDetailsUncheckedCreateInput = {
    id?: number
    AccountId?: number | null
    TaskId?: number | null
    type?: string | null
    address?: string | null
    villageName?: string | null
    pushUser?: string | null
    category?: string | null
    etc?: string | null
    status?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    assignedDays?: number | null
    assignedUser?: string | null
    TeamId?: number | null
    y?: string | null
    x?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    pushPhone?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    memo?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    TaskDetailResources?: TaskDetailResourcesUncheckedCreateNestedManyWithoutTaskDetailsInput
  }

  export type TaskDetailsUpdateInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    villageName?: NullableStringFieldUpdateOperationsInput | string | null
    pushUser?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    etc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedDays?: NullableIntFieldUpdateOperationsInput | number | null
    assignedUser?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pushPhone?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    Accounts?: AccountsUpdateOneWithoutTaskDetailsNestedInput
    Tasks?: TasksUpdateOneWithoutTaskDetailsNestedInput
    Teams?: TeamsUpdateOneWithoutTaskDetailsNestedInput
    TaskDetailResources?: TaskDetailResourcesUpdateManyWithoutTaskDetailsNestedInput
  }

  export type TaskDetailsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    TaskId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    villageName?: NullableStringFieldUpdateOperationsInput | string | null
    pushUser?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    etc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedDays?: NullableIntFieldUpdateOperationsInput | number | null
    assignedUser?: NullableStringFieldUpdateOperationsInput | string | null
    TeamId?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pushPhone?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    TaskDetailResources?: TaskDetailResourcesUncheckedUpdateManyWithoutTaskDetailsNestedInput
  }

  export type TaskDetailsCreateManyInput = {
    id?: number
    AccountId?: number | null
    TaskId?: number | null
    type?: string | null
    address?: string | null
    villageName?: string | null
    pushUser?: string | null
    category?: string | null
    etc?: string | null
    status?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    assignedDays?: number | null
    assignedUser?: string | null
    TeamId?: number | null
    y?: string | null
    x?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    pushPhone?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    memo?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TaskDetailsUpdateManyMutationInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    villageName?: NullableStringFieldUpdateOperationsInput | string | null
    pushUser?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    etc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedDays?: NullableIntFieldUpdateOperationsInput | number | null
    assignedUser?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pushPhone?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TaskDetailsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    TaskId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    villageName?: NullableStringFieldUpdateOperationsInput | string | null
    pushUser?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    etc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedDays?: NullableIntFieldUpdateOperationsInput | number | null
    assignedUser?: NullableStringFieldUpdateOperationsInput | string | null
    TeamId?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pushPhone?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TaskGroupsCreateInput = {
    path?: string | null
    name?: string | null
    status?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    area?: Decimal | DecimalJsLike | number | string | null
    createType?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    Accounts?: AccountsCreateNestedOneWithoutTaskGroupsInput
    Tasks?: TasksCreateNestedManyWithoutTaskGroupsInput
  }

  export type TaskGroupsUncheckedCreateInput = {
    id?: number
    path?: string | null
    name?: string | null
    status?: string | null
    AccountId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    area?: Decimal | DecimalJsLike | number | string | null
    createType?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    Tasks?: TasksUncheckedCreateNestedManyWithoutTaskGroupsInput
  }

  export type TaskGroupsUpdateInput = {
    path?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createType?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    Accounts?: AccountsUpdateOneWithoutTaskGroupsNestedInput
    Tasks?: TasksUpdateManyWithoutTaskGroupsNestedInput
  }

  export type TaskGroupsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createType?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    Tasks?: TasksUncheckedUpdateManyWithoutTaskGroupsNestedInput
  }

  export type TaskGroupsCreateManyInput = {
    id?: number
    path?: string | null
    name?: string | null
    status?: string | null
    AccountId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    area?: Decimal | DecimalJsLike | number | string | null
    createType?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TaskGroupsUpdateManyMutationInput = {
    path?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createType?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TaskGroupsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createType?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TasksCreateInput = {
    name?: string | null
    status?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    workingDays?: number | null
    workingTeamsCnt?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    area?: Decimal | DecimalJsLike | number | string | null
    isPaid?: boolean | null
    createType?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: Decimal | DecimalJsLike | number | string | null
    Accounts?: AccountsCreateNestedOneWithoutTasksInput
    TaskGroups?: TaskGroupsCreateNestedOneWithoutTasksInput
    Reports?: ReportsCreateNestedManyWithoutTasksInput
    Statistics?: StatisticsCreateNestedManyWithoutTasksInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutTasksInput
    Teams?: TeamsCreateNestedManyWithoutTasksInput
  }

  export type TasksUncheckedCreateInput = {
    id?: number
    name?: string | null
    status?: string | null
    AccountId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    workingDays?: number | null
    workingTeamsCnt?: number | null
    TaskGroupId?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    area?: Decimal | DecimalJsLike | number | string | null
    isPaid?: boolean | null
    createType?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: Decimal | DecimalJsLike | number | string | null
    Reports?: ReportsUncheckedCreateNestedManyWithoutTasksInput
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutTasksInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutTasksInput
    Teams?: TeamsUncheckedCreateNestedManyWithoutTasksInput
  }

  export type TasksUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: NullableIntFieldUpdateOperationsInput | number | null
    workingTeamsCnt?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createType?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Accounts?: AccountsUpdateOneWithoutTasksNestedInput
    TaskGroups?: TaskGroupsUpdateOneWithoutTasksNestedInput
    Reports?: ReportsUpdateManyWithoutTasksNestedInput
    Statistics?: StatisticsUpdateManyWithoutTasksNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutTasksNestedInput
    Teams?: TeamsUpdateManyWithoutTasksNestedInput
  }

  export type TasksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: NullableIntFieldUpdateOperationsInput | number | null
    workingTeamsCnt?: NullableIntFieldUpdateOperationsInput | number | null
    TaskGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createType?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Reports?: ReportsUncheckedUpdateManyWithoutTasksNestedInput
    Statistics?: StatisticsUncheckedUpdateManyWithoutTasksNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutTasksNestedInput
    Teams?: TeamsUncheckedUpdateManyWithoutTasksNestedInput
  }

  export type TasksCreateManyInput = {
    id?: number
    name?: string | null
    status?: string | null
    AccountId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    workingDays?: number | null
    workingTeamsCnt?: number | null
    TaskGroupId?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    area?: Decimal | DecimalJsLike | number | string | null
    isPaid?: boolean | null
    createType?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: Decimal | DecimalJsLike | number | string | null
  }

  export type TasksUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: NullableIntFieldUpdateOperationsInput | number | null
    workingTeamsCnt?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createType?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type TasksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: NullableIntFieldUpdateOperationsInput | number | null
    workingTeamsCnt?: NullableIntFieldUpdateOperationsInput | number | null
    TaskGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createType?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type TeamAgentsCreateInput = {
    isActive?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    Accounts: AccountsCreateNestedOneWithoutTeamAgentsInput
    Teams: TeamsCreateNestedOneWithoutTeamAgentsInput
  }

  export type TeamAgentsUncheckedCreateInput = {
    AgentId: number
    TeamId: number
    isActive?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TeamAgentsUpdateInput = {
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Accounts?: AccountsUpdateOneRequiredWithoutTeamAgentsNestedInput
    Teams?: TeamsUpdateOneRequiredWithoutTeamAgentsNestedInput
  }

  export type TeamAgentsUncheckedUpdateInput = {
    AgentId?: IntFieldUpdateOperationsInput | number
    TeamId?: IntFieldUpdateOperationsInput | number
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamAgentsCreateManyInput = {
    AgentId: number
    TeamId: number
    isActive?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TeamAgentsUpdateManyMutationInput = {
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamAgentsUncheckedUpdateManyInput = {
    AgentId?: IntFieldUpdateOperationsInput | number
    TeamId?: IntFieldUpdateOperationsInput | number
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamsCreateInput = {
    name?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    status?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    alias?: string | null
    Accounts_AccountsToTeams_AccountId?: AccountsCreateNestedOneWithoutTeams_AccountsToTeams_AccountIdInput
    Accounts_AccountsToTeams_AgentId?: AccountsCreateNestedOneWithoutTeams_AccountsToTeams_AgentIdInput
    Tasks?: TasksCreateNestedOneWithoutTeamsInput
    Statistics?: StatisticsCreateNestedManyWithoutTeamsInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutTeamsInput
    TeamAgents?: TeamAgentsCreateNestedManyWithoutTeamsInput
  }

  export type TeamsUncheckedCreateInput = {
    id?: number
    name?: string | null
    AccountId?: number | null
    AgentId?: number | null
    TaskId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    status?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    alias?: string | null
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutTeamsInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutTeamsInput
    TeamAgents?: TeamAgentsUncheckedCreateNestedManyWithoutTeamsInput
  }

  export type TeamsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    Accounts_AccountsToTeams_AccountId?: AccountsUpdateOneWithoutTeams_AccountsToTeams_AccountIdNestedInput
    Accounts_AccountsToTeams_AgentId?: AccountsUpdateOneWithoutTeams_AccountsToTeams_AgentIdNestedInput
    Tasks?: TasksUpdateOneWithoutTeamsNestedInput
    Statistics?: StatisticsUpdateManyWithoutTeamsNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutTeamsNestedInput
    TeamAgents?: TeamAgentsUpdateManyWithoutTeamsNestedInput
  }

  export type TeamsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    AgentId?: NullableIntFieldUpdateOperationsInput | number | null
    TaskId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    Statistics?: StatisticsUncheckedUpdateManyWithoutTeamsNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutTeamsNestedInput
    TeamAgents?: TeamAgentsUncheckedUpdateManyWithoutTeamsNestedInput
  }

  export type TeamsCreateManyInput = {
    id?: number
    name?: string | null
    AccountId?: number | null
    AgentId?: number | null
    TaskId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    status?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    alias?: string | null
  }

  export type TeamsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeamsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    AgentId?: NullableIntFieldUpdateOperationsInput | number | null
    TaskId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }
  export type JsonNullableFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase>, Exclude<keyof Required<JsonNullableFilterBase>, 'path'>>,
        Required<JsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase>, 'path'>>

  export type JsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: Array<string>
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type ServicesRelationFilter = {
    is?: ServicesWhereInput | null
    isNot?: ServicesWhereInput | null
  }

  export type AlertsListRelationFilter = {
    every?: AlertsWhereInput
    some?: AlertsWhereInput
    none?: AlertsWhereInput
  }

  export type CareersListRelationFilter = {
    every?: CareersWhereInput
    some?: CareersWhereInput
    none?: CareersWhereInput
  }

  export type CustomerTaskDetailsListRelationFilter = {
    every?: CustomerTaskDetailsWhereInput
    some?: CustomerTaskDetailsWhereInput
    none?: CustomerTaskDetailsWhereInput
  }

  export type CustomersListRelationFilter = {
    every?: CustomersWhereInput
    some?: CustomersWhereInput
    none?: CustomersWhereInput
  }

  export type DiscountsListRelationFilter = {
    every?: DiscountsWhereInput
    some?: DiscountsWhereInput
    none?: DiscountsWhereInput
  }

  export type LandsListRelationFilter = {
    every?: LandsWhereInput
    some?: LandsWhereInput
    none?: LandsWhereInput
  }

  export type NotificationsListRelationFilter = {
    every?: NotificationsWhereInput
    some?: NotificationsWhereInput
    none?: NotificationsWhereInput
  }

  export type OrderHistoriesListRelationFilter = {
    every?: OrderHistoriesWhereInput
    some?: OrderHistoriesWhereInput
    none?: OrderHistoriesWhereInput
  }

  export type OrdersListRelationFilter = {
    every?: OrdersWhereInput
    some?: OrdersWhereInput
    none?: OrdersWhereInput
  }

  export type PermissionsListRelationFilter = {
    every?: PermissionsWhereInput
    some?: PermissionsWhereInput
    none?: PermissionsWhereInput
  }

  export type PostAccountsListRelationFilter = {
    every?: PostAccountsWhereInput
    some?: PostAccountsWhereInput
    none?: PostAccountsWhereInput
  }

  export type PostsListRelationFilter = {
    every?: PostsWhereInput
    some?: PostsWhereInput
    none?: PostsWhereInput
  }

  export type ReportsListRelationFilter = {
    every?: ReportsWhereInput
    some?: ReportsWhereInput
    none?: ReportsWhereInput
  }

  export type StatisticsListRelationFilter = {
    every?: StatisticsWhereInput
    some?: StatisticsWhereInput
    none?: StatisticsWhereInput
  }

  export type SubscribesListRelationFilter = {
    every?: SubscribesWhereInput
    some?: SubscribesWhereInput
    none?: SubscribesWhereInput
  }

  export type TaskDetailResourcesListRelationFilter = {
    every?: TaskDetailResourcesWhereInput
    some?: TaskDetailResourcesWhereInput
    none?: TaskDetailResourcesWhereInput
  }

  export type TaskDetailsListRelationFilter = {
    every?: TaskDetailsWhereInput
    some?: TaskDetailsWhereInput
    none?: TaskDetailsWhereInput
  }

  export type TaskGroupsListRelationFilter = {
    every?: TaskGroupsWhereInput
    some?: TaskGroupsWhereInput
    none?: TaskGroupsWhereInput
  }

  export type TasksListRelationFilter = {
    every?: TasksWhereInput
    some?: TasksWhereInput
    none?: TasksWhereInput
  }

  export type TeamAgentsListRelationFilter = {
    every?: TeamAgentsWhereInput
    some?: TeamAgentsWhereInput
    none?: TeamAgentsWhereInput
  }

  export type TeamsListRelationFilter = {
    every?: TeamsWhereInput
    some?: TeamsWhereInput
    none?: TeamsWhereInput
  }

  export type AlertsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CareersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerTaskDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DiscountsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LandsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderHistoriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrdersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostAccountsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StatisticsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscribesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskDetailResourcesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskGroupsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TasksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamAgentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountsCountOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    verifyToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: SortOrder
    isAdmin?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    isVerify?: SortOrder
    isApprove?: SortOrder
    ServiceKey?: SortOrder
  }

  export type AccountsAvgOrderByAggregateInput = {
    id?: SortOrder
    verifyToken?: SortOrder
  }

  export type AccountsMaxOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    verifyToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAdmin?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    isVerify?: SortOrder
    isApprove?: SortOrder
    ServiceKey?: SortOrder
  }

  export type AccountsMinOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    verifyToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAdmin?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    isVerify?: SortOrder
    isApprove?: SortOrder
    ServiceKey?: SortOrder
  }

  export type AccountsSumOrderByAggregateInput = {
    id?: SortOrder
    verifyToken?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }
  export type JsonNullableWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: Array<string>
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntNullableFilter
    _min?: NestedJsonNullableFilter
    _max?: NestedJsonNullableFilter
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type BigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type AccountsRelationFilter = {
    is?: AccountsWhereInput | null
    isNot?: AccountsWhereInput | null
  }

  export type AlertsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    category?: SortOrder
    AccountId?: SortOrder
    ReferenceId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    data?: SortOrder
  }

  export type AlertsAvgOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    ReferenceId?: SortOrder
  }

  export type AlertsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    category?: SortOrder
    AccountId?: SortOrder
    ReferenceId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    category?: SortOrder
    AccountId?: SortOrder
    ReferenceId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertsSumOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    ReferenceId?: SortOrder
  }

  export type BigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type CareersCountOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CareersAvgOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
  }

  export type CareersMaxOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CareersMinOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CareersSumOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type CouponsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    quantity?: SortOrder
    maxRetry?: SortOrder
    unit?: SortOrder
    value?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    createdAt?: SortOrder
    extra?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponsAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    maxRetry?: SortOrder
    value?: SortOrder
  }

  export type CouponsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    quantity?: SortOrder
    maxRetry?: SortOrder
    unit?: SortOrder
    value?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    quantity?: SortOrder
    maxRetry?: SortOrder
    unit?: SortOrder
    value?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponsSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    maxRetry?: SortOrder
    value?: SortOrder
  }

  export type DecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type CustomersRelationFilter = {
    is?: CustomersWhereInput | null
    isNot?: CustomersWhereInput | null
  }

  export type CustomerTaskDetailsAccountIdCustomerIdXYCompoundUniqueInput = {
    AccountId: number
    CustomerId: number
    x: string
    y: string
  }

  export type CustomerTaskDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    CustomerId?: SortOrder
    type?: SortOrder
    address?: SortOrder
    villageName?: SortOrder
    category?: SortOrder
    etc?: SortOrder
    geometry?: SortOrder
    x?: SortOrder
    y?: SortOrder
    area?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerTaskDetailsAvgOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    CustomerId?: SortOrder
    area?: SortOrder
  }

  export type CustomerTaskDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    CustomerId?: SortOrder
    type?: SortOrder
    address?: SortOrder
    villageName?: SortOrder
    category?: SortOrder
    etc?: SortOrder
    x?: SortOrder
    y?: SortOrder
    area?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerTaskDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    CustomerId?: SortOrder
    type?: SortOrder
    address?: SortOrder
    villageName?: SortOrder
    category?: SortOrder
    etc?: SortOrder
    x?: SortOrder
    y?: SortOrder
    area?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerTaskDetailsSumOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    CustomerId?: SortOrder
    area?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type StringNullableListFilter = {
    equals?: Enumerable<string> | null
    has?: string | null
    hasEvery?: Enumerable<string>
    hasSome?: Enumerable<string>
    isEmpty?: boolean
  }

  export type CustomersAccountIdPhoneEmailCompoundUniqueInput = {
    AccountId: number
    phone: string
    email: string
  }

  export type CustomersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    crops?: SortOrder
    AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomersAvgOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
  }

  export type CustomersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomersSumOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type CouponsRelationFilter = {
    is?: CouponsWhereInput | null
    isNot?: CouponsWhereInput | null
  }

  export type OrdersRelationFilter = {
    is?: OrdersWhereInput | null
    isNot?: OrdersWhereInput | null
  }

  export type ProductsRelationFilter = {
    is?: ProductsWhereInput | null
    isNot?: ProductsWhereInput | null
  }

  export type DiscountsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    AccountId?: SortOrder
    OrderId?: SortOrder
    CouponId?: SortOrder
    ProductId?: SortOrder
    filters?: SortOrder
  }

  export type DiscountsAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    AccountId?: SortOrder
    OrderId?: SortOrder
    CouponId?: SortOrder
    ProductId?: SortOrder
  }

  export type DiscountsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    AccountId?: SortOrder
    OrderId?: SortOrder
    CouponId?: SortOrder
    ProductId?: SortOrder
  }

  export type DiscountsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    AccountId?: SortOrder
    OrderId?: SortOrder
    CouponId?: SortOrder
    ProductId?: SortOrder
  }

  export type DiscountsSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    AccountId?: SortOrder
    OrderId?: SortOrder
    CouponId?: SortOrder
    ProductId?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type EventsCountOrderByAggregateInput = {
    id?: SortOrder
    table?: SortOrder
    action?: SortOrder
    createdBy?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventsAvgOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
  }

  export type EventsMaxOrderByAggregateInput = {
    id?: SortOrder
    table?: SortOrder
    action?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventsMinOrderByAggregateInput = {
    id?: SortOrder
    table?: SortOrder
    action?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventsSumOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
  }

  export type GeosCountOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    geometry?: SortOrder
    x?: SortOrder
    y?: SortOrder
    pnu?: SortOrder
    area?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GeosAvgOrderByAggregateInput = {
    id?: SortOrder
    area?: SortOrder
  }

  export type GeosMaxOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    x?: SortOrder
    y?: SortOrder
    pnu?: SortOrder
    area?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GeosMinOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    x?: SortOrder
    y?: SortOrder
    pnu?: SortOrder
    area?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GeosSumOrderByAggregateInput = {
    id?: SortOrder
    area?: SortOrder
  }

  export type LandsCountOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    is_active?: SortOrder
    type?: SortOrder
    villageName?: SortOrder
    status?: SortOrder
    geometry?: SortOrder
    x?: SortOrder
    y?: SortOrder
    area?: SortOrder
    extra?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LandsAvgOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    area?: SortOrder
  }

  export type LandsMaxOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    is_active?: SortOrder
    type?: SortOrder
    villageName?: SortOrder
    status?: SortOrder
    x?: SortOrder
    y?: SortOrder
    area?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LandsMinOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    is_active?: SortOrder
    type?: SortOrder
    villageName?: SortOrder
    status?: SortOrder
    x?: SortOrder
    y?: SortOrder
    area?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LandsSumOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    area?: SortOrder
  }

  export type NoticesCountOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    imageURL?: SortOrder
    externalURL?: SortOrder
    order?: SortOrder
    active?: SortOrder
    deletedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
  }

  export type NoticesAvgOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type NoticesMaxOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    imageURL?: SortOrder
    externalURL?: SortOrder
    order?: SortOrder
    active?: SortOrder
    deletedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
  }

  export type NoticesMinOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    imageURL?: SortOrder
    externalURL?: SortOrder
    order?: SortOrder
    active?: SortOrder
    deletedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
  }

  export type NoticesSumOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type NotificationsCountOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    fcmToken?: SortOrder
    sendedAt?: SortOrder
    isSuccess?: SortOrder
    failReason?: SortOrder
    eventCode?: SortOrder
    sendCode?: SortOrder
    reservationCode?: SortOrder
    sendCycleCode?: SortOrder
    title?: SortOrder
    message?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationsAvgOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
  }

  export type NotificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    fcmToken?: SortOrder
    sendedAt?: SortOrder
    isSuccess?: SortOrder
    failReason?: SortOrder
    eventCode?: SortOrder
    sendCode?: SortOrder
    reservationCode?: SortOrder
    sendCycleCode?: SortOrder
    title?: SortOrder
    message?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationsMinOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    fcmToken?: SortOrder
    sendedAt?: SortOrder
    isSuccess?: SortOrder
    failReason?: SortOrder
    eventCode?: SortOrder
    sendCode?: SortOrder
    reservationCode?: SortOrder
    sendCycleCode?: SortOrder
    title?: SortOrder
    message?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationsSumOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
  }

  export type OrderHistoriesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    payment?: SortOrder
    paymentMethod?: SortOrder
    externalUid?: SortOrder
    customerUid?: SortOrder
    merchantUid?: SortOrder
    reqAmount?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    extra?: SortOrder
    AccountId?: SortOrder
    ProductId?: SortOrder
    OrderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderHistoriesAvgOrderByAggregateInput = {
    id?: SortOrder
    reqAmount?: SortOrder
    paidAmount?: SortOrder
    AccountId?: SortOrder
    ProductId?: SortOrder
    OrderId?: SortOrder
  }

  export type OrderHistoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    payment?: SortOrder
    paymentMethod?: SortOrder
    externalUid?: SortOrder
    customerUid?: SortOrder
    merchantUid?: SortOrder
    reqAmount?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    AccountId?: SortOrder
    ProductId?: SortOrder
    OrderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderHistoriesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    payment?: SortOrder
    paymentMethod?: SortOrder
    externalUid?: SortOrder
    customerUid?: SortOrder
    merchantUid?: SortOrder
    reqAmount?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    AccountId?: SortOrder
    ProductId?: SortOrder
    OrderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderHistoriesSumOrderByAggregateInput = {
    id?: SortOrder
    reqAmount?: SortOrder
    paidAmount?: SortOrder
    AccountId?: SortOrder
    ProductId?: SortOrder
    OrderId?: SortOrder
  }

  export type OrdersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    payment?: SortOrder
    paymentMethod?: SortOrder
    externalUid?: SortOrder
    customerUid?: SortOrder
    merchantUid?: SortOrder
    reqAmount?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    extra?: SortOrder
    AccountId?: SortOrder
    ProductId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiredAt?: SortOrder
    isSubscribe?: SortOrder
    issuedAt?: SortOrder
  }

  export type OrdersAvgOrderByAggregateInput = {
    id?: SortOrder
    reqAmount?: SortOrder
    paidAmount?: SortOrder
    AccountId?: SortOrder
    ProductId?: SortOrder
  }

  export type OrdersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    payment?: SortOrder
    paymentMethod?: SortOrder
    externalUid?: SortOrder
    customerUid?: SortOrder
    merchantUid?: SortOrder
    reqAmount?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    AccountId?: SortOrder
    ProductId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiredAt?: SortOrder
    isSubscribe?: SortOrder
    issuedAt?: SortOrder
  }

  export type OrdersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    payment?: SortOrder
    paymentMethod?: SortOrder
    externalUid?: SortOrder
    customerUid?: SortOrder
    merchantUid?: SortOrder
    reqAmount?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    AccountId?: SortOrder
    ProductId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiredAt?: SortOrder
    isSubscribe?: SortOrder
    issuedAt?: SortOrder
  }

  export type OrdersSumOrderByAggregateInput = {
    id?: SortOrder
    reqAmount?: SortOrder
    paidAmount?: SortOrder
    AccountId?: SortOrder
    ProductId?: SortOrder
  }

  export type Enumenum_Permissions_keyFilter = {
    equals?: enum_Permissions_key
    in?: Enumerable<enum_Permissions_key>
    notIn?: Enumerable<enum_Permissions_key>
    not?: NestedEnumenum_Permissions_keyFilter | enum_Permissions_key
  }

  export type PermissionsCountOrderByAggregateInput = {
    id?: SortOrder
    resource?: SortOrder
    key?: SortOrder
    resourceId?: SortOrder
    AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionsAvgOrderByAggregateInput = {
    id?: SortOrder
    resourceId?: SortOrder
    AccountId?: SortOrder
  }

  export type PermissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    resource?: SortOrder
    key?: SortOrder
    resourceId?: SortOrder
    AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionsMinOrderByAggregateInput = {
    id?: SortOrder
    resource?: SortOrder
    key?: SortOrder
    resourceId?: SortOrder
    AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionsSumOrderByAggregateInput = {
    id?: SortOrder
    resourceId?: SortOrder
    AccountId?: SortOrder
  }

  export type Enumenum_Permissions_keyWithAggregatesFilter = {
    equals?: enum_Permissions_key
    in?: Enumerable<enum_Permissions_key>
    notIn?: Enumerable<enum_Permissions_key>
    not?: NestedEnumenum_Permissions_keyWithAggregatesFilter | enum_Permissions_key
    _count?: NestedIntFilter
    _min?: NestedEnumenum_Permissions_keyFilter
    _max?: NestedEnumenum_Permissions_keyFilter
  }

  export type PostsRelationFilter = {
    is?: PostsWhereInput | null
    isNot?: PostsWhereInput | null
  }

  export type PostAccountsTypePostIdAccountIdCompoundUniqueInput = {
    type: string
    PostId: number
    AccountId: number
  }

  export type PostAccountsCountOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    PostId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostAccountsAvgOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    PostId?: SortOrder
  }

  export type PostAccountsMaxOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    PostId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostAccountsMinOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    PostId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostAccountsSumOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    PostId?: SortOrder
  }

  export type PostsCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    type?: SortOrder
    content?: SortOrder
    unit?: SortOrder
    price?: SortOrder
    location?: SortOrder
    area?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    viewCount?: SortOrder
    AccountId?: SortOrder
    contactName?: SortOrder
    contactPhone?: SortOrder
    contactEmail?: SortOrder
    qualifications?: SortOrder
  }

  export type PostsAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    area?: SortOrder
    viewCount?: SortOrder
    AccountId?: SortOrder
  }

  export type PostsMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    content?: SortOrder
    unit?: SortOrder
    price?: SortOrder
    area?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    viewCount?: SortOrder
    AccountId?: SortOrder
    contactName?: SortOrder
    contactPhone?: SortOrder
    contactEmail?: SortOrder
  }

  export type PostsMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    content?: SortOrder
    unit?: SortOrder
    price?: SortOrder
    area?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    viewCount?: SortOrder
    AccountId?: SortOrder
    contactName?: SortOrder
    contactPhone?: SortOrder
    contactEmail?: SortOrder
  }

  export type PostsSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    area?: SortOrder
    viewCount?: SortOrder
    AccountId?: SortOrder
  }

  export type ProductsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    filters?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isSubscribe?: SortOrder
  }

  export type ProductsAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    duration?: SortOrder
  }

  export type ProductsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isSubscribe?: SortOrder
  }

  export type ProductsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isSubscribe?: SortOrder
  }

  export type ProductsSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    duration?: SortOrder
  }

  export type TasksRelationFilter = {
    is?: TasksWhereInput | null
    isNot?: TasksWhereInput | null
  }

  export type ReportsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    isPrivate?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    TaskId?: SortOrder
    AccountId?: SortOrder
  }

  export type ReportsAvgOrderByAggregateInput = {
    id?: SortOrder
    TaskId?: SortOrder
    AccountId?: SortOrder
  }

  export type ReportsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    isPrivate?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    TaskId?: SortOrder
    AccountId?: SortOrder
  }

  export type ReportsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    isPrivate?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    TaskId?: SortOrder
    AccountId?: SortOrder
  }

  export type ReportsSumOrderByAggregateInput = {
    id?: SortOrder
    TaskId?: SortOrder
    AccountId?: SortOrder
  }

  export type SequelizeMetaCountOrderByAggregateInput = {
    name?: SortOrder
  }

  export type SequelizeMetaMaxOrderByAggregateInput = {
    name?: SortOrder
  }

  export type SequelizeMetaMinOrderByAggregateInput = {
    name?: SortOrder
  }

  export type AccountsListRelationFilter = {
    every?: AccountsWhereInput
    some?: AccountsWhereInput
    none?: AccountsWhereInput
  }

  export type AccountsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServicesCountOrderByAggregateInput = {
    key?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServicesMaxOrderByAggregateInput = {
    key?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServicesMinOrderByAggregateInput = {
    key?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamsRelationFilter = {
    is?: TeamsWhereInput | null
    isNot?: TeamsWhereInput | null
  }

  export type StatisticsCountOrderByAggregateInput = {
    id?: SortOrder
    AgentId?: SortOrder
    TeamId?: SortOrder
    TaskId?: SortOrder
    dailyWorkload?: SortOrder
    completedByOwner?: SortOrder
    completedBySelf?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatisticsAvgOrderByAggregateInput = {
    id?: SortOrder
    AgentId?: SortOrder
    TeamId?: SortOrder
    TaskId?: SortOrder
    dailyWorkload?: SortOrder
    completedByOwner?: SortOrder
    completedBySelf?: SortOrder
  }

  export type StatisticsMaxOrderByAggregateInput = {
    id?: SortOrder
    AgentId?: SortOrder
    TeamId?: SortOrder
    TaskId?: SortOrder
    dailyWorkload?: SortOrder
    completedByOwner?: SortOrder
    completedBySelf?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatisticsMinOrderByAggregateInput = {
    id?: SortOrder
    AgentId?: SortOrder
    TeamId?: SortOrder
    TaskId?: SortOrder
    dailyWorkload?: SortOrder
    completedByOwner?: SortOrder
    completedBySelf?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatisticsSumOrderByAggregateInput = {
    id?: SortOrder
    AgentId?: SortOrder
    TeamId?: SortOrder
    TaskId?: SortOrder
    dailyWorkload?: SortOrder
    completedByOwner?: SortOrder
    completedBySelf?: SortOrder
  }

  export type SubscribesCountOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    fcmToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscribesAvgOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
  }

  export type SubscribesMaxOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    fcmToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscribesMinOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    fcmToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscribesSumOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
  }

  export type TaskDetailsRelationFilter = {
    is?: TaskDetailsWhereInput | null
    isNot?: TaskDetailsWhereInput | null
  }

  export type TaskDetailResourcesCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    TaskDetailId?: SortOrder
    AccountId?: SortOrder
    group?: SortOrder
  }

  export type TaskDetailResourcesAvgOrderByAggregateInput = {
    id?: SortOrder
    TaskDetailId?: SortOrder
    AccountId?: SortOrder
  }

  export type TaskDetailResourcesMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    TaskDetailId?: SortOrder
    AccountId?: SortOrder
    group?: SortOrder
  }

  export type TaskDetailResourcesMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    TaskDetailId?: SortOrder
    AccountId?: SortOrder
    group?: SortOrder
  }

  export type TaskDetailResourcesSumOrderByAggregateInput = {
    id?: SortOrder
    TaskDetailId?: SortOrder
    AccountId?: SortOrder
  }

  export type TaskDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    TaskId?: SortOrder
    type?: SortOrder
    address?: SortOrder
    villageName?: SortOrder
    pushUser?: SortOrder
    category?: SortOrder
    etc?: SortOrder
    status?: SortOrder
    geometry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedDays?: SortOrder
    assignedUser?: SortOrder
    TeamId?: SortOrder
    y?: SortOrder
    x?: SortOrder
    area?: SortOrder
    pushPhone?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    memo?: SortOrder
    extra?: SortOrder
  }

  export type TaskDetailsAvgOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    TaskId?: SortOrder
    assignedDays?: SortOrder
    TeamId?: SortOrder
    area?: SortOrder
  }

  export type TaskDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    TaskId?: SortOrder
    type?: SortOrder
    address?: SortOrder
    villageName?: SortOrder
    pushUser?: SortOrder
    category?: SortOrder
    etc?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedDays?: SortOrder
    assignedUser?: SortOrder
    TeamId?: SortOrder
    y?: SortOrder
    x?: SortOrder
    area?: SortOrder
    pushPhone?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    memo?: SortOrder
  }

  export type TaskDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    TaskId?: SortOrder
    type?: SortOrder
    address?: SortOrder
    villageName?: SortOrder
    pushUser?: SortOrder
    category?: SortOrder
    etc?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedDays?: SortOrder
    assignedUser?: SortOrder
    TeamId?: SortOrder
    y?: SortOrder
    x?: SortOrder
    area?: SortOrder
    pushPhone?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    memo?: SortOrder
  }

  export type TaskDetailsSumOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    TaskId?: SortOrder
    assignedDays?: SortOrder
    TeamId?: SortOrder
    area?: SortOrder
  }

  export type TaskGroupsCountOrderByAggregateInput = {
    id?: SortOrder
    path?: SortOrder
    name?: SortOrder
    status?: SortOrder
    AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    area?: SortOrder
    createType?: SortOrder
    extra?: SortOrder
  }

  export type TaskGroupsAvgOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    area?: SortOrder
  }

  export type TaskGroupsMaxOrderByAggregateInput = {
    id?: SortOrder
    path?: SortOrder
    name?: SortOrder
    status?: SortOrder
    AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    area?: SortOrder
    createType?: SortOrder
  }

  export type TaskGroupsMinOrderByAggregateInput = {
    id?: SortOrder
    path?: SortOrder
    name?: SortOrder
    status?: SortOrder
    AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    area?: SortOrder
    createType?: SortOrder
  }

  export type TaskGroupsSumOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    area?: SortOrder
  }

  export type TaskGroupsRelationFilter = {
    is?: TaskGroupsWhereInput | null
    isNot?: TaskGroupsWhereInput | null
  }

  export type TasksCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workingDays?: SortOrder
    workingTeamsCnt?: SortOrder
    TaskGroupId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    area?: SortOrder
    isPaid?: SortOrder
    createType?: SortOrder
    extra?: SortOrder
    real_area?: SortOrder
  }

  export type TasksAvgOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    workingDays?: SortOrder
    workingTeamsCnt?: SortOrder
    TaskGroupId?: SortOrder
    area?: SortOrder
    real_area?: SortOrder
  }

  export type TasksMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workingDays?: SortOrder
    workingTeamsCnt?: SortOrder
    TaskGroupId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    area?: SortOrder
    isPaid?: SortOrder
    createType?: SortOrder
    real_area?: SortOrder
  }

  export type TasksMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workingDays?: SortOrder
    workingTeamsCnt?: SortOrder
    TaskGroupId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    area?: SortOrder
    isPaid?: SortOrder
    createType?: SortOrder
    real_area?: SortOrder
  }

  export type TasksSumOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    workingDays?: SortOrder
    workingTeamsCnt?: SortOrder
    TaskGroupId?: SortOrder
    area?: SortOrder
    real_area?: SortOrder
  }

  export type TeamAgentsAgentIdTeamIdCompoundUniqueInput = {
    AgentId: number
    TeamId: number
  }

  export type TeamAgentsCountOrderByAggregateInput = {
    AgentId?: SortOrder
    TeamId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamAgentsAvgOrderByAggregateInput = {
    AgentId?: SortOrder
    TeamId?: SortOrder
  }

  export type TeamAgentsMaxOrderByAggregateInput = {
    AgentId?: SortOrder
    TeamId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamAgentsMinOrderByAggregateInput = {
    AgentId?: SortOrder
    TeamId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamAgentsSumOrderByAggregateInput = {
    AgentId?: SortOrder
    TeamId?: SortOrder
  }

  export type TeamsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    AccountId?: SortOrder
    AgentId?: SortOrder
    TaskId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    area?: SortOrder
    alias?: SortOrder
  }

  export type TeamsAvgOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    AgentId?: SortOrder
    TaskId?: SortOrder
    area?: SortOrder
  }

  export type TeamsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    AccountId?: SortOrder
    AgentId?: SortOrder
    TaskId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    area?: SortOrder
    alias?: SortOrder
  }

  export type TeamsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    AccountId?: SortOrder
    AgentId?: SortOrder
    TaskId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    area?: SortOrder
    alias?: SortOrder
  }

  export type TeamsSumOrderByAggregateInput = {
    id?: SortOrder
    AccountId?: SortOrder
    AgentId?: SortOrder
    TaskId?: SortOrder
    area?: SortOrder
  }

  export type ServicesCreateNestedOneWithoutAccountsInput = {
    create?: XOR<ServicesCreateWithoutAccountsInput, ServicesUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: ServicesCreateOrConnectWithoutAccountsInput
    connect?: ServicesWhereUniqueInput
  }

  export type AlertsCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<AlertsCreateWithoutAccountsInput>, Enumerable<AlertsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<AlertsCreateOrConnectWithoutAccountsInput>
    createMany?: AlertsCreateManyAccountsInputEnvelope
    connect?: Enumerable<AlertsWhereUniqueInput>
  }

  export type CareersCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<CareersCreateWithoutAccountsInput>, Enumerable<CareersUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<CareersCreateOrConnectWithoutAccountsInput>
    createMany?: CareersCreateManyAccountsInputEnvelope
    connect?: Enumerable<CareersWhereUniqueInput>
  }

  export type CustomerTaskDetailsCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<CustomerTaskDetailsCreateWithoutAccountsInput>, Enumerable<CustomerTaskDetailsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<CustomerTaskDetailsCreateOrConnectWithoutAccountsInput>
    createMany?: CustomerTaskDetailsCreateManyAccountsInputEnvelope
    connect?: Enumerable<CustomerTaskDetailsWhereUniqueInput>
  }

  export type CustomersCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<CustomersCreateWithoutAccountsInput>, Enumerable<CustomersUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<CustomersCreateOrConnectWithoutAccountsInput>
    createMany?: CustomersCreateManyAccountsInputEnvelope
    connect?: Enumerable<CustomersWhereUniqueInput>
  }

  export type DiscountsCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<DiscountsCreateWithoutAccountsInput>, Enumerable<DiscountsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<DiscountsCreateOrConnectWithoutAccountsInput>
    createMany?: DiscountsCreateManyAccountsInputEnvelope
    connect?: Enumerable<DiscountsWhereUniqueInput>
  }

  export type LandsCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<LandsCreateWithoutAccountsInput>, Enumerable<LandsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<LandsCreateOrConnectWithoutAccountsInput>
    createMany?: LandsCreateManyAccountsInputEnvelope
    connect?: Enumerable<LandsWhereUniqueInput>
  }

  export type NotificationsCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<NotificationsCreateWithoutAccountsInput>, Enumerable<NotificationsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<NotificationsCreateOrConnectWithoutAccountsInput>
    createMany?: NotificationsCreateManyAccountsInputEnvelope
    connect?: Enumerable<NotificationsWhereUniqueInput>
  }

  export type OrderHistoriesCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<OrderHistoriesCreateWithoutAccountsInput>, Enumerable<OrderHistoriesUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<OrderHistoriesCreateOrConnectWithoutAccountsInput>
    createMany?: OrderHistoriesCreateManyAccountsInputEnvelope
    connect?: Enumerable<OrderHistoriesWhereUniqueInput>
  }

  export type OrdersCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<OrdersCreateWithoutAccountsInput>, Enumerable<OrdersUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<OrdersCreateOrConnectWithoutAccountsInput>
    createMany?: OrdersCreateManyAccountsInputEnvelope
    connect?: Enumerable<OrdersWhereUniqueInput>
  }

  export type PermissionsCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<PermissionsCreateWithoutAccountsInput>, Enumerable<PermissionsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<PermissionsCreateOrConnectWithoutAccountsInput>
    createMany?: PermissionsCreateManyAccountsInputEnvelope
    connect?: Enumerable<PermissionsWhereUniqueInput>
  }

  export type PostAccountsCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<PostAccountsCreateWithoutAccountsInput>, Enumerable<PostAccountsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<PostAccountsCreateOrConnectWithoutAccountsInput>
    createMany?: PostAccountsCreateManyAccountsInputEnvelope
    connect?: Enumerable<PostAccountsWhereUniqueInput>
  }

  export type PostsCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<PostsCreateWithoutAccountsInput>, Enumerable<PostsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<PostsCreateOrConnectWithoutAccountsInput>
    createMany?: PostsCreateManyAccountsInputEnvelope
    connect?: Enumerable<PostsWhereUniqueInput>
  }

  export type ReportsCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<ReportsCreateWithoutAccountsInput>, Enumerable<ReportsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<ReportsCreateOrConnectWithoutAccountsInput>
    createMany?: ReportsCreateManyAccountsInputEnvelope
    connect?: Enumerable<ReportsWhereUniqueInput>
  }

  export type StatisticsCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<StatisticsCreateWithoutAccountsInput>, Enumerable<StatisticsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<StatisticsCreateOrConnectWithoutAccountsInput>
    createMany?: StatisticsCreateManyAccountsInputEnvelope
    connect?: Enumerable<StatisticsWhereUniqueInput>
  }

  export type SubscribesCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<SubscribesCreateWithoutAccountsInput>, Enumerable<SubscribesUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<SubscribesCreateOrConnectWithoutAccountsInput>
    createMany?: SubscribesCreateManyAccountsInputEnvelope
    connect?: Enumerable<SubscribesWhereUniqueInput>
  }

  export type TaskDetailResourcesCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<TaskDetailResourcesCreateWithoutAccountsInput>, Enumerable<TaskDetailResourcesUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<TaskDetailResourcesCreateOrConnectWithoutAccountsInput>
    createMany?: TaskDetailResourcesCreateManyAccountsInputEnvelope
    connect?: Enumerable<TaskDetailResourcesWhereUniqueInput>
  }

  export type TaskDetailsCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<TaskDetailsCreateWithoutAccountsInput>, Enumerable<TaskDetailsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<TaskDetailsCreateOrConnectWithoutAccountsInput>
    createMany?: TaskDetailsCreateManyAccountsInputEnvelope
    connect?: Enumerable<TaskDetailsWhereUniqueInput>
  }

  export type TaskGroupsCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<TaskGroupsCreateWithoutAccountsInput>, Enumerable<TaskGroupsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<TaskGroupsCreateOrConnectWithoutAccountsInput>
    createMany?: TaskGroupsCreateManyAccountsInputEnvelope
    connect?: Enumerable<TaskGroupsWhereUniqueInput>
  }

  export type TasksCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<TasksCreateWithoutAccountsInput>, Enumerable<TasksUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<TasksCreateOrConnectWithoutAccountsInput>
    createMany?: TasksCreateManyAccountsInputEnvelope
    connect?: Enumerable<TasksWhereUniqueInput>
  }

  export type TeamAgentsCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<TeamAgentsCreateWithoutAccountsInput>, Enumerable<TeamAgentsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<TeamAgentsCreateOrConnectWithoutAccountsInput>
    createMany?: TeamAgentsCreateManyAccountsInputEnvelope
    connect?: Enumerable<TeamAgentsWhereUniqueInput>
  }

  export type TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput = {
    create?: XOR<Enumerable<TeamsCreateWithoutAccounts_AccountsToTeams_AccountIdInput>, Enumerable<TeamsUncheckedCreateWithoutAccounts_AccountsToTeams_AccountIdInput>>
    connectOrCreate?: Enumerable<TeamsCreateOrConnectWithoutAccounts_AccountsToTeams_AccountIdInput>
    createMany?: TeamsCreateManyAccounts_AccountsToTeams_AccountIdInputEnvelope
    connect?: Enumerable<TeamsWhereUniqueInput>
  }

  export type TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput = {
    create?: XOR<Enumerable<TeamsCreateWithoutAccounts_AccountsToTeams_AgentIdInput>, Enumerable<TeamsUncheckedCreateWithoutAccounts_AccountsToTeams_AgentIdInput>>
    connectOrCreate?: Enumerable<TeamsCreateOrConnectWithoutAccounts_AccountsToTeams_AgentIdInput>
    createMany?: TeamsCreateManyAccounts_AccountsToTeams_AgentIdInputEnvelope
    connect?: Enumerable<TeamsWhereUniqueInput>
  }

  export type AlertsUncheckedCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<AlertsCreateWithoutAccountsInput>, Enumerable<AlertsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<AlertsCreateOrConnectWithoutAccountsInput>
    createMany?: AlertsCreateManyAccountsInputEnvelope
    connect?: Enumerable<AlertsWhereUniqueInput>
  }

  export type CareersUncheckedCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<CareersCreateWithoutAccountsInput>, Enumerable<CareersUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<CareersCreateOrConnectWithoutAccountsInput>
    createMany?: CareersCreateManyAccountsInputEnvelope
    connect?: Enumerable<CareersWhereUniqueInput>
  }

  export type CustomerTaskDetailsUncheckedCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<CustomerTaskDetailsCreateWithoutAccountsInput>, Enumerable<CustomerTaskDetailsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<CustomerTaskDetailsCreateOrConnectWithoutAccountsInput>
    createMany?: CustomerTaskDetailsCreateManyAccountsInputEnvelope
    connect?: Enumerable<CustomerTaskDetailsWhereUniqueInput>
  }

  export type CustomersUncheckedCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<CustomersCreateWithoutAccountsInput>, Enumerable<CustomersUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<CustomersCreateOrConnectWithoutAccountsInput>
    createMany?: CustomersCreateManyAccountsInputEnvelope
    connect?: Enumerable<CustomersWhereUniqueInput>
  }

  export type DiscountsUncheckedCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<DiscountsCreateWithoutAccountsInput>, Enumerable<DiscountsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<DiscountsCreateOrConnectWithoutAccountsInput>
    createMany?: DiscountsCreateManyAccountsInputEnvelope
    connect?: Enumerable<DiscountsWhereUniqueInput>
  }

  export type LandsUncheckedCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<LandsCreateWithoutAccountsInput>, Enumerable<LandsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<LandsCreateOrConnectWithoutAccountsInput>
    createMany?: LandsCreateManyAccountsInputEnvelope
    connect?: Enumerable<LandsWhereUniqueInput>
  }

  export type NotificationsUncheckedCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<NotificationsCreateWithoutAccountsInput>, Enumerable<NotificationsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<NotificationsCreateOrConnectWithoutAccountsInput>
    createMany?: NotificationsCreateManyAccountsInputEnvelope
    connect?: Enumerable<NotificationsWhereUniqueInput>
  }

  export type OrderHistoriesUncheckedCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<OrderHistoriesCreateWithoutAccountsInput>, Enumerable<OrderHistoriesUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<OrderHistoriesCreateOrConnectWithoutAccountsInput>
    createMany?: OrderHistoriesCreateManyAccountsInputEnvelope
    connect?: Enumerable<OrderHistoriesWhereUniqueInput>
  }

  export type OrdersUncheckedCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<OrdersCreateWithoutAccountsInput>, Enumerable<OrdersUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<OrdersCreateOrConnectWithoutAccountsInput>
    createMany?: OrdersCreateManyAccountsInputEnvelope
    connect?: Enumerable<OrdersWhereUniqueInput>
  }

  export type PermissionsUncheckedCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<PermissionsCreateWithoutAccountsInput>, Enumerable<PermissionsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<PermissionsCreateOrConnectWithoutAccountsInput>
    createMany?: PermissionsCreateManyAccountsInputEnvelope
    connect?: Enumerable<PermissionsWhereUniqueInput>
  }

  export type PostAccountsUncheckedCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<PostAccountsCreateWithoutAccountsInput>, Enumerable<PostAccountsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<PostAccountsCreateOrConnectWithoutAccountsInput>
    createMany?: PostAccountsCreateManyAccountsInputEnvelope
    connect?: Enumerable<PostAccountsWhereUniqueInput>
  }

  export type PostsUncheckedCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<PostsCreateWithoutAccountsInput>, Enumerable<PostsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<PostsCreateOrConnectWithoutAccountsInput>
    createMany?: PostsCreateManyAccountsInputEnvelope
    connect?: Enumerable<PostsWhereUniqueInput>
  }

  export type ReportsUncheckedCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<ReportsCreateWithoutAccountsInput>, Enumerable<ReportsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<ReportsCreateOrConnectWithoutAccountsInput>
    createMany?: ReportsCreateManyAccountsInputEnvelope
    connect?: Enumerable<ReportsWhereUniqueInput>
  }

  export type StatisticsUncheckedCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<StatisticsCreateWithoutAccountsInput>, Enumerable<StatisticsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<StatisticsCreateOrConnectWithoutAccountsInput>
    createMany?: StatisticsCreateManyAccountsInputEnvelope
    connect?: Enumerable<StatisticsWhereUniqueInput>
  }

  export type SubscribesUncheckedCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<SubscribesCreateWithoutAccountsInput>, Enumerable<SubscribesUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<SubscribesCreateOrConnectWithoutAccountsInput>
    createMany?: SubscribesCreateManyAccountsInputEnvelope
    connect?: Enumerable<SubscribesWhereUniqueInput>
  }

  export type TaskDetailResourcesUncheckedCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<TaskDetailResourcesCreateWithoutAccountsInput>, Enumerable<TaskDetailResourcesUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<TaskDetailResourcesCreateOrConnectWithoutAccountsInput>
    createMany?: TaskDetailResourcesCreateManyAccountsInputEnvelope
    connect?: Enumerable<TaskDetailResourcesWhereUniqueInput>
  }

  export type TaskDetailsUncheckedCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<TaskDetailsCreateWithoutAccountsInput>, Enumerable<TaskDetailsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<TaskDetailsCreateOrConnectWithoutAccountsInput>
    createMany?: TaskDetailsCreateManyAccountsInputEnvelope
    connect?: Enumerable<TaskDetailsWhereUniqueInput>
  }

  export type TaskGroupsUncheckedCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<TaskGroupsCreateWithoutAccountsInput>, Enumerable<TaskGroupsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<TaskGroupsCreateOrConnectWithoutAccountsInput>
    createMany?: TaskGroupsCreateManyAccountsInputEnvelope
    connect?: Enumerable<TaskGroupsWhereUniqueInput>
  }

  export type TasksUncheckedCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<TasksCreateWithoutAccountsInput>, Enumerable<TasksUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<TasksCreateOrConnectWithoutAccountsInput>
    createMany?: TasksCreateManyAccountsInputEnvelope
    connect?: Enumerable<TasksWhereUniqueInput>
  }

  export type TeamAgentsUncheckedCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<TeamAgentsCreateWithoutAccountsInput>, Enumerable<TeamAgentsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<TeamAgentsCreateOrConnectWithoutAccountsInput>
    createMany?: TeamAgentsCreateManyAccountsInputEnvelope
    connect?: Enumerable<TeamAgentsWhereUniqueInput>
  }

  export type TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput = {
    create?: XOR<Enumerable<TeamsCreateWithoutAccounts_AccountsToTeams_AccountIdInput>, Enumerable<TeamsUncheckedCreateWithoutAccounts_AccountsToTeams_AccountIdInput>>
    connectOrCreate?: Enumerable<TeamsCreateOrConnectWithoutAccounts_AccountsToTeams_AccountIdInput>
    createMany?: TeamsCreateManyAccounts_AccountsToTeams_AccountIdInputEnvelope
    connect?: Enumerable<TeamsWhereUniqueInput>
  }

  export type TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput = {
    create?: XOR<Enumerable<TeamsCreateWithoutAccounts_AccountsToTeams_AgentIdInput>, Enumerable<TeamsUncheckedCreateWithoutAccounts_AccountsToTeams_AgentIdInput>>
    connectOrCreate?: Enumerable<TeamsCreateOrConnectWithoutAccounts_AccountsToTeams_AgentIdInput>
    createMany?: TeamsCreateManyAccounts_AccountsToTeams_AgentIdInputEnvelope
    connect?: Enumerable<TeamsWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type ServicesUpdateOneWithoutAccountsNestedInput = {
    create?: XOR<ServicesCreateWithoutAccountsInput, ServicesUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: ServicesCreateOrConnectWithoutAccountsInput
    upsert?: ServicesUpsertWithoutAccountsInput
    disconnect?: boolean
    delete?: boolean
    connect?: ServicesWhereUniqueInput
    update?: XOR<ServicesUpdateWithoutAccountsInput, ServicesUncheckedUpdateWithoutAccountsInput>
  }

  export type AlertsUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<AlertsCreateWithoutAccountsInput>, Enumerable<AlertsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<AlertsCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<AlertsUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: AlertsCreateManyAccountsInputEnvelope
    set?: Enumerable<AlertsWhereUniqueInput>
    disconnect?: Enumerable<AlertsWhereUniqueInput>
    delete?: Enumerable<AlertsWhereUniqueInput>
    connect?: Enumerable<AlertsWhereUniqueInput>
    update?: Enumerable<AlertsUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<AlertsUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<AlertsScalarWhereInput>
  }

  export type CareersUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<CareersCreateWithoutAccountsInput>, Enumerable<CareersUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<CareersCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<CareersUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: CareersCreateManyAccountsInputEnvelope
    set?: Enumerable<CareersWhereUniqueInput>
    disconnect?: Enumerable<CareersWhereUniqueInput>
    delete?: Enumerable<CareersWhereUniqueInput>
    connect?: Enumerable<CareersWhereUniqueInput>
    update?: Enumerable<CareersUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<CareersUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<CareersScalarWhereInput>
  }

  export type CustomerTaskDetailsUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<CustomerTaskDetailsCreateWithoutAccountsInput>, Enumerable<CustomerTaskDetailsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<CustomerTaskDetailsCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<CustomerTaskDetailsUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: CustomerTaskDetailsCreateManyAccountsInputEnvelope
    set?: Enumerable<CustomerTaskDetailsWhereUniqueInput>
    disconnect?: Enumerable<CustomerTaskDetailsWhereUniqueInput>
    delete?: Enumerable<CustomerTaskDetailsWhereUniqueInput>
    connect?: Enumerable<CustomerTaskDetailsWhereUniqueInput>
    update?: Enumerable<CustomerTaskDetailsUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<CustomerTaskDetailsUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<CustomerTaskDetailsScalarWhereInput>
  }

  export type CustomersUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<CustomersCreateWithoutAccountsInput>, Enumerable<CustomersUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<CustomersCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<CustomersUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: CustomersCreateManyAccountsInputEnvelope
    set?: Enumerable<CustomersWhereUniqueInput>
    disconnect?: Enumerable<CustomersWhereUniqueInput>
    delete?: Enumerable<CustomersWhereUniqueInput>
    connect?: Enumerable<CustomersWhereUniqueInput>
    update?: Enumerable<CustomersUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<CustomersUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<CustomersScalarWhereInput>
  }

  export type DiscountsUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<DiscountsCreateWithoutAccountsInput>, Enumerable<DiscountsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<DiscountsCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<DiscountsUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: DiscountsCreateManyAccountsInputEnvelope
    set?: Enumerable<DiscountsWhereUniqueInput>
    disconnect?: Enumerable<DiscountsWhereUniqueInput>
    delete?: Enumerable<DiscountsWhereUniqueInput>
    connect?: Enumerable<DiscountsWhereUniqueInput>
    update?: Enumerable<DiscountsUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<DiscountsUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<DiscountsScalarWhereInput>
  }

  export type LandsUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<LandsCreateWithoutAccountsInput>, Enumerable<LandsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<LandsCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<LandsUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: LandsCreateManyAccountsInputEnvelope
    set?: Enumerable<LandsWhereUniqueInput>
    disconnect?: Enumerable<LandsWhereUniqueInput>
    delete?: Enumerable<LandsWhereUniqueInput>
    connect?: Enumerable<LandsWhereUniqueInput>
    update?: Enumerable<LandsUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<LandsUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<LandsScalarWhereInput>
  }

  export type NotificationsUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<NotificationsCreateWithoutAccountsInput>, Enumerable<NotificationsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<NotificationsCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<NotificationsUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: NotificationsCreateManyAccountsInputEnvelope
    set?: Enumerable<NotificationsWhereUniqueInput>
    disconnect?: Enumerable<NotificationsWhereUniqueInput>
    delete?: Enumerable<NotificationsWhereUniqueInput>
    connect?: Enumerable<NotificationsWhereUniqueInput>
    update?: Enumerable<NotificationsUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<NotificationsUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<NotificationsScalarWhereInput>
  }

  export type OrderHistoriesUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<OrderHistoriesCreateWithoutAccountsInput>, Enumerable<OrderHistoriesUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<OrderHistoriesCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<OrderHistoriesUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: OrderHistoriesCreateManyAccountsInputEnvelope
    set?: Enumerable<OrderHistoriesWhereUniqueInput>
    disconnect?: Enumerable<OrderHistoriesWhereUniqueInput>
    delete?: Enumerable<OrderHistoriesWhereUniqueInput>
    connect?: Enumerable<OrderHistoriesWhereUniqueInput>
    update?: Enumerable<OrderHistoriesUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<OrderHistoriesUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<OrderHistoriesScalarWhereInput>
  }

  export type OrdersUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<OrdersCreateWithoutAccountsInput>, Enumerable<OrdersUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<OrdersCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<OrdersUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: OrdersCreateManyAccountsInputEnvelope
    set?: Enumerable<OrdersWhereUniqueInput>
    disconnect?: Enumerable<OrdersWhereUniqueInput>
    delete?: Enumerable<OrdersWhereUniqueInput>
    connect?: Enumerable<OrdersWhereUniqueInput>
    update?: Enumerable<OrdersUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<OrdersUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<OrdersScalarWhereInput>
  }

  export type PermissionsUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<PermissionsCreateWithoutAccountsInput>, Enumerable<PermissionsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<PermissionsCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<PermissionsUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: PermissionsCreateManyAccountsInputEnvelope
    set?: Enumerable<PermissionsWhereUniqueInput>
    disconnect?: Enumerable<PermissionsWhereUniqueInput>
    delete?: Enumerable<PermissionsWhereUniqueInput>
    connect?: Enumerable<PermissionsWhereUniqueInput>
    update?: Enumerable<PermissionsUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<PermissionsUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<PermissionsScalarWhereInput>
  }

  export type PostAccountsUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<PostAccountsCreateWithoutAccountsInput>, Enumerable<PostAccountsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<PostAccountsCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<PostAccountsUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: PostAccountsCreateManyAccountsInputEnvelope
    set?: Enumerable<PostAccountsWhereUniqueInput>
    disconnect?: Enumerable<PostAccountsWhereUniqueInput>
    delete?: Enumerable<PostAccountsWhereUniqueInput>
    connect?: Enumerable<PostAccountsWhereUniqueInput>
    update?: Enumerable<PostAccountsUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<PostAccountsUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<PostAccountsScalarWhereInput>
  }

  export type PostsUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<PostsCreateWithoutAccountsInput>, Enumerable<PostsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<PostsCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<PostsUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: PostsCreateManyAccountsInputEnvelope
    set?: Enumerable<PostsWhereUniqueInput>
    disconnect?: Enumerable<PostsWhereUniqueInput>
    delete?: Enumerable<PostsWhereUniqueInput>
    connect?: Enumerable<PostsWhereUniqueInput>
    update?: Enumerable<PostsUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<PostsUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<PostsScalarWhereInput>
  }

  export type ReportsUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<ReportsCreateWithoutAccountsInput>, Enumerable<ReportsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<ReportsCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<ReportsUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: ReportsCreateManyAccountsInputEnvelope
    set?: Enumerable<ReportsWhereUniqueInput>
    disconnect?: Enumerable<ReportsWhereUniqueInput>
    delete?: Enumerable<ReportsWhereUniqueInput>
    connect?: Enumerable<ReportsWhereUniqueInput>
    update?: Enumerable<ReportsUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<ReportsUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<ReportsScalarWhereInput>
  }

  export type StatisticsUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<StatisticsCreateWithoutAccountsInput>, Enumerable<StatisticsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<StatisticsCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<StatisticsUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: StatisticsCreateManyAccountsInputEnvelope
    set?: Enumerable<StatisticsWhereUniqueInput>
    disconnect?: Enumerable<StatisticsWhereUniqueInput>
    delete?: Enumerable<StatisticsWhereUniqueInput>
    connect?: Enumerable<StatisticsWhereUniqueInput>
    update?: Enumerable<StatisticsUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<StatisticsUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<StatisticsScalarWhereInput>
  }

  export type SubscribesUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<SubscribesCreateWithoutAccountsInput>, Enumerable<SubscribesUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<SubscribesCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<SubscribesUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: SubscribesCreateManyAccountsInputEnvelope
    set?: Enumerable<SubscribesWhereUniqueInput>
    disconnect?: Enumerable<SubscribesWhereUniqueInput>
    delete?: Enumerable<SubscribesWhereUniqueInput>
    connect?: Enumerable<SubscribesWhereUniqueInput>
    update?: Enumerable<SubscribesUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<SubscribesUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<SubscribesScalarWhereInput>
  }

  export type TaskDetailResourcesUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<TaskDetailResourcesCreateWithoutAccountsInput>, Enumerable<TaskDetailResourcesUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<TaskDetailResourcesCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<TaskDetailResourcesUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: TaskDetailResourcesCreateManyAccountsInputEnvelope
    set?: Enumerable<TaskDetailResourcesWhereUniqueInput>
    disconnect?: Enumerable<TaskDetailResourcesWhereUniqueInput>
    delete?: Enumerable<TaskDetailResourcesWhereUniqueInput>
    connect?: Enumerable<TaskDetailResourcesWhereUniqueInput>
    update?: Enumerable<TaskDetailResourcesUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<TaskDetailResourcesUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<TaskDetailResourcesScalarWhereInput>
  }

  export type TaskDetailsUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<TaskDetailsCreateWithoutAccountsInput>, Enumerable<TaskDetailsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<TaskDetailsCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<TaskDetailsUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: TaskDetailsCreateManyAccountsInputEnvelope
    set?: Enumerable<TaskDetailsWhereUniqueInput>
    disconnect?: Enumerable<TaskDetailsWhereUniqueInput>
    delete?: Enumerable<TaskDetailsWhereUniqueInput>
    connect?: Enumerable<TaskDetailsWhereUniqueInput>
    update?: Enumerable<TaskDetailsUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<TaskDetailsUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<TaskDetailsScalarWhereInput>
  }

  export type TaskGroupsUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<TaskGroupsCreateWithoutAccountsInput>, Enumerable<TaskGroupsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<TaskGroupsCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<TaskGroupsUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: TaskGroupsCreateManyAccountsInputEnvelope
    set?: Enumerable<TaskGroupsWhereUniqueInput>
    disconnect?: Enumerable<TaskGroupsWhereUniqueInput>
    delete?: Enumerable<TaskGroupsWhereUniqueInput>
    connect?: Enumerable<TaskGroupsWhereUniqueInput>
    update?: Enumerable<TaskGroupsUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<TaskGroupsUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<TaskGroupsScalarWhereInput>
  }

  export type TasksUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<TasksCreateWithoutAccountsInput>, Enumerable<TasksUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<TasksCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<TasksUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: TasksCreateManyAccountsInputEnvelope
    set?: Enumerable<TasksWhereUniqueInput>
    disconnect?: Enumerable<TasksWhereUniqueInput>
    delete?: Enumerable<TasksWhereUniqueInput>
    connect?: Enumerable<TasksWhereUniqueInput>
    update?: Enumerable<TasksUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<TasksUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<TasksScalarWhereInput>
  }

  export type TeamAgentsUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<TeamAgentsCreateWithoutAccountsInput>, Enumerable<TeamAgentsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<TeamAgentsCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<TeamAgentsUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: TeamAgentsCreateManyAccountsInputEnvelope
    set?: Enumerable<TeamAgentsWhereUniqueInput>
    disconnect?: Enumerable<TeamAgentsWhereUniqueInput>
    delete?: Enumerable<TeamAgentsWhereUniqueInput>
    connect?: Enumerable<TeamAgentsWhereUniqueInput>
    update?: Enumerable<TeamAgentsUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<TeamAgentsUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<TeamAgentsScalarWhereInput>
  }

  export type TeamsUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput = {
    create?: XOR<Enumerable<TeamsCreateWithoutAccounts_AccountsToTeams_AccountIdInput>, Enumerable<TeamsUncheckedCreateWithoutAccounts_AccountsToTeams_AccountIdInput>>
    connectOrCreate?: Enumerable<TeamsCreateOrConnectWithoutAccounts_AccountsToTeams_AccountIdInput>
    upsert?: Enumerable<TeamsUpsertWithWhereUniqueWithoutAccounts_AccountsToTeams_AccountIdInput>
    createMany?: TeamsCreateManyAccounts_AccountsToTeams_AccountIdInputEnvelope
    set?: Enumerable<TeamsWhereUniqueInput>
    disconnect?: Enumerable<TeamsWhereUniqueInput>
    delete?: Enumerable<TeamsWhereUniqueInput>
    connect?: Enumerable<TeamsWhereUniqueInput>
    update?: Enumerable<TeamsUpdateWithWhereUniqueWithoutAccounts_AccountsToTeams_AccountIdInput>
    updateMany?: Enumerable<TeamsUpdateManyWithWhereWithoutAccounts_AccountsToTeams_AccountIdInput>
    deleteMany?: Enumerable<TeamsScalarWhereInput>
  }

  export type TeamsUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput = {
    create?: XOR<Enumerable<TeamsCreateWithoutAccounts_AccountsToTeams_AgentIdInput>, Enumerable<TeamsUncheckedCreateWithoutAccounts_AccountsToTeams_AgentIdInput>>
    connectOrCreate?: Enumerable<TeamsCreateOrConnectWithoutAccounts_AccountsToTeams_AgentIdInput>
    upsert?: Enumerable<TeamsUpsertWithWhereUniqueWithoutAccounts_AccountsToTeams_AgentIdInput>
    createMany?: TeamsCreateManyAccounts_AccountsToTeams_AgentIdInputEnvelope
    set?: Enumerable<TeamsWhereUniqueInput>
    disconnect?: Enumerable<TeamsWhereUniqueInput>
    delete?: Enumerable<TeamsWhereUniqueInput>
    connect?: Enumerable<TeamsWhereUniqueInput>
    update?: Enumerable<TeamsUpdateWithWhereUniqueWithoutAccounts_AccountsToTeams_AgentIdInput>
    updateMany?: Enumerable<TeamsUpdateManyWithWhereWithoutAccounts_AccountsToTeams_AgentIdInput>
    deleteMany?: Enumerable<TeamsScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AlertsUncheckedUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<AlertsCreateWithoutAccountsInput>, Enumerable<AlertsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<AlertsCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<AlertsUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: AlertsCreateManyAccountsInputEnvelope
    set?: Enumerable<AlertsWhereUniqueInput>
    disconnect?: Enumerable<AlertsWhereUniqueInput>
    delete?: Enumerable<AlertsWhereUniqueInput>
    connect?: Enumerable<AlertsWhereUniqueInput>
    update?: Enumerable<AlertsUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<AlertsUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<AlertsScalarWhereInput>
  }

  export type CareersUncheckedUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<CareersCreateWithoutAccountsInput>, Enumerable<CareersUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<CareersCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<CareersUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: CareersCreateManyAccountsInputEnvelope
    set?: Enumerable<CareersWhereUniqueInput>
    disconnect?: Enumerable<CareersWhereUniqueInput>
    delete?: Enumerable<CareersWhereUniqueInput>
    connect?: Enumerable<CareersWhereUniqueInput>
    update?: Enumerable<CareersUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<CareersUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<CareersScalarWhereInput>
  }

  export type CustomerTaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<CustomerTaskDetailsCreateWithoutAccountsInput>, Enumerable<CustomerTaskDetailsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<CustomerTaskDetailsCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<CustomerTaskDetailsUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: CustomerTaskDetailsCreateManyAccountsInputEnvelope
    set?: Enumerable<CustomerTaskDetailsWhereUniqueInput>
    disconnect?: Enumerable<CustomerTaskDetailsWhereUniqueInput>
    delete?: Enumerable<CustomerTaskDetailsWhereUniqueInput>
    connect?: Enumerable<CustomerTaskDetailsWhereUniqueInput>
    update?: Enumerable<CustomerTaskDetailsUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<CustomerTaskDetailsUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<CustomerTaskDetailsScalarWhereInput>
  }

  export type CustomersUncheckedUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<CustomersCreateWithoutAccountsInput>, Enumerable<CustomersUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<CustomersCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<CustomersUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: CustomersCreateManyAccountsInputEnvelope
    set?: Enumerable<CustomersWhereUniqueInput>
    disconnect?: Enumerable<CustomersWhereUniqueInput>
    delete?: Enumerable<CustomersWhereUniqueInput>
    connect?: Enumerable<CustomersWhereUniqueInput>
    update?: Enumerable<CustomersUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<CustomersUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<CustomersScalarWhereInput>
  }

  export type DiscountsUncheckedUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<DiscountsCreateWithoutAccountsInput>, Enumerable<DiscountsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<DiscountsCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<DiscountsUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: DiscountsCreateManyAccountsInputEnvelope
    set?: Enumerable<DiscountsWhereUniqueInput>
    disconnect?: Enumerable<DiscountsWhereUniqueInput>
    delete?: Enumerable<DiscountsWhereUniqueInput>
    connect?: Enumerable<DiscountsWhereUniqueInput>
    update?: Enumerable<DiscountsUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<DiscountsUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<DiscountsScalarWhereInput>
  }

  export type LandsUncheckedUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<LandsCreateWithoutAccountsInput>, Enumerable<LandsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<LandsCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<LandsUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: LandsCreateManyAccountsInputEnvelope
    set?: Enumerable<LandsWhereUniqueInput>
    disconnect?: Enumerable<LandsWhereUniqueInput>
    delete?: Enumerable<LandsWhereUniqueInput>
    connect?: Enumerable<LandsWhereUniqueInput>
    update?: Enumerable<LandsUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<LandsUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<LandsScalarWhereInput>
  }

  export type NotificationsUncheckedUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<NotificationsCreateWithoutAccountsInput>, Enumerable<NotificationsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<NotificationsCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<NotificationsUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: NotificationsCreateManyAccountsInputEnvelope
    set?: Enumerable<NotificationsWhereUniqueInput>
    disconnect?: Enumerable<NotificationsWhereUniqueInput>
    delete?: Enumerable<NotificationsWhereUniqueInput>
    connect?: Enumerable<NotificationsWhereUniqueInput>
    update?: Enumerable<NotificationsUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<NotificationsUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<NotificationsScalarWhereInput>
  }

  export type OrderHistoriesUncheckedUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<OrderHistoriesCreateWithoutAccountsInput>, Enumerable<OrderHistoriesUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<OrderHistoriesCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<OrderHistoriesUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: OrderHistoriesCreateManyAccountsInputEnvelope
    set?: Enumerable<OrderHistoriesWhereUniqueInput>
    disconnect?: Enumerable<OrderHistoriesWhereUniqueInput>
    delete?: Enumerable<OrderHistoriesWhereUniqueInput>
    connect?: Enumerable<OrderHistoriesWhereUniqueInput>
    update?: Enumerable<OrderHistoriesUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<OrderHistoriesUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<OrderHistoriesScalarWhereInput>
  }

  export type OrdersUncheckedUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<OrdersCreateWithoutAccountsInput>, Enumerable<OrdersUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<OrdersCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<OrdersUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: OrdersCreateManyAccountsInputEnvelope
    set?: Enumerable<OrdersWhereUniqueInput>
    disconnect?: Enumerable<OrdersWhereUniqueInput>
    delete?: Enumerable<OrdersWhereUniqueInput>
    connect?: Enumerable<OrdersWhereUniqueInput>
    update?: Enumerable<OrdersUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<OrdersUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<OrdersScalarWhereInput>
  }

  export type PermissionsUncheckedUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<PermissionsCreateWithoutAccountsInput>, Enumerable<PermissionsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<PermissionsCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<PermissionsUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: PermissionsCreateManyAccountsInputEnvelope
    set?: Enumerable<PermissionsWhereUniqueInput>
    disconnect?: Enumerable<PermissionsWhereUniqueInput>
    delete?: Enumerable<PermissionsWhereUniqueInput>
    connect?: Enumerable<PermissionsWhereUniqueInput>
    update?: Enumerable<PermissionsUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<PermissionsUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<PermissionsScalarWhereInput>
  }

  export type PostAccountsUncheckedUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<PostAccountsCreateWithoutAccountsInput>, Enumerable<PostAccountsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<PostAccountsCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<PostAccountsUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: PostAccountsCreateManyAccountsInputEnvelope
    set?: Enumerable<PostAccountsWhereUniqueInput>
    disconnect?: Enumerable<PostAccountsWhereUniqueInput>
    delete?: Enumerable<PostAccountsWhereUniqueInput>
    connect?: Enumerable<PostAccountsWhereUniqueInput>
    update?: Enumerable<PostAccountsUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<PostAccountsUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<PostAccountsScalarWhereInput>
  }

  export type PostsUncheckedUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<PostsCreateWithoutAccountsInput>, Enumerable<PostsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<PostsCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<PostsUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: PostsCreateManyAccountsInputEnvelope
    set?: Enumerable<PostsWhereUniqueInput>
    disconnect?: Enumerable<PostsWhereUniqueInput>
    delete?: Enumerable<PostsWhereUniqueInput>
    connect?: Enumerable<PostsWhereUniqueInput>
    update?: Enumerable<PostsUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<PostsUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<PostsScalarWhereInput>
  }

  export type ReportsUncheckedUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<ReportsCreateWithoutAccountsInput>, Enumerable<ReportsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<ReportsCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<ReportsUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: ReportsCreateManyAccountsInputEnvelope
    set?: Enumerable<ReportsWhereUniqueInput>
    disconnect?: Enumerable<ReportsWhereUniqueInput>
    delete?: Enumerable<ReportsWhereUniqueInput>
    connect?: Enumerable<ReportsWhereUniqueInput>
    update?: Enumerable<ReportsUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<ReportsUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<ReportsScalarWhereInput>
  }

  export type StatisticsUncheckedUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<StatisticsCreateWithoutAccountsInput>, Enumerable<StatisticsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<StatisticsCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<StatisticsUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: StatisticsCreateManyAccountsInputEnvelope
    set?: Enumerable<StatisticsWhereUniqueInput>
    disconnect?: Enumerable<StatisticsWhereUniqueInput>
    delete?: Enumerable<StatisticsWhereUniqueInput>
    connect?: Enumerable<StatisticsWhereUniqueInput>
    update?: Enumerable<StatisticsUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<StatisticsUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<StatisticsScalarWhereInput>
  }

  export type SubscribesUncheckedUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<SubscribesCreateWithoutAccountsInput>, Enumerable<SubscribesUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<SubscribesCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<SubscribesUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: SubscribesCreateManyAccountsInputEnvelope
    set?: Enumerable<SubscribesWhereUniqueInput>
    disconnect?: Enumerable<SubscribesWhereUniqueInput>
    delete?: Enumerable<SubscribesWhereUniqueInput>
    connect?: Enumerable<SubscribesWhereUniqueInput>
    update?: Enumerable<SubscribesUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<SubscribesUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<SubscribesScalarWhereInput>
  }

  export type TaskDetailResourcesUncheckedUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<TaskDetailResourcesCreateWithoutAccountsInput>, Enumerable<TaskDetailResourcesUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<TaskDetailResourcesCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<TaskDetailResourcesUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: TaskDetailResourcesCreateManyAccountsInputEnvelope
    set?: Enumerable<TaskDetailResourcesWhereUniqueInput>
    disconnect?: Enumerable<TaskDetailResourcesWhereUniqueInput>
    delete?: Enumerable<TaskDetailResourcesWhereUniqueInput>
    connect?: Enumerable<TaskDetailResourcesWhereUniqueInput>
    update?: Enumerable<TaskDetailResourcesUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<TaskDetailResourcesUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<TaskDetailResourcesScalarWhereInput>
  }

  export type TaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<TaskDetailsCreateWithoutAccountsInput>, Enumerable<TaskDetailsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<TaskDetailsCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<TaskDetailsUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: TaskDetailsCreateManyAccountsInputEnvelope
    set?: Enumerable<TaskDetailsWhereUniqueInput>
    disconnect?: Enumerable<TaskDetailsWhereUniqueInput>
    delete?: Enumerable<TaskDetailsWhereUniqueInput>
    connect?: Enumerable<TaskDetailsWhereUniqueInput>
    update?: Enumerable<TaskDetailsUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<TaskDetailsUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<TaskDetailsScalarWhereInput>
  }

  export type TaskGroupsUncheckedUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<TaskGroupsCreateWithoutAccountsInput>, Enumerable<TaskGroupsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<TaskGroupsCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<TaskGroupsUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: TaskGroupsCreateManyAccountsInputEnvelope
    set?: Enumerable<TaskGroupsWhereUniqueInput>
    disconnect?: Enumerable<TaskGroupsWhereUniqueInput>
    delete?: Enumerable<TaskGroupsWhereUniqueInput>
    connect?: Enumerable<TaskGroupsWhereUniqueInput>
    update?: Enumerable<TaskGroupsUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<TaskGroupsUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<TaskGroupsScalarWhereInput>
  }

  export type TasksUncheckedUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<TasksCreateWithoutAccountsInput>, Enumerable<TasksUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<TasksCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<TasksUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: TasksCreateManyAccountsInputEnvelope
    set?: Enumerable<TasksWhereUniqueInput>
    disconnect?: Enumerable<TasksWhereUniqueInput>
    delete?: Enumerable<TasksWhereUniqueInput>
    connect?: Enumerable<TasksWhereUniqueInput>
    update?: Enumerable<TasksUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<TasksUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<TasksScalarWhereInput>
  }

  export type TeamAgentsUncheckedUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<TeamAgentsCreateWithoutAccountsInput>, Enumerable<TeamAgentsUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<TeamAgentsCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<TeamAgentsUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: TeamAgentsCreateManyAccountsInputEnvelope
    set?: Enumerable<TeamAgentsWhereUniqueInput>
    disconnect?: Enumerable<TeamAgentsWhereUniqueInput>
    delete?: Enumerable<TeamAgentsWhereUniqueInput>
    connect?: Enumerable<TeamAgentsWhereUniqueInput>
    update?: Enumerable<TeamAgentsUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<TeamAgentsUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<TeamAgentsScalarWhereInput>
  }

  export type TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput = {
    create?: XOR<Enumerable<TeamsCreateWithoutAccounts_AccountsToTeams_AccountIdInput>, Enumerable<TeamsUncheckedCreateWithoutAccounts_AccountsToTeams_AccountIdInput>>
    connectOrCreate?: Enumerable<TeamsCreateOrConnectWithoutAccounts_AccountsToTeams_AccountIdInput>
    upsert?: Enumerable<TeamsUpsertWithWhereUniqueWithoutAccounts_AccountsToTeams_AccountIdInput>
    createMany?: TeamsCreateManyAccounts_AccountsToTeams_AccountIdInputEnvelope
    set?: Enumerable<TeamsWhereUniqueInput>
    disconnect?: Enumerable<TeamsWhereUniqueInput>
    delete?: Enumerable<TeamsWhereUniqueInput>
    connect?: Enumerable<TeamsWhereUniqueInput>
    update?: Enumerable<TeamsUpdateWithWhereUniqueWithoutAccounts_AccountsToTeams_AccountIdInput>
    updateMany?: Enumerable<TeamsUpdateManyWithWhereWithoutAccounts_AccountsToTeams_AccountIdInput>
    deleteMany?: Enumerable<TeamsScalarWhereInput>
  }

  export type TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput = {
    create?: XOR<Enumerable<TeamsCreateWithoutAccounts_AccountsToTeams_AgentIdInput>, Enumerable<TeamsUncheckedCreateWithoutAccounts_AccountsToTeams_AgentIdInput>>
    connectOrCreate?: Enumerable<TeamsCreateOrConnectWithoutAccounts_AccountsToTeams_AgentIdInput>
    upsert?: Enumerable<TeamsUpsertWithWhereUniqueWithoutAccounts_AccountsToTeams_AgentIdInput>
    createMany?: TeamsCreateManyAccounts_AccountsToTeams_AgentIdInputEnvelope
    set?: Enumerable<TeamsWhereUniqueInput>
    disconnect?: Enumerable<TeamsWhereUniqueInput>
    delete?: Enumerable<TeamsWhereUniqueInput>
    connect?: Enumerable<TeamsWhereUniqueInput>
    update?: Enumerable<TeamsUpdateWithWhereUniqueWithoutAccounts_AccountsToTeams_AgentIdInput>
    updateMany?: Enumerable<TeamsUpdateManyWithWhereWithoutAccounts_AccountsToTeams_AgentIdInput>
    deleteMany?: Enumerable<TeamsScalarWhereInput>
  }

  export type AccountsCreateNestedOneWithoutAlertsInput = {
    create?: XOR<AccountsCreateWithoutAlertsInput, AccountsUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutAlertsInput
    connect?: AccountsWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type AccountsUpdateOneWithoutAlertsNestedInput = {
    create?: XOR<AccountsCreateWithoutAlertsInput, AccountsUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutAlertsInput
    upsert?: AccountsUpsertWithoutAlertsInput
    disconnect?: boolean
    delete?: boolean
    connect?: AccountsWhereUniqueInput
    update?: XOR<AccountsUpdateWithoutAlertsInput, AccountsUncheckedUpdateWithoutAlertsInput>
  }

  export type AccountsCreateNestedOneWithoutCareersInput = {
    create?: XOR<AccountsCreateWithoutCareersInput, AccountsUncheckedCreateWithoutCareersInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutCareersInput
    connect?: AccountsWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AccountsUpdateOneWithoutCareersNestedInput = {
    create?: XOR<AccountsCreateWithoutCareersInput, AccountsUncheckedCreateWithoutCareersInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutCareersInput
    upsert?: AccountsUpsertWithoutCareersInput
    disconnect?: boolean
    delete?: boolean
    connect?: AccountsWhereUniqueInput
    update?: XOR<AccountsUpdateWithoutCareersInput, AccountsUncheckedUpdateWithoutCareersInput>
  }

  export type DiscountsCreateNestedManyWithoutCouponsInput = {
    create?: XOR<Enumerable<DiscountsCreateWithoutCouponsInput>, Enumerable<DiscountsUncheckedCreateWithoutCouponsInput>>
    connectOrCreate?: Enumerable<DiscountsCreateOrConnectWithoutCouponsInput>
    createMany?: DiscountsCreateManyCouponsInputEnvelope
    connect?: Enumerable<DiscountsWhereUniqueInput>
  }

  export type DiscountsUncheckedCreateNestedManyWithoutCouponsInput = {
    create?: XOR<Enumerable<DiscountsCreateWithoutCouponsInput>, Enumerable<DiscountsUncheckedCreateWithoutCouponsInput>>
    connectOrCreate?: Enumerable<DiscountsCreateOrConnectWithoutCouponsInput>
    createMany?: DiscountsCreateManyCouponsInputEnvelope
    connect?: Enumerable<DiscountsWhereUniqueInput>
  }

  export type DiscountsUpdateManyWithoutCouponsNestedInput = {
    create?: XOR<Enumerable<DiscountsCreateWithoutCouponsInput>, Enumerable<DiscountsUncheckedCreateWithoutCouponsInput>>
    connectOrCreate?: Enumerable<DiscountsCreateOrConnectWithoutCouponsInput>
    upsert?: Enumerable<DiscountsUpsertWithWhereUniqueWithoutCouponsInput>
    createMany?: DiscountsCreateManyCouponsInputEnvelope
    set?: Enumerable<DiscountsWhereUniqueInput>
    disconnect?: Enumerable<DiscountsWhereUniqueInput>
    delete?: Enumerable<DiscountsWhereUniqueInput>
    connect?: Enumerable<DiscountsWhereUniqueInput>
    update?: Enumerable<DiscountsUpdateWithWhereUniqueWithoutCouponsInput>
    updateMany?: Enumerable<DiscountsUpdateManyWithWhereWithoutCouponsInput>
    deleteMany?: Enumerable<DiscountsScalarWhereInput>
  }

  export type DiscountsUncheckedUpdateManyWithoutCouponsNestedInput = {
    create?: XOR<Enumerable<DiscountsCreateWithoutCouponsInput>, Enumerable<DiscountsUncheckedCreateWithoutCouponsInput>>
    connectOrCreate?: Enumerable<DiscountsCreateOrConnectWithoutCouponsInput>
    upsert?: Enumerable<DiscountsUpsertWithWhereUniqueWithoutCouponsInput>
    createMany?: DiscountsCreateManyCouponsInputEnvelope
    set?: Enumerable<DiscountsWhereUniqueInput>
    disconnect?: Enumerable<DiscountsWhereUniqueInput>
    delete?: Enumerable<DiscountsWhereUniqueInput>
    connect?: Enumerable<DiscountsWhereUniqueInput>
    update?: Enumerable<DiscountsUpdateWithWhereUniqueWithoutCouponsInput>
    updateMany?: Enumerable<DiscountsUpdateManyWithWhereWithoutCouponsInput>
    deleteMany?: Enumerable<DiscountsScalarWhereInput>
  }

  export type AccountsCreateNestedOneWithoutCustomerTaskDetailsInput = {
    create?: XOR<AccountsCreateWithoutCustomerTaskDetailsInput, AccountsUncheckedCreateWithoutCustomerTaskDetailsInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutCustomerTaskDetailsInput
    connect?: AccountsWhereUniqueInput
  }

  export type CustomersCreateNestedOneWithoutCustomerTaskDetailsInput = {
    create?: XOR<CustomersCreateWithoutCustomerTaskDetailsInput, CustomersUncheckedCreateWithoutCustomerTaskDetailsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutCustomerTaskDetailsInput
    connect?: CustomersWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type AccountsUpdateOneWithoutCustomerTaskDetailsNestedInput = {
    create?: XOR<AccountsCreateWithoutCustomerTaskDetailsInput, AccountsUncheckedCreateWithoutCustomerTaskDetailsInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutCustomerTaskDetailsInput
    upsert?: AccountsUpsertWithoutCustomerTaskDetailsInput
    disconnect?: boolean
    delete?: boolean
    connect?: AccountsWhereUniqueInput
    update?: XOR<AccountsUpdateWithoutCustomerTaskDetailsInput, AccountsUncheckedUpdateWithoutCustomerTaskDetailsInput>
  }

  export type CustomersUpdateOneWithoutCustomerTaskDetailsNestedInput = {
    create?: XOR<CustomersCreateWithoutCustomerTaskDetailsInput, CustomersUncheckedCreateWithoutCustomerTaskDetailsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutCustomerTaskDetailsInput
    upsert?: CustomersUpsertWithoutCustomerTaskDetailsInput
    disconnect?: boolean
    delete?: boolean
    connect?: CustomersWhereUniqueInput
    update?: XOR<CustomersUpdateWithoutCustomerTaskDetailsInput, CustomersUncheckedUpdateWithoutCustomerTaskDetailsInput>
  }

  export type CustomersCreatecropsInput = {
    set: Enumerable<string>
  }

  export type AccountsCreateNestedOneWithoutCustomersInput = {
    create?: XOR<AccountsCreateWithoutCustomersInput, AccountsUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutCustomersInput
    connect?: AccountsWhereUniqueInput
  }

  export type CustomerTaskDetailsCreateNestedManyWithoutCustomersInput = {
    create?: XOR<Enumerable<CustomerTaskDetailsCreateWithoutCustomersInput>, Enumerable<CustomerTaskDetailsUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<CustomerTaskDetailsCreateOrConnectWithoutCustomersInput>
    createMany?: CustomerTaskDetailsCreateManyCustomersInputEnvelope
    connect?: Enumerable<CustomerTaskDetailsWhereUniqueInput>
  }

  export type CustomerTaskDetailsUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<Enumerable<CustomerTaskDetailsCreateWithoutCustomersInput>, Enumerable<CustomerTaskDetailsUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<CustomerTaskDetailsCreateOrConnectWithoutCustomersInput>
    createMany?: CustomerTaskDetailsCreateManyCustomersInputEnvelope
    connect?: Enumerable<CustomerTaskDetailsWhereUniqueInput>
  }

  export type CustomersUpdatecropsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type AccountsUpdateOneWithoutCustomersNestedInput = {
    create?: XOR<AccountsCreateWithoutCustomersInput, AccountsUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutCustomersInput
    upsert?: AccountsUpsertWithoutCustomersInput
    disconnect?: boolean
    delete?: boolean
    connect?: AccountsWhereUniqueInput
    update?: XOR<AccountsUpdateWithoutCustomersInput, AccountsUncheckedUpdateWithoutCustomersInput>
  }

  export type CustomerTaskDetailsUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<Enumerable<CustomerTaskDetailsCreateWithoutCustomersInput>, Enumerable<CustomerTaskDetailsUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<CustomerTaskDetailsCreateOrConnectWithoutCustomersInput>
    upsert?: Enumerable<CustomerTaskDetailsUpsertWithWhereUniqueWithoutCustomersInput>
    createMany?: CustomerTaskDetailsCreateManyCustomersInputEnvelope
    set?: Enumerable<CustomerTaskDetailsWhereUniqueInput>
    disconnect?: Enumerable<CustomerTaskDetailsWhereUniqueInput>
    delete?: Enumerable<CustomerTaskDetailsWhereUniqueInput>
    connect?: Enumerable<CustomerTaskDetailsWhereUniqueInput>
    update?: Enumerable<CustomerTaskDetailsUpdateWithWhereUniqueWithoutCustomersInput>
    updateMany?: Enumerable<CustomerTaskDetailsUpdateManyWithWhereWithoutCustomersInput>
    deleteMany?: Enumerable<CustomerTaskDetailsScalarWhereInput>
  }

  export type CustomerTaskDetailsUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<Enumerable<CustomerTaskDetailsCreateWithoutCustomersInput>, Enumerable<CustomerTaskDetailsUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<CustomerTaskDetailsCreateOrConnectWithoutCustomersInput>
    upsert?: Enumerable<CustomerTaskDetailsUpsertWithWhereUniqueWithoutCustomersInput>
    createMany?: CustomerTaskDetailsCreateManyCustomersInputEnvelope
    set?: Enumerable<CustomerTaskDetailsWhereUniqueInput>
    disconnect?: Enumerable<CustomerTaskDetailsWhereUniqueInput>
    delete?: Enumerable<CustomerTaskDetailsWhereUniqueInput>
    connect?: Enumerable<CustomerTaskDetailsWhereUniqueInput>
    update?: Enumerable<CustomerTaskDetailsUpdateWithWhereUniqueWithoutCustomersInput>
    updateMany?: Enumerable<CustomerTaskDetailsUpdateManyWithWhereWithoutCustomersInput>
    deleteMany?: Enumerable<CustomerTaskDetailsScalarWhereInput>
  }

  export type AccountsCreateNestedOneWithoutDiscountsInput = {
    create?: XOR<AccountsCreateWithoutDiscountsInput, AccountsUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutDiscountsInput
    connect?: AccountsWhereUniqueInput
  }

  export type CouponsCreateNestedOneWithoutDiscountsInput = {
    create?: XOR<CouponsCreateWithoutDiscountsInput, CouponsUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: CouponsCreateOrConnectWithoutDiscountsInput
    connect?: CouponsWhereUniqueInput
  }

  export type OrdersCreateNestedOneWithoutDiscountsInput = {
    create?: XOR<OrdersCreateWithoutDiscountsInput, OrdersUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutDiscountsInput
    connect?: OrdersWhereUniqueInput
  }

  export type ProductsCreateNestedOneWithoutDiscountsInput = {
    create?: XOR<ProductsCreateWithoutDiscountsInput, ProductsUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutDiscountsInput
    connect?: ProductsWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AccountsUpdateOneWithoutDiscountsNestedInput = {
    create?: XOR<AccountsCreateWithoutDiscountsInput, AccountsUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutDiscountsInput
    upsert?: AccountsUpsertWithoutDiscountsInput
    disconnect?: boolean
    delete?: boolean
    connect?: AccountsWhereUniqueInput
    update?: XOR<AccountsUpdateWithoutDiscountsInput, AccountsUncheckedUpdateWithoutDiscountsInput>
  }

  export type CouponsUpdateOneWithoutDiscountsNestedInput = {
    create?: XOR<CouponsCreateWithoutDiscountsInput, CouponsUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: CouponsCreateOrConnectWithoutDiscountsInput
    upsert?: CouponsUpsertWithoutDiscountsInput
    disconnect?: boolean
    delete?: boolean
    connect?: CouponsWhereUniqueInput
    update?: XOR<CouponsUpdateWithoutDiscountsInput, CouponsUncheckedUpdateWithoutDiscountsInput>
  }

  export type OrdersUpdateOneWithoutDiscountsNestedInput = {
    create?: XOR<OrdersCreateWithoutDiscountsInput, OrdersUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutDiscountsInput
    upsert?: OrdersUpsertWithoutDiscountsInput
    disconnect?: boolean
    delete?: boolean
    connect?: OrdersWhereUniqueInput
    update?: XOR<OrdersUpdateWithoutDiscountsInput, OrdersUncheckedUpdateWithoutDiscountsInput>
  }

  export type ProductsUpdateOneWithoutDiscountsNestedInput = {
    create?: XOR<ProductsCreateWithoutDiscountsInput, ProductsUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutDiscountsInput
    upsert?: ProductsUpsertWithoutDiscountsInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProductsWhereUniqueInput
    update?: XOR<ProductsUpdateWithoutDiscountsInput, ProductsUncheckedUpdateWithoutDiscountsInput>
  }

  export type AccountsCreateNestedOneWithoutLandsInput = {
    create?: XOR<AccountsCreateWithoutLandsInput, AccountsUncheckedCreateWithoutLandsInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutLandsInput
    connect?: AccountsWhereUniqueInput
  }

  export type AccountsUpdateOneRequiredWithoutLandsNestedInput = {
    create?: XOR<AccountsCreateWithoutLandsInput, AccountsUncheckedCreateWithoutLandsInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutLandsInput
    upsert?: AccountsUpsertWithoutLandsInput
    connect?: AccountsWhereUniqueInput
    update?: XOR<AccountsUpdateWithoutLandsInput, AccountsUncheckedUpdateWithoutLandsInput>
  }

  export type AccountsCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<AccountsCreateWithoutNotificationsInput, AccountsUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutNotificationsInput
    connect?: AccountsWhereUniqueInput
  }

  export type AccountsUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<AccountsCreateWithoutNotificationsInput, AccountsUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutNotificationsInput
    upsert?: AccountsUpsertWithoutNotificationsInput
    connect?: AccountsWhereUniqueInput
    update?: XOR<AccountsUpdateWithoutNotificationsInput, AccountsUncheckedUpdateWithoutNotificationsInput>
  }

  export type AccountsCreateNestedOneWithoutOrderHistoriesInput = {
    create?: XOR<AccountsCreateWithoutOrderHistoriesInput, AccountsUncheckedCreateWithoutOrderHistoriesInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutOrderHistoriesInput
    connect?: AccountsWhereUniqueInput
  }

  export type OrdersCreateNestedOneWithoutOrderHistoriesInput = {
    create?: XOR<OrdersCreateWithoutOrderHistoriesInput, OrdersUncheckedCreateWithoutOrderHistoriesInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutOrderHistoriesInput
    connect?: OrdersWhereUniqueInput
  }

  export type ProductsCreateNestedOneWithoutOrderHistoriesInput = {
    create?: XOR<ProductsCreateWithoutOrderHistoriesInput, ProductsUncheckedCreateWithoutOrderHistoriesInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutOrderHistoriesInput
    connect?: ProductsWhereUniqueInput
  }

  export type AccountsUpdateOneWithoutOrderHistoriesNestedInput = {
    create?: XOR<AccountsCreateWithoutOrderHistoriesInput, AccountsUncheckedCreateWithoutOrderHistoriesInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutOrderHistoriesInput
    upsert?: AccountsUpsertWithoutOrderHistoriesInput
    disconnect?: boolean
    delete?: boolean
    connect?: AccountsWhereUniqueInput
    update?: XOR<AccountsUpdateWithoutOrderHistoriesInput, AccountsUncheckedUpdateWithoutOrderHistoriesInput>
  }

  export type OrdersUpdateOneWithoutOrderHistoriesNestedInput = {
    create?: XOR<OrdersCreateWithoutOrderHistoriesInput, OrdersUncheckedCreateWithoutOrderHistoriesInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutOrderHistoriesInput
    upsert?: OrdersUpsertWithoutOrderHistoriesInput
    disconnect?: boolean
    delete?: boolean
    connect?: OrdersWhereUniqueInput
    update?: XOR<OrdersUpdateWithoutOrderHistoriesInput, OrdersUncheckedUpdateWithoutOrderHistoriesInput>
  }

  export type ProductsUpdateOneWithoutOrderHistoriesNestedInput = {
    create?: XOR<ProductsCreateWithoutOrderHistoriesInput, ProductsUncheckedCreateWithoutOrderHistoriesInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutOrderHistoriesInput
    upsert?: ProductsUpsertWithoutOrderHistoriesInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProductsWhereUniqueInput
    update?: XOR<ProductsUpdateWithoutOrderHistoriesInput, ProductsUncheckedUpdateWithoutOrderHistoriesInput>
  }

  export type AccountsCreateNestedOneWithoutOrdersInput = {
    create?: XOR<AccountsCreateWithoutOrdersInput, AccountsUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutOrdersInput
    connect?: AccountsWhereUniqueInput
  }

  export type ProductsCreateNestedOneWithoutOrdersInput = {
    create?: XOR<ProductsCreateWithoutOrdersInput, ProductsUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutOrdersInput
    connect?: ProductsWhereUniqueInput
  }

  export type DiscountsCreateNestedManyWithoutOrdersInput = {
    create?: XOR<Enumerable<DiscountsCreateWithoutOrdersInput>, Enumerable<DiscountsUncheckedCreateWithoutOrdersInput>>
    connectOrCreate?: Enumerable<DiscountsCreateOrConnectWithoutOrdersInput>
    createMany?: DiscountsCreateManyOrdersInputEnvelope
    connect?: Enumerable<DiscountsWhereUniqueInput>
  }

  export type OrderHistoriesCreateNestedManyWithoutOrdersInput = {
    create?: XOR<Enumerable<OrderHistoriesCreateWithoutOrdersInput>, Enumerable<OrderHistoriesUncheckedCreateWithoutOrdersInput>>
    connectOrCreate?: Enumerable<OrderHistoriesCreateOrConnectWithoutOrdersInput>
    createMany?: OrderHistoriesCreateManyOrdersInputEnvelope
    connect?: Enumerable<OrderHistoriesWhereUniqueInput>
  }

  export type DiscountsUncheckedCreateNestedManyWithoutOrdersInput = {
    create?: XOR<Enumerable<DiscountsCreateWithoutOrdersInput>, Enumerable<DiscountsUncheckedCreateWithoutOrdersInput>>
    connectOrCreate?: Enumerable<DiscountsCreateOrConnectWithoutOrdersInput>
    createMany?: DiscountsCreateManyOrdersInputEnvelope
    connect?: Enumerable<DiscountsWhereUniqueInput>
  }

  export type OrderHistoriesUncheckedCreateNestedManyWithoutOrdersInput = {
    create?: XOR<Enumerable<OrderHistoriesCreateWithoutOrdersInput>, Enumerable<OrderHistoriesUncheckedCreateWithoutOrdersInput>>
    connectOrCreate?: Enumerable<OrderHistoriesCreateOrConnectWithoutOrdersInput>
    createMany?: OrderHistoriesCreateManyOrdersInputEnvelope
    connect?: Enumerable<OrderHistoriesWhereUniqueInput>
  }

  export type AccountsUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<AccountsCreateWithoutOrdersInput, AccountsUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutOrdersInput
    upsert?: AccountsUpsertWithoutOrdersInput
    disconnect?: boolean
    delete?: boolean
    connect?: AccountsWhereUniqueInput
    update?: XOR<AccountsUpdateWithoutOrdersInput, AccountsUncheckedUpdateWithoutOrdersInput>
  }

  export type ProductsUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<ProductsCreateWithoutOrdersInput, ProductsUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutOrdersInput
    upsert?: ProductsUpsertWithoutOrdersInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProductsWhereUniqueInput
    update?: XOR<ProductsUpdateWithoutOrdersInput, ProductsUncheckedUpdateWithoutOrdersInput>
  }

  export type DiscountsUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<Enumerable<DiscountsCreateWithoutOrdersInput>, Enumerable<DiscountsUncheckedCreateWithoutOrdersInput>>
    connectOrCreate?: Enumerable<DiscountsCreateOrConnectWithoutOrdersInput>
    upsert?: Enumerable<DiscountsUpsertWithWhereUniqueWithoutOrdersInput>
    createMany?: DiscountsCreateManyOrdersInputEnvelope
    set?: Enumerable<DiscountsWhereUniqueInput>
    disconnect?: Enumerable<DiscountsWhereUniqueInput>
    delete?: Enumerable<DiscountsWhereUniqueInput>
    connect?: Enumerable<DiscountsWhereUniqueInput>
    update?: Enumerable<DiscountsUpdateWithWhereUniqueWithoutOrdersInput>
    updateMany?: Enumerable<DiscountsUpdateManyWithWhereWithoutOrdersInput>
    deleteMany?: Enumerable<DiscountsScalarWhereInput>
  }

  export type OrderHistoriesUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<Enumerable<OrderHistoriesCreateWithoutOrdersInput>, Enumerable<OrderHistoriesUncheckedCreateWithoutOrdersInput>>
    connectOrCreate?: Enumerable<OrderHistoriesCreateOrConnectWithoutOrdersInput>
    upsert?: Enumerable<OrderHistoriesUpsertWithWhereUniqueWithoutOrdersInput>
    createMany?: OrderHistoriesCreateManyOrdersInputEnvelope
    set?: Enumerable<OrderHistoriesWhereUniqueInput>
    disconnect?: Enumerable<OrderHistoriesWhereUniqueInput>
    delete?: Enumerable<OrderHistoriesWhereUniqueInput>
    connect?: Enumerable<OrderHistoriesWhereUniqueInput>
    update?: Enumerable<OrderHistoriesUpdateWithWhereUniqueWithoutOrdersInput>
    updateMany?: Enumerable<OrderHistoriesUpdateManyWithWhereWithoutOrdersInput>
    deleteMany?: Enumerable<OrderHistoriesScalarWhereInput>
  }

  export type DiscountsUncheckedUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<Enumerable<DiscountsCreateWithoutOrdersInput>, Enumerable<DiscountsUncheckedCreateWithoutOrdersInput>>
    connectOrCreate?: Enumerable<DiscountsCreateOrConnectWithoutOrdersInput>
    upsert?: Enumerable<DiscountsUpsertWithWhereUniqueWithoutOrdersInput>
    createMany?: DiscountsCreateManyOrdersInputEnvelope
    set?: Enumerable<DiscountsWhereUniqueInput>
    disconnect?: Enumerable<DiscountsWhereUniqueInput>
    delete?: Enumerable<DiscountsWhereUniqueInput>
    connect?: Enumerable<DiscountsWhereUniqueInput>
    update?: Enumerable<DiscountsUpdateWithWhereUniqueWithoutOrdersInput>
    updateMany?: Enumerable<DiscountsUpdateManyWithWhereWithoutOrdersInput>
    deleteMany?: Enumerable<DiscountsScalarWhereInput>
  }

  export type OrderHistoriesUncheckedUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<Enumerable<OrderHistoriesCreateWithoutOrdersInput>, Enumerable<OrderHistoriesUncheckedCreateWithoutOrdersInput>>
    connectOrCreate?: Enumerable<OrderHistoriesCreateOrConnectWithoutOrdersInput>
    upsert?: Enumerable<OrderHistoriesUpsertWithWhereUniqueWithoutOrdersInput>
    createMany?: OrderHistoriesCreateManyOrdersInputEnvelope
    set?: Enumerable<OrderHistoriesWhereUniqueInput>
    disconnect?: Enumerable<OrderHistoriesWhereUniqueInput>
    delete?: Enumerable<OrderHistoriesWhereUniqueInput>
    connect?: Enumerable<OrderHistoriesWhereUniqueInput>
    update?: Enumerable<OrderHistoriesUpdateWithWhereUniqueWithoutOrdersInput>
    updateMany?: Enumerable<OrderHistoriesUpdateManyWithWhereWithoutOrdersInput>
    deleteMany?: Enumerable<OrderHistoriesScalarWhereInput>
  }

  export type AccountsCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<AccountsCreateWithoutPermissionsInput, AccountsUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutPermissionsInput
    connect?: AccountsWhereUniqueInput
  }

  export type Enumenum_Permissions_keyFieldUpdateOperationsInput = {
    set?: enum_Permissions_key
  }

  export type AccountsUpdateOneWithoutPermissionsNestedInput = {
    create?: XOR<AccountsCreateWithoutPermissionsInput, AccountsUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutPermissionsInput
    upsert?: AccountsUpsertWithoutPermissionsInput
    disconnect?: boolean
    delete?: boolean
    connect?: AccountsWhereUniqueInput
    update?: XOR<AccountsUpdateWithoutPermissionsInput, AccountsUncheckedUpdateWithoutPermissionsInput>
  }

  export type AccountsCreateNestedOneWithoutPostAccountsInput = {
    create?: XOR<AccountsCreateWithoutPostAccountsInput, AccountsUncheckedCreateWithoutPostAccountsInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutPostAccountsInput
    connect?: AccountsWhereUniqueInput
  }

  export type PostsCreateNestedOneWithoutPostAccountsInput = {
    create?: XOR<PostsCreateWithoutPostAccountsInput, PostsUncheckedCreateWithoutPostAccountsInput>
    connectOrCreate?: PostsCreateOrConnectWithoutPostAccountsInput
    connect?: PostsWhereUniqueInput
  }

  export type AccountsUpdateOneWithoutPostAccountsNestedInput = {
    create?: XOR<AccountsCreateWithoutPostAccountsInput, AccountsUncheckedCreateWithoutPostAccountsInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutPostAccountsInput
    upsert?: AccountsUpsertWithoutPostAccountsInput
    disconnect?: boolean
    delete?: boolean
    connect?: AccountsWhereUniqueInput
    update?: XOR<AccountsUpdateWithoutPostAccountsInput, AccountsUncheckedUpdateWithoutPostAccountsInput>
  }

  export type PostsUpdateOneWithoutPostAccountsNestedInput = {
    create?: XOR<PostsCreateWithoutPostAccountsInput, PostsUncheckedCreateWithoutPostAccountsInput>
    connectOrCreate?: PostsCreateOrConnectWithoutPostAccountsInput
    upsert?: PostsUpsertWithoutPostAccountsInput
    disconnect?: boolean
    delete?: boolean
    connect?: PostsWhereUniqueInput
    update?: XOR<PostsUpdateWithoutPostAccountsInput, PostsUncheckedUpdateWithoutPostAccountsInput>
  }

  export type PostsCreatetypeInput = {
    set: Enumerable<string>
  }

  export type PostsCreatelocationInput = {
    set: Enumerable<string>
  }

  export type PostsCreatequalificationsInput = {
    set: Enumerable<string>
  }

  export type AccountsCreateNestedOneWithoutPostsInput = {
    create?: XOR<AccountsCreateWithoutPostsInput, AccountsUncheckedCreateWithoutPostsInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutPostsInput
    connect?: AccountsWhereUniqueInput
  }

  export type PostAccountsCreateNestedManyWithoutPostsInput = {
    create?: XOR<Enumerable<PostAccountsCreateWithoutPostsInput>, Enumerable<PostAccountsUncheckedCreateWithoutPostsInput>>
    connectOrCreate?: Enumerable<PostAccountsCreateOrConnectWithoutPostsInput>
    createMany?: PostAccountsCreateManyPostsInputEnvelope
    connect?: Enumerable<PostAccountsWhereUniqueInput>
  }

  export type PostAccountsUncheckedCreateNestedManyWithoutPostsInput = {
    create?: XOR<Enumerable<PostAccountsCreateWithoutPostsInput>, Enumerable<PostAccountsUncheckedCreateWithoutPostsInput>>
    connectOrCreate?: Enumerable<PostAccountsCreateOrConnectWithoutPostsInput>
    createMany?: PostAccountsCreateManyPostsInputEnvelope
    connect?: Enumerable<PostAccountsWhereUniqueInput>
  }

  export type PostsUpdatetypeInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type PostsUpdatelocationInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type PostsUpdatequalificationsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type AccountsUpdateOneWithoutPostsNestedInput = {
    create?: XOR<AccountsCreateWithoutPostsInput, AccountsUncheckedCreateWithoutPostsInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutPostsInput
    upsert?: AccountsUpsertWithoutPostsInput
    disconnect?: boolean
    delete?: boolean
    connect?: AccountsWhereUniqueInput
    update?: XOR<AccountsUpdateWithoutPostsInput, AccountsUncheckedUpdateWithoutPostsInput>
  }

  export type PostAccountsUpdateManyWithoutPostsNestedInput = {
    create?: XOR<Enumerable<PostAccountsCreateWithoutPostsInput>, Enumerable<PostAccountsUncheckedCreateWithoutPostsInput>>
    connectOrCreate?: Enumerable<PostAccountsCreateOrConnectWithoutPostsInput>
    upsert?: Enumerable<PostAccountsUpsertWithWhereUniqueWithoutPostsInput>
    createMany?: PostAccountsCreateManyPostsInputEnvelope
    set?: Enumerable<PostAccountsWhereUniqueInput>
    disconnect?: Enumerable<PostAccountsWhereUniqueInput>
    delete?: Enumerable<PostAccountsWhereUniqueInput>
    connect?: Enumerable<PostAccountsWhereUniqueInput>
    update?: Enumerable<PostAccountsUpdateWithWhereUniqueWithoutPostsInput>
    updateMany?: Enumerable<PostAccountsUpdateManyWithWhereWithoutPostsInput>
    deleteMany?: Enumerable<PostAccountsScalarWhereInput>
  }

  export type PostAccountsUncheckedUpdateManyWithoutPostsNestedInput = {
    create?: XOR<Enumerable<PostAccountsCreateWithoutPostsInput>, Enumerable<PostAccountsUncheckedCreateWithoutPostsInput>>
    connectOrCreate?: Enumerable<PostAccountsCreateOrConnectWithoutPostsInput>
    upsert?: Enumerable<PostAccountsUpsertWithWhereUniqueWithoutPostsInput>
    createMany?: PostAccountsCreateManyPostsInputEnvelope
    set?: Enumerable<PostAccountsWhereUniqueInput>
    disconnect?: Enumerable<PostAccountsWhereUniqueInput>
    delete?: Enumerable<PostAccountsWhereUniqueInput>
    connect?: Enumerable<PostAccountsWhereUniqueInput>
    update?: Enumerable<PostAccountsUpdateWithWhereUniqueWithoutPostsInput>
    updateMany?: Enumerable<PostAccountsUpdateManyWithWhereWithoutPostsInput>
    deleteMany?: Enumerable<PostAccountsScalarWhereInput>
  }

  export type DiscountsCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<DiscountsCreateWithoutProductsInput>, Enumerable<DiscountsUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<DiscountsCreateOrConnectWithoutProductsInput>
    createMany?: DiscountsCreateManyProductsInputEnvelope
    connect?: Enumerable<DiscountsWhereUniqueInput>
  }

  export type OrderHistoriesCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<OrderHistoriesCreateWithoutProductsInput>, Enumerable<OrderHistoriesUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<OrderHistoriesCreateOrConnectWithoutProductsInput>
    createMany?: OrderHistoriesCreateManyProductsInputEnvelope
    connect?: Enumerable<OrderHistoriesWhereUniqueInput>
  }

  export type OrdersCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<OrdersCreateWithoutProductsInput>, Enumerable<OrdersUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<OrdersCreateOrConnectWithoutProductsInput>
    createMany?: OrdersCreateManyProductsInputEnvelope
    connect?: Enumerable<OrdersWhereUniqueInput>
  }

  export type DiscountsUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<DiscountsCreateWithoutProductsInput>, Enumerable<DiscountsUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<DiscountsCreateOrConnectWithoutProductsInput>
    createMany?: DiscountsCreateManyProductsInputEnvelope
    connect?: Enumerable<DiscountsWhereUniqueInput>
  }

  export type OrderHistoriesUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<OrderHistoriesCreateWithoutProductsInput>, Enumerable<OrderHistoriesUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<OrderHistoriesCreateOrConnectWithoutProductsInput>
    createMany?: OrderHistoriesCreateManyProductsInputEnvelope
    connect?: Enumerable<OrderHistoriesWhereUniqueInput>
  }

  export type OrdersUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<OrdersCreateWithoutProductsInput>, Enumerable<OrdersUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<OrdersCreateOrConnectWithoutProductsInput>
    createMany?: OrdersCreateManyProductsInputEnvelope
    connect?: Enumerable<OrdersWhereUniqueInput>
  }

  export type DiscountsUpdateManyWithoutProductsNestedInput = {
    create?: XOR<Enumerable<DiscountsCreateWithoutProductsInput>, Enumerable<DiscountsUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<DiscountsCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<DiscountsUpsertWithWhereUniqueWithoutProductsInput>
    createMany?: DiscountsCreateManyProductsInputEnvelope
    set?: Enumerable<DiscountsWhereUniqueInput>
    disconnect?: Enumerable<DiscountsWhereUniqueInput>
    delete?: Enumerable<DiscountsWhereUniqueInput>
    connect?: Enumerable<DiscountsWhereUniqueInput>
    update?: Enumerable<DiscountsUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<DiscountsUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<DiscountsScalarWhereInput>
  }

  export type OrderHistoriesUpdateManyWithoutProductsNestedInput = {
    create?: XOR<Enumerable<OrderHistoriesCreateWithoutProductsInput>, Enumerable<OrderHistoriesUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<OrderHistoriesCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<OrderHistoriesUpsertWithWhereUniqueWithoutProductsInput>
    createMany?: OrderHistoriesCreateManyProductsInputEnvelope
    set?: Enumerable<OrderHistoriesWhereUniqueInput>
    disconnect?: Enumerable<OrderHistoriesWhereUniqueInput>
    delete?: Enumerable<OrderHistoriesWhereUniqueInput>
    connect?: Enumerable<OrderHistoriesWhereUniqueInput>
    update?: Enumerable<OrderHistoriesUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<OrderHistoriesUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<OrderHistoriesScalarWhereInput>
  }

  export type OrdersUpdateManyWithoutProductsNestedInput = {
    create?: XOR<Enumerable<OrdersCreateWithoutProductsInput>, Enumerable<OrdersUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<OrdersCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<OrdersUpsertWithWhereUniqueWithoutProductsInput>
    createMany?: OrdersCreateManyProductsInputEnvelope
    set?: Enumerable<OrdersWhereUniqueInput>
    disconnect?: Enumerable<OrdersWhereUniqueInput>
    delete?: Enumerable<OrdersWhereUniqueInput>
    connect?: Enumerable<OrdersWhereUniqueInput>
    update?: Enumerable<OrdersUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<OrdersUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<OrdersScalarWhereInput>
  }

  export type DiscountsUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<Enumerable<DiscountsCreateWithoutProductsInput>, Enumerable<DiscountsUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<DiscountsCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<DiscountsUpsertWithWhereUniqueWithoutProductsInput>
    createMany?: DiscountsCreateManyProductsInputEnvelope
    set?: Enumerable<DiscountsWhereUniqueInput>
    disconnect?: Enumerable<DiscountsWhereUniqueInput>
    delete?: Enumerable<DiscountsWhereUniqueInput>
    connect?: Enumerable<DiscountsWhereUniqueInput>
    update?: Enumerable<DiscountsUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<DiscountsUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<DiscountsScalarWhereInput>
  }

  export type OrderHistoriesUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<Enumerable<OrderHistoriesCreateWithoutProductsInput>, Enumerable<OrderHistoriesUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<OrderHistoriesCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<OrderHistoriesUpsertWithWhereUniqueWithoutProductsInput>
    createMany?: OrderHistoriesCreateManyProductsInputEnvelope
    set?: Enumerable<OrderHistoriesWhereUniqueInput>
    disconnect?: Enumerable<OrderHistoriesWhereUniqueInput>
    delete?: Enumerable<OrderHistoriesWhereUniqueInput>
    connect?: Enumerable<OrderHistoriesWhereUniqueInput>
    update?: Enumerable<OrderHistoriesUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<OrderHistoriesUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<OrderHistoriesScalarWhereInput>
  }

  export type OrdersUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<Enumerable<OrdersCreateWithoutProductsInput>, Enumerable<OrdersUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<OrdersCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<OrdersUpsertWithWhereUniqueWithoutProductsInput>
    createMany?: OrdersCreateManyProductsInputEnvelope
    set?: Enumerable<OrdersWhereUniqueInput>
    disconnect?: Enumerable<OrdersWhereUniqueInput>
    delete?: Enumerable<OrdersWhereUniqueInput>
    connect?: Enumerable<OrdersWhereUniqueInput>
    update?: Enumerable<OrdersUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<OrdersUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<OrdersScalarWhereInput>
  }

  export type AccountsCreateNestedOneWithoutReportsInput = {
    create?: XOR<AccountsCreateWithoutReportsInput, AccountsUncheckedCreateWithoutReportsInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutReportsInput
    connect?: AccountsWhereUniqueInput
  }

  export type TasksCreateNestedOneWithoutReportsInput = {
    create?: XOR<TasksCreateWithoutReportsInput, TasksUncheckedCreateWithoutReportsInput>
    connectOrCreate?: TasksCreateOrConnectWithoutReportsInput
    connect?: TasksWhereUniqueInput
  }

  export type AccountsUpdateOneWithoutReportsNestedInput = {
    create?: XOR<AccountsCreateWithoutReportsInput, AccountsUncheckedCreateWithoutReportsInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutReportsInput
    upsert?: AccountsUpsertWithoutReportsInput
    disconnect?: boolean
    delete?: boolean
    connect?: AccountsWhereUniqueInput
    update?: XOR<AccountsUpdateWithoutReportsInput, AccountsUncheckedUpdateWithoutReportsInput>
  }

  export type TasksUpdateOneWithoutReportsNestedInput = {
    create?: XOR<TasksCreateWithoutReportsInput, TasksUncheckedCreateWithoutReportsInput>
    connectOrCreate?: TasksCreateOrConnectWithoutReportsInput
    upsert?: TasksUpsertWithoutReportsInput
    disconnect?: boolean
    delete?: boolean
    connect?: TasksWhereUniqueInput
    update?: XOR<TasksUpdateWithoutReportsInput, TasksUncheckedUpdateWithoutReportsInput>
  }

  export type AccountsCreateNestedManyWithoutServicesInput = {
    create?: XOR<Enumerable<AccountsCreateWithoutServicesInput>, Enumerable<AccountsUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<AccountsCreateOrConnectWithoutServicesInput>
    createMany?: AccountsCreateManyServicesInputEnvelope
    connect?: Enumerable<AccountsWhereUniqueInput>
  }

  export type AccountsUncheckedCreateNestedManyWithoutServicesInput = {
    create?: XOR<Enumerable<AccountsCreateWithoutServicesInput>, Enumerable<AccountsUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<AccountsCreateOrConnectWithoutServicesInput>
    createMany?: AccountsCreateManyServicesInputEnvelope
    connect?: Enumerable<AccountsWhereUniqueInput>
  }

  export type AccountsUpdateManyWithoutServicesNestedInput = {
    create?: XOR<Enumerable<AccountsCreateWithoutServicesInput>, Enumerable<AccountsUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<AccountsCreateOrConnectWithoutServicesInput>
    upsert?: Enumerable<AccountsUpsertWithWhereUniqueWithoutServicesInput>
    createMany?: AccountsCreateManyServicesInputEnvelope
    set?: Enumerable<AccountsWhereUniqueInput>
    disconnect?: Enumerable<AccountsWhereUniqueInput>
    delete?: Enumerable<AccountsWhereUniqueInput>
    connect?: Enumerable<AccountsWhereUniqueInput>
    update?: Enumerable<AccountsUpdateWithWhereUniqueWithoutServicesInput>
    updateMany?: Enumerable<AccountsUpdateManyWithWhereWithoutServicesInput>
    deleteMany?: Enumerable<AccountsScalarWhereInput>
  }

  export type AccountsUncheckedUpdateManyWithoutServicesNestedInput = {
    create?: XOR<Enumerable<AccountsCreateWithoutServicesInput>, Enumerable<AccountsUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<AccountsCreateOrConnectWithoutServicesInput>
    upsert?: Enumerable<AccountsUpsertWithWhereUniqueWithoutServicesInput>
    createMany?: AccountsCreateManyServicesInputEnvelope
    set?: Enumerable<AccountsWhereUniqueInput>
    disconnect?: Enumerable<AccountsWhereUniqueInput>
    delete?: Enumerable<AccountsWhereUniqueInput>
    connect?: Enumerable<AccountsWhereUniqueInput>
    update?: Enumerable<AccountsUpdateWithWhereUniqueWithoutServicesInput>
    updateMany?: Enumerable<AccountsUpdateManyWithWhereWithoutServicesInput>
    deleteMany?: Enumerable<AccountsScalarWhereInput>
  }

  export type AccountsCreateNestedOneWithoutStatisticsInput = {
    create?: XOR<AccountsCreateWithoutStatisticsInput, AccountsUncheckedCreateWithoutStatisticsInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutStatisticsInput
    connect?: AccountsWhereUniqueInput
  }

  export type TasksCreateNestedOneWithoutStatisticsInput = {
    create?: XOR<TasksCreateWithoutStatisticsInput, TasksUncheckedCreateWithoutStatisticsInput>
    connectOrCreate?: TasksCreateOrConnectWithoutStatisticsInput
    connect?: TasksWhereUniqueInput
  }

  export type TeamsCreateNestedOneWithoutStatisticsInput = {
    create?: XOR<TeamsCreateWithoutStatisticsInput, TeamsUncheckedCreateWithoutStatisticsInput>
    connectOrCreate?: TeamsCreateOrConnectWithoutStatisticsInput
    connect?: TeamsWhereUniqueInput
  }

  export type AccountsUpdateOneWithoutStatisticsNestedInput = {
    create?: XOR<AccountsCreateWithoutStatisticsInput, AccountsUncheckedCreateWithoutStatisticsInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutStatisticsInput
    upsert?: AccountsUpsertWithoutStatisticsInput
    disconnect?: boolean
    delete?: boolean
    connect?: AccountsWhereUniqueInput
    update?: XOR<AccountsUpdateWithoutStatisticsInput, AccountsUncheckedUpdateWithoutStatisticsInput>
  }

  export type TasksUpdateOneWithoutStatisticsNestedInput = {
    create?: XOR<TasksCreateWithoutStatisticsInput, TasksUncheckedCreateWithoutStatisticsInput>
    connectOrCreate?: TasksCreateOrConnectWithoutStatisticsInput
    upsert?: TasksUpsertWithoutStatisticsInput
    disconnect?: boolean
    delete?: boolean
    connect?: TasksWhereUniqueInput
    update?: XOR<TasksUpdateWithoutStatisticsInput, TasksUncheckedUpdateWithoutStatisticsInput>
  }

  export type TeamsUpdateOneWithoutStatisticsNestedInput = {
    create?: XOR<TeamsCreateWithoutStatisticsInput, TeamsUncheckedCreateWithoutStatisticsInput>
    connectOrCreate?: TeamsCreateOrConnectWithoutStatisticsInput
    upsert?: TeamsUpsertWithoutStatisticsInput
    disconnect?: boolean
    delete?: boolean
    connect?: TeamsWhereUniqueInput
    update?: XOR<TeamsUpdateWithoutStatisticsInput, TeamsUncheckedUpdateWithoutStatisticsInput>
  }

  export type AccountsCreateNestedOneWithoutSubscribesInput = {
    create?: XOR<AccountsCreateWithoutSubscribesInput, AccountsUncheckedCreateWithoutSubscribesInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutSubscribesInput
    connect?: AccountsWhereUniqueInput
  }

  export type AccountsUpdateOneRequiredWithoutSubscribesNestedInput = {
    create?: XOR<AccountsCreateWithoutSubscribesInput, AccountsUncheckedCreateWithoutSubscribesInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutSubscribesInput
    upsert?: AccountsUpsertWithoutSubscribesInput
    connect?: AccountsWhereUniqueInput
    update?: XOR<AccountsUpdateWithoutSubscribesInput, AccountsUncheckedUpdateWithoutSubscribesInput>
  }

  export type AccountsCreateNestedOneWithoutTaskDetailResourcesInput = {
    create?: XOR<AccountsCreateWithoutTaskDetailResourcesInput, AccountsUncheckedCreateWithoutTaskDetailResourcesInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutTaskDetailResourcesInput
    connect?: AccountsWhereUniqueInput
  }

  export type TaskDetailsCreateNestedOneWithoutTaskDetailResourcesInput = {
    create?: XOR<TaskDetailsCreateWithoutTaskDetailResourcesInput, TaskDetailsUncheckedCreateWithoutTaskDetailResourcesInput>
    connectOrCreate?: TaskDetailsCreateOrConnectWithoutTaskDetailResourcesInput
    connect?: TaskDetailsWhereUniqueInput
  }

  export type AccountsUpdateOneWithoutTaskDetailResourcesNestedInput = {
    create?: XOR<AccountsCreateWithoutTaskDetailResourcesInput, AccountsUncheckedCreateWithoutTaskDetailResourcesInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutTaskDetailResourcesInput
    upsert?: AccountsUpsertWithoutTaskDetailResourcesInput
    disconnect?: boolean
    delete?: boolean
    connect?: AccountsWhereUniqueInput
    update?: XOR<AccountsUpdateWithoutTaskDetailResourcesInput, AccountsUncheckedUpdateWithoutTaskDetailResourcesInput>
  }

  export type TaskDetailsUpdateOneWithoutTaskDetailResourcesNestedInput = {
    create?: XOR<TaskDetailsCreateWithoutTaskDetailResourcesInput, TaskDetailsUncheckedCreateWithoutTaskDetailResourcesInput>
    connectOrCreate?: TaskDetailsCreateOrConnectWithoutTaskDetailResourcesInput
    upsert?: TaskDetailsUpsertWithoutTaskDetailResourcesInput
    disconnect?: boolean
    delete?: boolean
    connect?: TaskDetailsWhereUniqueInput
    update?: XOR<TaskDetailsUpdateWithoutTaskDetailResourcesInput, TaskDetailsUncheckedUpdateWithoutTaskDetailResourcesInput>
  }

  export type AccountsCreateNestedOneWithoutTaskDetailsInput = {
    create?: XOR<AccountsCreateWithoutTaskDetailsInput, AccountsUncheckedCreateWithoutTaskDetailsInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutTaskDetailsInput
    connect?: AccountsWhereUniqueInput
  }

  export type TasksCreateNestedOneWithoutTaskDetailsInput = {
    create?: XOR<TasksCreateWithoutTaskDetailsInput, TasksUncheckedCreateWithoutTaskDetailsInput>
    connectOrCreate?: TasksCreateOrConnectWithoutTaskDetailsInput
    connect?: TasksWhereUniqueInput
  }

  export type TeamsCreateNestedOneWithoutTaskDetailsInput = {
    create?: XOR<TeamsCreateWithoutTaskDetailsInput, TeamsUncheckedCreateWithoutTaskDetailsInput>
    connectOrCreate?: TeamsCreateOrConnectWithoutTaskDetailsInput
    connect?: TeamsWhereUniqueInput
  }

  export type TaskDetailResourcesCreateNestedManyWithoutTaskDetailsInput = {
    create?: XOR<Enumerable<TaskDetailResourcesCreateWithoutTaskDetailsInput>, Enumerable<TaskDetailResourcesUncheckedCreateWithoutTaskDetailsInput>>
    connectOrCreate?: Enumerable<TaskDetailResourcesCreateOrConnectWithoutTaskDetailsInput>
    createMany?: TaskDetailResourcesCreateManyTaskDetailsInputEnvelope
    connect?: Enumerable<TaskDetailResourcesWhereUniqueInput>
  }

  export type TaskDetailResourcesUncheckedCreateNestedManyWithoutTaskDetailsInput = {
    create?: XOR<Enumerable<TaskDetailResourcesCreateWithoutTaskDetailsInput>, Enumerable<TaskDetailResourcesUncheckedCreateWithoutTaskDetailsInput>>
    connectOrCreate?: Enumerable<TaskDetailResourcesCreateOrConnectWithoutTaskDetailsInput>
    createMany?: TaskDetailResourcesCreateManyTaskDetailsInputEnvelope
    connect?: Enumerable<TaskDetailResourcesWhereUniqueInput>
  }

  export type AccountsUpdateOneWithoutTaskDetailsNestedInput = {
    create?: XOR<AccountsCreateWithoutTaskDetailsInput, AccountsUncheckedCreateWithoutTaskDetailsInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutTaskDetailsInput
    upsert?: AccountsUpsertWithoutTaskDetailsInput
    disconnect?: boolean
    delete?: boolean
    connect?: AccountsWhereUniqueInput
    update?: XOR<AccountsUpdateWithoutTaskDetailsInput, AccountsUncheckedUpdateWithoutTaskDetailsInput>
  }

  export type TasksUpdateOneWithoutTaskDetailsNestedInput = {
    create?: XOR<TasksCreateWithoutTaskDetailsInput, TasksUncheckedCreateWithoutTaskDetailsInput>
    connectOrCreate?: TasksCreateOrConnectWithoutTaskDetailsInput
    upsert?: TasksUpsertWithoutTaskDetailsInput
    disconnect?: boolean
    delete?: boolean
    connect?: TasksWhereUniqueInput
    update?: XOR<TasksUpdateWithoutTaskDetailsInput, TasksUncheckedUpdateWithoutTaskDetailsInput>
  }

  export type TeamsUpdateOneWithoutTaskDetailsNestedInput = {
    create?: XOR<TeamsCreateWithoutTaskDetailsInput, TeamsUncheckedCreateWithoutTaskDetailsInput>
    connectOrCreate?: TeamsCreateOrConnectWithoutTaskDetailsInput
    upsert?: TeamsUpsertWithoutTaskDetailsInput
    disconnect?: boolean
    delete?: boolean
    connect?: TeamsWhereUniqueInput
    update?: XOR<TeamsUpdateWithoutTaskDetailsInput, TeamsUncheckedUpdateWithoutTaskDetailsInput>
  }

  export type TaskDetailResourcesUpdateManyWithoutTaskDetailsNestedInput = {
    create?: XOR<Enumerable<TaskDetailResourcesCreateWithoutTaskDetailsInput>, Enumerable<TaskDetailResourcesUncheckedCreateWithoutTaskDetailsInput>>
    connectOrCreate?: Enumerable<TaskDetailResourcesCreateOrConnectWithoutTaskDetailsInput>
    upsert?: Enumerable<TaskDetailResourcesUpsertWithWhereUniqueWithoutTaskDetailsInput>
    createMany?: TaskDetailResourcesCreateManyTaskDetailsInputEnvelope
    set?: Enumerable<TaskDetailResourcesWhereUniqueInput>
    disconnect?: Enumerable<TaskDetailResourcesWhereUniqueInput>
    delete?: Enumerable<TaskDetailResourcesWhereUniqueInput>
    connect?: Enumerable<TaskDetailResourcesWhereUniqueInput>
    update?: Enumerable<TaskDetailResourcesUpdateWithWhereUniqueWithoutTaskDetailsInput>
    updateMany?: Enumerable<TaskDetailResourcesUpdateManyWithWhereWithoutTaskDetailsInput>
    deleteMany?: Enumerable<TaskDetailResourcesScalarWhereInput>
  }

  export type TaskDetailResourcesUncheckedUpdateManyWithoutTaskDetailsNestedInput = {
    create?: XOR<Enumerable<TaskDetailResourcesCreateWithoutTaskDetailsInput>, Enumerable<TaskDetailResourcesUncheckedCreateWithoutTaskDetailsInput>>
    connectOrCreate?: Enumerable<TaskDetailResourcesCreateOrConnectWithoutTaskDetailsInput>
    upsert?: Enumerable<TaskDetailResourcesUpsertWithWhereUniqueWithoutTaskDetailsInput>
    createMany?: TaskDetailResourcesCreateManyTaskDetailsInputEnvelope
    set?: Enumerable<TaskDetailResourcesWhereUniqueInput>
    disconnect?: Enumerable<TaskDetailResourcesWhereUniqueInput>
    delete?: Enumerable<TaskDetailResourcesWhereUniqueInput>
    connect?: Enumerable<TaskDetailResourcesWhereUniqueInput>
    update?: Enumerable<TaskDetailResourcesUpdateWithWhereUniqueWithoutTaskDetailsInput>
    updateMany?: Enumerable<TaskDetailResourcesUpdateManyWithWhereWithoutTaskDetailsInput>
    deleteMany?: Enumerable<TaskDetailResourcesScalarWhereInput>
  }

  export type AccountsCreateNestedOneWithoutTaskGroupsInput = {
    create?: XOR<AccountsCreateWithoutTaskGroupsInput, AccountsUncheckedCreateWithoutTaskGroupsInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutTaskGroupsInput
    connect?: AccountsWhereUniqueInput
  }

  export type TasksCreateNestedManyWithoutTaskGroupsInput = {
    create?: XOR<Enumerable<TasksCreateWithoutTaskGroupsInput>, Enumerable<TasksUncheckedCreateWithoutTaskGroupsInput>>
    connectOrCreate?: Enumerable<TasksCreateOrConnectWithoutTaskGroupsInput>
    createMany?: TasksCreateManyTaskGroupsInputEnvelope
    connect?: Enumerable<TasksWhereUniqueInput>
  }

  export type TasksUncheckedCreateNestedManyWithoutTaskGroupsInput = {
    create?: XOR<Enumerable<TasksCreateWithoutTaskGroupsInput>, Enumerable<TasksUncheckedCreateWithoutTaskGroupsInput>>
    connectOrCreate?: Enumerable<TasksCreateOrConnectWithoutTaskGroupsInput>
    createMany?: TasksCreateManyTaskGroupsInputEnvelope
    connect?: Enumerable<TasksWhereUniqueInput>
  }

  export type AccountsUpdateOneWithoutTaskGroupsNestedInput = {
    create?: XOR<AccountsCreateWithoutTaskGroupsInput, AccountsUncheckedCreateWithoutTaskGroupsInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutTaskGroupsInput
    upsert?: AccountsUpsertWithoutTaskGroupsInput
    disconnect?: boolean
    delete?: boolean
    connect?: AccountsWhereUniqueInput
    update?: XOR<AccountsUpdateWithoutTaskGroupsInput, AccountsUncheckedUpdateWithoutTaskGroupsInput>
  }

  export type TasksUpdateManyWithoutTaskGroupsNestedInput = {
    create?: XOR<Enumerable<TasksCreateWithoutTaskGroupsInput>, Enumerable<TasksUncheckedCreateWithoutTaskGroupsInput>>
    connectOrCreate?: Enumerable<TasksCreateOrConnectWithoutTaskGroupsInput>
    upsert?: Enumerable<TasksUpsertWithWhereUniqueWithoutTaskGroupsInput>
    createMany?: TasksCreateManyTaskGroupsInputEnvelope
    set?: Enumerable<TasksWhereUniqueInput>
    disconnect?: Enumerable<TasksWhereUniqueInput>
    delete?: Enumerable<TasksWhereUniqueInput>
    connect?: Enumerable<TasksWhereUniqueInput>
    update?: Enumerable<TasksUpdateWithWhereUniqueWithoutTaskGroupsInput>
    updateMany?: Enumerable<TasksUpdateManyWithWhereWithoutTaskGroupsInput>
    deleteMany?: Enumerable<TasksScalarWhereInput>
  }

  export type TasksUncheckedUpdateManyWithoutTaskGroupsNestedInput = {
    create?: XOR<Enumerable<TasksCreateWithoutTaskGroupsInput>, Enumerable<TasksUncheckedCreateWithoutTaskGroupsInput>>
    connectOrCreate?: Enumerable<TasksCreateOrConnectWithoutTaskGroupsInput>
    upsert?: Enumerable<TasksUpsertWithWhereUniqueWithoutTaskGroupsInput>
    createMany?: TasksCreateManyTaskGroupsInputEnvelope
    set?: Enumerable<TasksWhereUniqueInput>
    disconnect?: Enumerable<TasksWhereUniqueInput>
    delete?: Enumerable<TasksWhereUniqueInput>
    connect?: Enumerable<TasksWhereUniqueInput>
    update?: Enumerable<TasksUpdateWithWhereUniqueWithoutTaskGroupsInput>
    updateMany?: Enumerable<TasksUpdateManyWithWhereWithoutTaskGroupsInput>
    deleteMany?: Enumerable<TasksScalarWhereInput>
  }

  export type AccountsCreateNestedOneWithoutTasksInput = {
    create?: XOR<AccountsCreateWithoutTasksInput, AccountsUncheckedCreateWithoutTasksInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutTasksInput
    connect?: AccountsWhereUniqueInput
  }

  export type TaskGroupsCreateNestedOneWithoutTasksInput = {
    create?: XOR<TaskGroupsCreateWithoutTasksInput, TaskGroupsUncheckedCreateWithoutTasksInput>
    connectOrCreate?: TaskGroupsCreateOrConnectWithoutTasksInput
    connect?: TaskGroupsWhereUniqueInput
  }

  export type ReportsCreateNestedManyWithoutTasksInput = {
    create?: XOR<Enumerable<ReportsCreateWithoutTasksInput>, Enumerable<ReportsUncheckedCreateWithoutTasksInput>>
    connectOrCreate?: Enumerable<ReportsCreateOrConnectWithoutTasksInput>
    createMany?: ReportsCreateManyTasksInputEnvelope
    connect?: Enumerable<ReportsWhereUniqueInput>
  }

  export type StatisticsCreateNestedManyWithoutTasksInput = {
    create?: XOR<Enumerable<StatisticsCreateWithoutTasksInput>, Enumerable<StatisticsUncheckedCreateWithoutTasksInput>>
    connectOrCreate?: Enumerable<StatisticsCreateOrConnectWithoutTasksInput>
    createMany?: StatisticsCreateManyTasksInputEnvelope
    connect?: Enumerable<StatisticsWhereUniqueInput>
  }

  export type TaskDetailsCreateNestedManyWithoutTasksInput = {
    create?: XOR<Enumerable<TaskDetailsCreateWithoutTasksInput>, Enumerable<TaskDetailsUncheckedCreateWithoutTasksInput>>
    connectOrCreate?: Enumerable<TaskDetailsCreateOrConnectWithoutTasksInput>
    createMany?: TaskDetailsCreateManyTasksInputEnvelope
    connect?: Enumerable<TaskDetailsWhereUniqueInput>
  }

  export type TeamsCreateNestedManyWithoutTasksInput = {
    create?: XOR<Enumerable<TeamsCreateWithoutTasksInput>, Enumerable<TeamsUncheckedCreateWithoutTasksInput>>
    connectOrCreate?: Enumerable<TeamsCreateOrConnectWithoutTasksInput>
    createMany?: TeamsCreateManyTasksInputEnvelope
    connect?: Enumerable<TeamsWhereUniqueInput>
  }

  export type ReportsUncheckedCreateNestedManyWithoutTasksInput = {
    create?: XOR<Enumerable<ReportsCreateWithoutTasksInput>, Enumerable<ReportsUncheckedCreateWithoutTasksInput>>
    connectOrCreate?: Enumerable<ReportsCreateOrConnectWithoutTasksInput>
    createMany?: ReportsCreateManyTasksInputEnvelope
    connect?: Enumerable<ReportsWhereUniqueInput>
  }

  export type StatisticsUncheckedCreateNestedManyWithoutTasksInput = {
    create?: XOR<Enumerable<StatisticsCreateWithoutTasksInput>, Enumerable<StatisticsUncheckedCreateWithoutTasksInput>>
    connectOrCreate?: Enumerable<StatisticsCreateOrConnectWithoutTasksInput>
    createMany?: StatisticsCreateManyTasksInputEnvelope
    connect?: Enumerable<StatisticsWhereUniqueInput>
  }

  export type TaskDetailsUncheckedCreateNestedManyWithoutTasksInput = {
    create?: XOR<Enumerable<TaskDetailsCreateWithoutTasksInput>, Enumerable<TaskDetailsUncheckedCreateWithoutTasksInput>>
    connectOrCreate?: Enumerable<TaskDetailsCreateOrConnectWithoutTasksInput>
    createMany?: TaskDetailsCreateManyTasksInputEnvelope
    connect?: Enumerable<TaskDetailsWhereUniqueInput>
  }

  export type TeamsUncheckedCreateNestedManyWithoutTasksInput = {
    create?: XOR<Enumerable<TeamsCreateWithoutTasksInput>, Enumerable<TeamsUncheckedCreateWithoutTasksInput>>
    connectOrCreate?: Enumerable<TeamsCreateOrConnectWithoutTasksInput>
    createMany?: TeamsCreateManyTasksInputEnvelope
    connect?: Enumerable<TeamsWhereUniqueInput>
  }

  export type AccountsUpdateOneWithoutTasksNestedInput = {
    create?: XOR<AccountsCreateWithoutTasksInput, AccountsUncheckedCreateWithoutTasksInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutTasksInput
    upsert?: AccountsUpsertWithoutTasksInput
    disconnect?: boolean
    delete?: boolean
    connect?: AccountsWhereUniqueInput
    update?: XOR<AccountsUpdateWithoutTasksInput, AccountsUncheckedUpdateWithoutTasksInput>
  }

  export type TaskGroupsUpdateOneWithoutTasksNestedInput = {
    create?: XOR<TaskGroupsCreateWithoutTasksInput, TaskGroupsUncheckedCreateWithoutTasksInput>
    connectOrCreate?: TaskGroupsCreateOrConnectWithoutTasksInput
    upsert?: TaskGroupsUpsertWithoutTasksInput
    disconnect?: boolean
    delete?: boolean
    connect?: TaskGroupsWhereUniqueInput
    update?: XOR<TaskGroupsUpdateWithoutTasksInput, TaskGroupsUncheckedUpdateWithoutTasksInput>
  }

  export type ReportsUpdateManyWithoutTasksNestedInput = {
    create?: XOR<Enumerable<ReportsCreateWithoutTasksInput>, Enumerable<ReportsUncheckedCreateWithoutTasksInput>>
    connectOrCreate?: Enumerable<ReportsCreateOrConnectWithoutTasksInput>
    upsert?: Enumerable<ReportsUpsertWithWhereUniqueWithoutTasksInput>
    createMany?: ReportsCreateManyTasksInputEnvelope
    set?: Enumerable<ReportsWhereUniqueInput>
    disconnect?: Enumerable<ReportsWhereUniqueInput>
    delete?: Enumerable<ReportsWhereUniqueInput>
    connect?: Enumerable<ReportsWhereUniqueInput>
    update?: Enumerable<ReportsUpdateWithWhereUniqueWithoutTasksInput>
    updateMany?: Enumerable<ReportsUpdateManyWithWhereWithoutTasksInput>
    deleteMany?: Enumerable<ReportsScalarWhereInput>
  }

  export type StatisticsUpdateManyWithoutTasksNestedInput = {
    create?: XOR<Enumerable<StatisticsCreateWithoutTasksInput>, Enumerable<StatisticsUncheckedCreateWithoutTasksInput>>
    connectOrCreate?: Enumerable<StatisticsCreateOrConnectWithoutTasksInput>
    upsert?: Enumerable<StatisticsUpsertWithWhereUniqueWithoutTasksInput>
    createMany?: StatisticsCreateManyTasksInputEnvelope
    set?: Enumerable<StatisticsWhereUniqueInput>
    disconnect?: Enumerable<StatisticsWhereUniqueInput>
    delete?: Enumerable<StatisticsWhereUniqueInput>
    connect?: Enumerable<StatisticsWhereUniqueInput>
    update?: Enumerable<StatisticsUpdateWithWhereUniqueWithoutTasksInput>
    updateMany?: Enumerable<StatisticsUpdateManyWithWhereWithoutTasksInput>
    deleteMany?: Enumerable<StatisticsScalarWhereInput>
  }

  export type TaskDetailsUpdateManyWithoutTasksNestedInput = {
    create?: XOR<Enumerable<TaskDetailsCreateWithoutTasksInput>, Enumerable<TaskDetailsUncheckedCreateWithoutTasksInput>>
    connectOrCreate?: Enumerable<TaskDetailsCreateOrConnectWithoutTasksInput>
    upsert?: Enumerable<TaskDetailsUpsertWithWhereUniqueWithoutTasksInput>
    createMany?: TaskDetailsCreateManyTasksInputEnvelope
    set?: Enumerable<TaskDetailsWhereUniqueInput>
    disconnect?: Enumerable<TaskDetailsWhereUniqueInput>
    delete?: Enumerable<TaskDetailsWhereUniqueInput>
    connect?: Enumerable<TaskDetailsWhereUniqueInput>
    update?: Enumerable<TaskDetailsUpdateWithWhereUniqueWithoutTasksInput>
    updateMany?: Enumerable<TaskDetailsUpdateManyWithWhereWithoutTasksInput>
    deleteMany?: Enumerable<TaskDetailsScalarWhereInput>
  }

  export type TeamsUpdateManyWithoutTasksNestedInput = {
    create?: XOR<Enumerable<TeamsCreateWithoutTasksInput>, Enumerable<TeamsUncheckedCreateWithoutTasksInput>>
    connectOrCreate?: Enumerable<TeamsCreateOrConnectWithoutTasksInput>
    upsert?: Enumerable<TeamsUpsertWithWhereUniqueWithoutTasksInput>
    createMany?: TeamsCreateManyTasksInputEnvelope
    set?: Enumerable<TeamsWhereUniqueInput>
    disconnect?: Enumerable<TeamsWhereUniqueInput>
    delete?: Enumerable<TeamsWhereUniqueInput>
    connect?: Enumerable<TeamsWhereUniqueInput>
    update?: Enumerable<TeamsUpdateWithWhereUniqueWithoutTasksInput>
    updateMany?: Enumerable<TeamsUpdateManyWithWhereWithoutTasksInput>
    deleteMany?: Enumerable<TeamsScalarWhereInput>
  }

  export type ReportsUncheckedUpdateManyWithoutTasksNestedInput = {
    create?: XOR<Enumerable<ReportsCreateWithoutTasksInput>, Enumerable<ReportsUncheckedCreateWithoutTasksInput>>
    connectOrCreate?: Enumerable<ReportsCreateOrConnectWithoutTasksInput>
    upsert?: Enumerable<ReportsUpsertWithWhereUniqueWithoutTasksInput>
    createMany?: ReportsCreateManyTasksInputEnvelope
    set?: Enumerable<ReportsWhereUniqueInput>
    disconnect?: Enumerable<ReportsWhereUniqueInput>
    delete?: Enumerable<ReportsWhereUniqueInput>
    connect?: Enumerable<ReportsWhereUniqueInput>
    update?: Enumerable<ReportsUpdateWithWhereUniqueWithoutTasksInput>
    updateMany?: Enumerable<ReportsUpdateManyWithWhereWithoutTasksInput>
    deleteMany?: Enumerable<ReportsScalarWhereInput>
  }

  export type StatisticsUncheckedUpdateManyWithoutTasksNestedInput = {
    create?: XOR<Enumerable<StatisticsCreateWithoutTasksInput>, Enumerable<StatisticsUncheckedCreateWithoutTasksInput>>
    connectOrCreate?: Enumerable<StatisticsCreateOrConnectWithoutTasksInput>
    upsert?: Enumerable<StatisticsUpsertWithWhereUniqueWithoutTasksInput>
    createMany?: StatisticsCreateManyTasksInputEnvelope
    set?: Enumerable<StatisticsWhereUniqueInput>
    disconnect?: Enumerable<StatisticsWhereUniqueInput>
    delete?: Enumerable<StatisticsWhereUniqueInput>
    connect?: Enumerable<StatisticsWhereUniqueInput>
    update?: Enumerable<StatisticsUpdateWithWhereUniqueWithoutTasksInput>
    updateMany?: Enumerable<StatisticsUpdateManyWithWhereWithoutTasksInput>
    deleteMany?: Enumerable<StatisticsScalarWhereInput>
  }

  export type TaskDetailsUncheckedUpdateManyWithoutTasksNestedInput = {
    create?: XOR<Enumerable<TaskDetailsCreateWithoutTasksInput>, Enumerable<TaskDetailsUncheckedCreateWithoutTasksInput>>
    connectOrCreate?: Enumerable<TaskDetailsCreateOrConnectWithoutTasksInput>
    upsert?: Enumerable<TaskDetailsUpsertWithWhereUniqueWithoutTasksInput>
    createMany?: TaskDetailsCreateManyTasksInputEnvelope
    set?: Enumerable<TaskDetailsWhereUniqueInput>
    disconnect?: Enumerable<TaskDetailsWhereUniqueInput>
    delete?: Enumerable<TaskDetailsWhereUniqueInput>
    connect?: Enumerable<TaskDetailsWhereUniqueInput>
    update?: Enumerable<TaskDetailsUpdateWithWhereUniqueWithoutTasksInput>
    updateMany?: Enumerable<TaskDetailsUpdateManyWithWhereWithoutTasksInput>
    deleteMany?: Enumerable<TaskDetailsScalarWhereInput>
  }

  export type TeamsUncheckedUpdateManyWithoutTasksNestedInput = {
    create?: XOR<Enumerable<TeamsCreateWithoutTasksInput>, Enumerable<TeamsUncheckedCreateWithoutTasksInput>>
    connectOrCreate?: Enumerable<TeamsCreateOrConnectWithoutTasksInput>
    upsert?: Enumerable<TeamsUpsertWithWhereUniqueWithoutTasksInput>
    createMany?: TeamsCreateManyTasksInputEnvelope
    set?: Enumerable<TeamsWhereUniqueInput>
    disconnect?: Enumerable<TeamsWhereUniqueInput>
    delete?: Enumerable<TeamsWhereUniqueInput>
    connect?: Enumerable<TeamsWhereUniqueInput>
    update?: Enumerable<TeamsUpdateWithWhereUniqueWithoutTasksInput>
    updateMany?: Enumerable<TeamsUpdateManyWithWhereWithoutTasksInput>
    deleteMany?: Enumerable<TeamsScalarWhereInput>
  }

  export type AccountsCreateNestedOneWithoutTeamAgentsInput = {
    create?: XOR<AccountsCreateWithoutTeamAgentsInput, AccountsUncheckedCreateWithoutTeamAgentsInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutTeamAgentsInput
    connect?: AccountsWhereUniqueInput
  }

  export type TeamsCreateNestedOneWithoutTeamAgentsInput = {
    create?: XOR<TeamsCreateWithoutTeamAgentsInput, TeamsUncheckedCreateWithoutTeamAgentsInput>
    connectOrCreate?: TeamsCreateOrConnectWithoutTeamAgentsInput
    connect?: TeamsWhereUniqueInput
  }

  export type AccountsUpdateOneRequiredWithoutTeamAgentsNestedInput = {
    create?: XOR<AccountsCreateWithoutTeamAgentsInput, AccountsUncheckedCreateWithoutTeamAgentsInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutTeamAgentsInput
    upsert?: AccountsUpsertWithoutTeamAgentsInput
    connect?: AccountsWhereUniqueInput
    update?: XOR<AccountsUpdateWithoutTeamAgentsInput, AccountsUncheckedUpdateWithoutTeamAgentsInput>
  }

  export type TeamsUpdateOneRequiredWithoutTeamAgentsNestedInput = {
    create?: XOR<TeamsCreateWithoutTeamAgentsInput, TeamsUncheckedCreateWithoutTeamAgentsInput>
    connectOrCreate?: TeamsCreateOrConnectWithoutTeamAgentsInput
    upsert?: TeamsUpsertWithoutTeamAgentsInput
    connect?: TeamsWhereUniqueInput
    update?: XOR<TeamsUpdateWithoutTeamAgentsInput, TeamsUncheckedUpdateWithoutTeamAgentsInput>
  }

  export type AccountsCreateNestedOneWithoutTeams_AccountsToTeams_AccountIdInput = {
    create?: XOR<AccountsCreateWithoutTeams_AccountsToTeams_AccountIdInput, AccountsUncheckedCreateWithoutTeams_AccountsToTeams_AccountIdInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutTeams_AccountsToTeams_AccountIdInput
    connect?: AccountsWhereUniqueInput
  }

  export type AccountsCreateNestedOneWithoutTeams_AccountsToTeams_AgentIdInput = {
    create?: XOR<AccountsCreateWithoutTeams_AccountsToTeams_AgentIdInput, AccountsUncheckedCreateWithoutTeams_AccountsToTeams_AgentIdInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutTeams_AccountsToTeams_AgentIdInput
    connect?: AccountsWhereUniqueInput
  }

  export type TasksCreateNestedOneWithoutTeamsInput = {
    create?: XOR<TasksCreateWithoutTeamsInput, TasksUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: TasksCreateOrConnectWithoutTeamsInput
    connect?: TasksWhereUniqueInput
  }

  export type StatisticsCreateNestedManyWithoutTeamsInput = {
    create?: XOR<Enumerable<StatisticsCreateWithoutTeamsInput>, Enumerable<StatisticsUncheckedCreateWithoutTeamsInput>>
    connectOrCreate?: Enumerable<StatisticsCreateOrConnectWithoutTeamsInput>
    createMany?: StatisticsCreateManyTeamsInputEnvelope
    connect?: Enumerable<StatisticsWhereUniqueInput>
  }

  export type TaskDetailsCreateNestedManyWithoutTeamsInput = {
    create?: XOR<Enumerable<TaskDetailsCreateWithoutTeamsInput>, Enumerable<TaskDetailsUncheckedCreateWithoutTeamsInput>>
    connectOrCreate?: Enumerable<TaskDetailsCreateOrConnectWithoutTeamsInput>
    createMany?: TaskDetailsCreateManyTeamsInputEnvelope
    connect?: Enumerable<TaskDetailsWhereUniqueInput>
  }

  export type TeamAgentsCreateNestedManyWithoutTeamsInput = {
    create?: XOR<Enumerable<TeamAgentsCreateWithoutTeamsInput>, Enumerable<TeamAgentsUncheckedCreateWithoutTeamsInput>>
    connectOrCreate?: Enumerable<TeamAgentsCreateOrConnectWithoutTeamsInput>
    createMany?: TeamAgentsCreateManyTeamsInputEnvelope
    connect?: Enumerable<TeamAgentsWhereUniqueInput>
  }

  export type StatisticsUncheckedCreateNestedManyWithoutTeamsInput = {
    create?: XOR<Enumerable<StatisticsCreateWithoutTeamsInput>, Enumerable<StatisticsUncheckedCreateWithoutTeamsInput>>
    connectOrCreate?: Enumerable<StatisticsCreateOrConnectWithoutTeamsInput>
    createMany?: StatisticsCreateManyTeamsInputEnvelope
    connect?: Enumerable<StatisticsWhereUniqueInput>
  }

  export type TaskDetailsUncheckedCreateNestedManyWithoutTeamsInput = {
    create?: XOR<Enumerable<TaskDetailsCreateWithoutTeamsInput>, Enumerable<TaskDetailsUncheckedCreateWithoutTeamsInput>>
    connectOrCreate?: Enumerable<TaskDetailsCreateOrConnectWithoutTeamsInput>
    createMany?: TaskDetailsCreateManyTeamsInputEnvelope
    connect?: Enumerable<TaskDetailsWhereUniqueInput>
  }

  export type TeamAgentsUncheckedCreateNestedManyWithoutTeamsInput = {
    create?: XOR<Enumerable<TeamAgentsCreateWithoutTeamsInput>, Enumerable<TeamAgentsUncheckedCreateWithoutTeamsInput>>
    connectOrCreate?: Enumerable<TeamAgentsCreateOrConnectWithoutTeamsInput>
    createMany?: TeamAgentsCreateManyTeamsInputEnvelope
    connect?: Enumerable<TeamAgentsWhereUniqueInput>
  }

  export type AccountsUpdateOneWithoutTeams_AccountsToTeams_AccountIdNestedInput = {
    create?: XOR<AccountsCreateWithoutTeams_AccountsToTeams_AccountIdInput, AccountsUncheckedCreateWithoutTeams_AccountsToTeams_AccountIdInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutTeams_AccountsToTeams_AccountIdInput
    upsert?: AccountsUpsertWithoutTeams_AccountsToTeams_AccountIdInput
    disconnect?: boolean
    delete?: boolean
    connect?: AccountsWhereUniqueInput
    update?: XOR<AccountsUpdateWithoutTeams_AccountsToTeams_AccountIdInput, AccountsUncheckedUpdateWithoutTeams_AccountsToTeams_AccountIdInput>
  }

  export type AccountsUpdateOneWithoutTeams_AccountsToTeams_AgentIdNestedInput = {
    create?: XOR<AccountsCreateWithoutTeams_AccountsToTeams_AgentIdInput, AccountsUncheckedCreateWithoutTeams_AccountsToTeams_AgentIdInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutTeams_AccountsToTeams_AgentIdInput
    upsert?: AccountsUpsertWithoutTeams_AccountsToTeams_AgentIdInput
    disconnect?: boolean
    delete?: boolean
    connect?: AccountsWhereUniqueInput
    update?: XOR<AccountsUpdateWithoutTeams_AccountsToTeams_AgentIdInput, AccountsUncheckedUpdateWithoutTeams_AccountsToTeams_AgentIdInput>
  }

  export type TasksUpdateOneWithoutTeamsNestedInput = {
    create?: XOR<TasksCreateWithoutTeamsInput, TasksUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: TasksCreateOrConnectWithoutTeamsInput
    upsert?: TasksUpsertWithoutTeamsInput
    disconnect?: boolean
    delete?: boolean
    connect?: TasksWhereUniqueInput
    update?: XOR<TasksUpdateWithoutTeamsInput, TasksUncheckedUpdateWithoutTeamsInput>
  }

  export type StatisticsUpdateManyWithoutTeamsNestedInput = {
    create?: XOR<Enumerable<StatisticsCreateWithoutTeamsInput>, Enumerable<StatisticsUncheckedCreateWithoutTeamsInput>>
    connectOrCreate?: Enumerable<StatisticsCreateOrConnectWithoutTeamsInput>
    upsert?: Enumerable<StatisticsUpsertWithWhereUniqueWithoutTeamsInput>
    createMany?: StatisticsCreateManyTeamsInputEnvelope
    set?: Enumerable<StatisticsWhereUniqueInput>
    disconnect?: Enumerable<StatisticsWhereUniqueInput>
    delete?: Enumerable<StatisticsWhereUniqueInput>
    connect?: Enumerable<StatisticsWhereUniqueInput>
    update?: Enumerable<StatisticsUpdateWithWhereUniqueWithoutTeamsInput>
    updateMany?: Enumerable<StatisticsUpdateManyWithWhereWithoutTeamsInput>
    deleteMany?: Enumerable<StatisticsScalarWhereInput>
  }

  export type TaskDetailsUpdateManyWithoutTeamsNestedInput = {
    create?: XOR<Enumerable<TaskDetailsCreateWithoutTeamsInput>, Enumerable<TaskDetailsUncheckedCreateWithoutTeamsInput>>
    connectOrCreate?: Enumerable<TaskDetailsCreateOrConnectWithoutTeamsInput>
    upsert?: Enumerable<TaskDetailsUpsertWithWhereUniqueWithoutTeamsInput>
    createMany?: TaskDetailsCreateManyTeamsInputEnvelope
    set?: Enumerable<TaskDetailsWhereUniqueInput>
    disconnect?: Enumerable<TaskDetailsWhereUniqueInput>
    delete?: Enumerable<TaskDetailsWhereUniqueInput>
    connect?: Enumerable<TaskDetailsWhereUniqueInput>
    update?: Enumerable<TaskDetailsUpdateWithWhereUniqueWithoutTeamsInput>
    updateMany?: Enumerable<TaskDetailsUpdateManyWithWhereWithoutTeamsInput>
    deleteMany?: Enumerable<TaskDetailsScalarWhereInput>
  }

  export type TeamAgentsUpdateManyWithoutTeamsNestedInput = {
    create?: XOR<Enumerable<TeamAgentsCreateWithoutTeamsInput>, Enumerable<TeamAgentsUncheckedCreateWithoutTeamsInput>>
    connectOrCreate?: Enumerable<TeamAgentsCreateOrConnectWithoutTeamsInput>
    upsert?: Enumerable<TeamAgentsUpsertWithWhereUniqueWithoutTeamsInput>
    createMany?: TeamAgentsCreateManyTeamsInputEnvelope
    set?: Enumerable<TeamAgentsWhereUniqueInput>
    disconnect?: Enumerable<TeamAgentsWhereUniqueInput>
    delete?: Enumerable<TeamAgentsWhereUniqueInput>
    connect?: Enumerable<TeamAgentsWhereUniqueInput>
    update?: Enumerable<TeamAgentsUpdateWithWhereUniqueWithoutTeamsInput>
    updateMany?: Enumerable<TeamAgentsUpdateManyWithWhereWithoutTeamsInput>
    deleteMany?: Enumerable<TeamAgentsScalarWhereInput>
  }

  export type StatisticsUncheckedUpdateManyWithoutTeamsNestedInput = {
    create?: XOR<Enumerable<StatisticsCreateWithoutTeamsInput>, Enumerable<StatisticsUncheckedCreateWithoutTeamsInput>>
    connectOrCreate?: Enumerable<StatisticsCreateOrConnectWithoutTeamsInput>
    upsert?: Enumerable<StatisticsUpsertWithWhereUniqueWithoutTeamsInput>
    createMany?: StatisticsCreateManyTeamsInputEnvelope
    set?: Enumerable<StatisticsWhereUniqueInput>
    disconnect?: Enumerable<StatisticsWhereUniqueInput>
    delete?: Enumerable<StatisticsWhereUniqueInput>
    connect?: Enumerable<StatisticsWhereUniqueInput>
    update?: Enumerable<StatisticsUpdateWithWhereUniqueWithoutTeamsInput>
    updateMany?: Enumerable<StatisticsUpdateManyWithWhereWithoutTeamsInput>
    deleteMany?: Enumerable<StatisticsScalarWhereInput>
  }

  export type TaskDetailsUncheckedUpdateManyWithoutTeamsNestedInput = {
    create?: XOR<Enumerable<TaskDetailsCreateWithoutTeamsInput>, Enumerable<TaskDetailsUncheckedCreateWithoutTeamsInput>>
    connectOrCreate?: Enumerable<TaskDetailsCreateOrConnectWithoutTeamsInput>
    upsert?: Enumerable<TaskDetailsUpsertWithWhereUniqueWithoutTeamsInput>
    createMany?: TaskDetailsCreateManyTeamsInputEnvelope
    set?: Enumerable<TaskDetailsWhereUniqueInput>
    disconnect?: Enumerable<TaskDetailsWhereUniqueInput>
    delete?: Enumerable<TaskDetailsWhereUniqueInput>
    connect?: Enumerable<TaskDetailsWhereUniqueInput>
    update?: Enumerable<TaskDetailsUpdateWithWhereUniqueWithoutTeamsInput>
    updateMany?: Enumerable<TaskDetailsUpdateManyWithWhereWithoutTeamsInput>
    deleteMany?: Enumerable<TaskDetailsScalarWhereInput>
  }

  export type TeamAgentsUncheckedUpdateManyWithoutTeamsNestedInput = {
    create?: XOR<Enumerable<TeamAgentsCreateWithoutTeamsInput>, Enumerable<TeamAgentsUncheckedCreateWithoutTeamsInput>>
    connectOrCreate?: Enumerable<TeamAgentsCreateOrConnectWithoutTeamsInput>
    upsert?: Enumerable<TeamAgentsUpsertWithWhereUniqueWithoutTeamsInput>
    createMany?: TeamAgentsCreateManyTeamsInputEnvelope
    set?: Enumerable<TeamAgentsWhereUniqueInput>
    disconnect?: Enumerable<TeamAgentsWhereUniqueInput>
    delete?: Enumerable<TeamAgentsWhereUniqueInput>
    connect?: Enumerable<TeamAgentsWhereUniqueInput>
    update?: Enumerable<TeamAgentsUpdateWithWhereUniqueWithoutTeamsInput>
    updateMany?: Enumerable<TeamAgentsUpdateManyWithWhereWithoutTeamsInput>
    deleteMany?: Enumerable<TeamAgentsScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }
  export type NestedJsonNullableFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase>, Exclude<keyof Required<NestedJsonNullableFilterBase>, 'path'>>,
        Required<NestedJsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase>, 'path'>>

  export type NestedJsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: Array<string>
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedBigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedBigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedDecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type NestedEnumenum_Permissions_keyFilter = {
    equals?: enum_Permissions_key
    in?: Enumerable<enum_Permissions_key>
    notIn?: Enumerable<enum_Permissions_key>
    not?: NestedEnumenum_Permissions_keyFilter | enum_Permissions_key
  }

  export type NestedEnumenum_Permissions_keyWithAggregatesFilter = {
    equals?: enum_Permissions_key
    in?: Enumerable<enum_Permissions_key>
    notIn?: Enumerable<enum_Permissions_key>
    not?: NestedEnumenum_Permissions_keyWithAggregatesFilter | enum_Permissions_key
    _count?: NestedIntFilter
    _min?: NestedEnumenum_Permissions_keyFilter
    _max?: NestedEnumenum_Permissions_keyFilter
  }

  export type ServicesCreateWithoutAccountsInput = {
    key: string
    description?: string | null
    isActive?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ServicesUncheckedCreateWithoutAccountsInput = {
    key: string
    description?: string | null
    isActive?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ServicesCreateOrConnectWithoutAccountsInput = {
    where: ServicesWhereUniqueInput
    create: XOR<ServicesCreateWithoutAccountsInput, ServicesUncheckedCreateWithoutAccountsInput>
  }

  export type AlertsCreateWithoutAccountsInput = {
    id?: bigint | number
    title?: string | null
    type: string
    category: string
    ReferenceId: number
    isRead?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AlertsUncheckedCreateWithoutAccountsInput = {
    id?: bigint | number
    title?: string | null
    type: string
    category: string
    ReferenceId: number
    isRead?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AlertsCreateOrConnectWithoutAccountsInput = {
    where: AlertsWhereUniqueInput
    create: XOR<AlertsCreateWithoutAccountsInput, AlertsUncheckedCreateWithoutAccountsInput>
  }

  export type AlertsCreateManyAccountsInputEnvelope = {
    data: Enumerable<AlertsCreateManyAccountsInput>
    skipDuplicates?: boolean
  }

  export type CareersCreateWithoutAccountsInput = {
    title?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    content?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CareersUncheckedCreateWithoutAccountsInput = {
    id?: number
    title?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    content?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CareersCreateOrConnectWithoutAccountsInput = {
    where: CareersWhereUniqueInput
    create: XOR<CareersCreateWithoutAccountsInput, CareersUncheckedCreateWithoutAccountsInput>
  }

  export type CareersCreateManyAccountsInputEnvelope = {
    data: Enumerable<CareersCreateManyAccountsInput>
    skipDuplicates?: boolean
  }

  export type CustomerTaskDetailsCreateWithoutAccountsInput = {
    type?: string | null
    address?: string | null
    villageName?: string | null
    category?: string | null
    etc?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: string | null
    y?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    createdAt: Date | string
    updatedAt: Date | string
    Customers?: CustomersCreateNestedOneWithoutCustomerTaskDetailsInput
  }

  export type CustomerTaskDetailsUncheckedCreateWithoutAccountsInput = {
    id?: number
    CustomerId?: number | null
    type?: string | null
    address?: string | null
    villageName?: string | null
    category?: string | null
    etc?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: string | null
    y?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CustomerTaskDetailsCreateOrConnectWithoutAccountsInput = {
    where: CustomerTaskDetailsWhereUniqueInput
    create: XOR<CustomerTaskDetailsCreateWithoutAccountsInput, CustomerTaskDetailsUncheckedCreateWithoutAccountsInput>
  }

  export type CustomerTaskDetailsCreateManyAccountsInputEnvelope = {
    data: Enumerable<CustomerTaskDetailsCreateManyAccountsInput>
    skipDuplicates?: boolean
  }

  export type CustomersCreateWithoutAccountsInput = {
    name?: string | null
    email?: string | null
    phone?: string | null
    crops?: CustomersCreatecropsInput | Enumerable<string>
    createdAt: Date | string
    updatedAt: Date | string
    CustomerTaskDetails?: CustomerTaskDetailsCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateWithoutAccountsInput = {
    id?: number
    name?: string | null
    email?: string | null
    phone?: string | null
    crops?: CustomersCreatecropsInput | Enumerable<string>
    createdAt: Date | string
    updatedAt: Date | string
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersCreateOrConnectWithoutAccountsInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutAccountsInput, CustomersUncheckedCreateWithoutAccountsInput>
  }

  export type CustomersCreateManyAccountsInputEnvelope = {
    data: Enumerable<CustomersCreateManyAccountsInput>
    skipDuplicates?: boolean
  }

  export type DiscountsCreateWithoutAccountsInput = {
    name?: string | null
    price?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    Coupons?: CouponsCreateNestedOneWithoutDiscountsInput
    Orders?: OrdersCreateNestedOneWithoutDiscountsInput
    Products?: ProductsCreateNestedOneWithoutDiscountsInput
  }

  export type DiscountsUncheckedCreateWithoutAccountsInput = {
    id?: number
    name?: string | null
    price?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    OrderId?: number | null
    CouponId?: number | null
    ProductId?: number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DiscountsCreateOrConnectWithoutAccountsInput = {
    where: DiscountsWhereUniqueInput
    create: XOR<DiscountsCreateWithoutAccountsInput, DiscountsUncheckedCreateWithoutAccountsInput>
  }

  export type DiscountsCreateManyAccountsInputEnvelope = {
    data: Enumerable<DiscountsCreateManyAccountsInput>
    skipDuplicates?: boolean
  }

  export type LandsCreateWithoutAccountsInput = {
    id?: bigint | number
    is_active?: boolean | null
    type?: string | null
    villageName?: string | null
    status?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: string | null
    y?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type LandsUncheckedCreateWithoutAccountsInput = {
    id?: bigint | number
    is_active?: boolean | null
    type?: string | null
    villageName?: string | null
    status?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: string | null
    y?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type LandsCreateOrConnectWithoutAccountsInput = {
    where: LandsWhereUniqueInput
    create: XOR<LandsCreateWithoutAccountsInput, LandsUncheckedCreateWithoutAccountsInput>
  }

  export type LandsCreateManyAccountsInputEnvelope = {
    data: Enumerable<LandsCreateManyAccountsInput>
    skipDuplicates?: boolean
  }

  export type NotificationsCreateWithoutAccountsInput = {
    id?: bigint | number
    fcmToken: string
    sendedAt?: Date | string | null
    isSuccess?: boolean | null
    failReason?: string | null
    eventCode: string
    sendCode: string
    reservationCode: string
    sendCycleCode: string
    title: string
    message: string
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type NotificationsUncheckedCreateWithoutAccountsInput = {
    id?: bigint | number
    fcmToken: string
    sendedAt?: Date | string | null
    isSuccess?: boolean | null
    failReason?: string | null
    eventCode: string
    sendCode: string
    reservationCode: string
    sendCycleCode: string
    title: string
    message: string
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type NotificationsCreateOrConnectWithoutAccountsInput = {
    where: NotificationsWhereUniqueInput
    create: XOR<NotificationsCreateWithoutAccountsInput, NotificationsUncheckedCreateWithoutAccountsInput>
  }

  export type NotificationsCreateManyAccountsInputEnvelope = {
    data: Enumerable<NotificationsCreateManyAccountsInput>
    skipDuplicates?: boolean
  }

  export type OrderHistoriesCreateWithoutAccountsInput = {
    name?: string | null
    payment?: string | null
    paymentMethod?: string | null
    externalUid?: string | null
    customerUid?: string | null
    merchantUid?: string | null
    reqAmount?: number | null
    paidAmount?: number | null
    status?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    Orders?: OrdersCreateNestedOneWithoutOrderHistoriesInput
    Products?: ProductsCreateNestedOneWithoutOrderHistoriesInput
  }

  export type OrderHistoriesUncheckedCreateWithoutAccountsInput = {
    id?: number
    name?: string | null
    payment?: string | null
    paymentMethod?: string | null
    externalUid?: string | null
    customerUid?: string | null
    merchantUid?: string | null
    reqAmount?: number | null
    paidAmount?: number | null
    status?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    ProductId?: number | null
    OrderId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type OrderHistoriesCreateOrConnectWithoutAccountsInput = {
    where: OrderHistoriesWhereUniqueInput
    create: XOR<OrderHistoriesCreateWithoutAccountsInput, OrderHistoriesUncheckedCreateWithoutAccountsInput>
  }

  export type OrderHistoriesCreateManyAccountsInputEnvelope = {
    data: Enumerable<OrderHistoriesCreateManyAccountsInput>
    skipDuplicates?: boolean
  }

  export type OrdersCreateWithoutAccountsInput = {
    name?: string | null
    payment?: string | null
    paymentMethod?: string | null
    externalUid?: string | null
    customerUid?: string | null
    merchantUid?: string | null
    reqAmount?: number | null
    paidAmount?: number | null
    status?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    expiredAt?: Date | string | null
    isSubscribe?: boolean | null
    issuedAt?: Date | string | null
    Products?: ProductsCreateNestedOneWithoutOrdersInput
    Discounts?: DiscountsCreateNestedManyWithoutOrdersInput
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutOrdersInput
  }

  export type OrdersUncheckedCreateWithoutAccountsInput = {
    id?: number
    name?: string | null
    payment?: string | null
    paymentMethod?: string | null
    externalUid?: string | null
    customerUid?: string | null
    merchantUid?: string | null
    reqAmount?: number | null
    paidAmount?: number | null
    status?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    ProductId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    expiredAt?: Date | string | null
    isSubscribe?: boolean | null
    issuedAt?: Date | string | null
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutOrdersInput
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type OrdersCreateOrConnectWithoutAccountsInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutAccountsInput, OrdersUncheckedCreateWithoutAccountsInput>
  }

  export type OrdersCreateManyAccountsInputEnvelope = {
    data: Enumerable<OrdersCreateManyAccountsInput>
    skipDuplicates?: boolean
  }

  export type PermissionsCreateWithoutAccountsInput = {
    resource: string
    key: enum_Permissions_key
    resourceId: number
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type PermissionsUncheckedCreateWithoutAccountsInput = {
    id?: number
    resource: string
    key: enum_Permissions_key
    resourceId: number
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type PermissionsCreateOrConnectWithoutAccountsInput = {
    where: PermissionsWhereUniqueInput
    create: XOR<PermissionsCreateWithoutAccountsInput, PermissionsUncheckedCreateWithoutAccountsInput>
  }

  export type PermissionsCreateManyAccountsInputEnvelope = {
    data: Enumerable<PermissionsCreateManyAccountsInput>
    skipDuplicates?: boolean
  }

  export type PostAccountsCreateWithoutAccountsInput = {
    type?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    Posts?: PostsCreateNestedOneWithoutPostAccountsInput
  }

  export type PostAccountsUncheckedCreateWithoutAccountsInput = {
    id?: number
    PostId?: number | null
    type?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type PostAccountsCreateOrConnectWithoutAccountsInput = {
    where: PostAccountsWhereUniqueInput
    create: XOR<PostAccountsCreateWithoutAccountsInput, PostAccountsUncheckedCreateWithoutAccountsInput>
  }

  export type PostAccountsCreateManyAccountsInputEnvelope = {
    data: Enumerable<PostAccountsCreateManyAccountsInput>
    skipDuplicates?: boolean
  }

  export type PostsCreateWithoutAccountsInput = {
    category?: string | null
    type?: PostsCreatetypeInput | Enumerable<string>
    content?: string | null
    unit?: string | null
    price?: number | null
    location?: PostsCreatelocationInput | Enumerable<string>
    area?: Decimal | DecimalJsLike | number | string | null
    title?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: string | null
    viewCount?: number | null
    contactName?: string | null
    contactPhone?: string | null
    contactEmail?: string | null
    qualifications?: PostsCreatequalificationsInput | Enumerable<string>
    PostAccounts?: PostAccountsCreateNestedManyWithoutPostsInput
  }

  export type PostsUncheckedCreateWithoutAccountsInput = {
    id?: number
    category?: string | null
    type?: PostsCreatetypeInput | Enumerable<string>
    content?: string | null
    unit?: string | null
    price?: number | null
    location?: PostsCreatelocationInput | Enumerable<string>
    area?: Decimal | DecimalJsLike | number | string | null
    title?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: string | null
    viewCount?: number | null
    contactName?: string | null
    contactPhone?: string | null
    contactEmail?: string | null
    qualifications?: PostsCreatequalificationsInput | Enumerable<string>
    PostAccounts?: PostAccountsUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostsCreateOrConnectWithoutAccountsInput = {
    where: PostsWhereUniqueInput
    create: XOR<PostsCreateWithoutAccountsInput, PostsUncheckedCreateWithoutAccountsInput>
  }

  export type PostsCreateManyAccountsInputEnvelope = {
    data: Enumerable<PostsCreateManyAccountsInput>
    skipDuplicates?: boolean
  }

  export type ReportsCreateWithoutAccountsInput = {
    name?: string | null
    isActive?: boolean | null
    isPrivate?: boolean | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    Tasks?: TasksCreateNestedOneWithoutReportsInput
  }

  export type ReportsUncheckedCreateWithoutAccountsInput = {
    id?: number
    name?: string | null
    isActive?: boolean | null
    isPrivate?: boolean | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    TaskId?: number | null
  }

  export type ReportsCreateOrConnectWithoutAccountsInput = {
    where: ReportsWhereUniqueInput
    create: XOR<ReportsCreateWithoutAccountsInput, ReportsUncheckedCreateWithoutAccountsInput>
  }

  export type ReportsCreateManyAccountsInputEnvelope = {
    data: Enumerable<ReportsCreateManyAccountsInput>
    skipDuplicates?: boolean
  }

  export type StatisticsCreateWithoutAccountsInput = {
    dailyWorkload?: Decimal | DecimalJsLike | number | string | null
    completedByOwner?: Decimal | DecimalJsLike | number | string | null
    completedBySelf?: Decimal | DecimalJsLike | number | string | null
    createdAt: Date | string
    updatedAt: Date | string
    Tasks?: TasksCreateNestedOneWithoutStatisticsInput
    Teams?: TeamsCreateNestedOneWithoutStatisticsInput
  }

  export type StatisticsUncheckedCreateWithoutAccountsInput = {
    id?: number
    TeamId?: number | null
    TaskId?: number | null
    dailyWorkload?: Decimal | DecimalJsLike | number | string | null
    completedByOwner?: Decimal | DecimalJsLike | number | string | null
    completedBySelf?: Decimal | DecimalJsLike | number | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type StatisticsCreateOrConnectWithoutAccountsInput = {
    where: StatisticsWhereUniqueInput
    create: XOR<StatisticsCreateWithoutAccountsInput, StatisticsUncheckedCreateWithoutAccountsInput>
  }

  export type StatisticsCreateManyAccountsInputEnvelope = {
    data: Enumerable<StatisticsCreateManyAccountsInput>
    skipDuplicates?: boolean
  }

  export type SubscribesCreateWithoutAccountsInput = {
    fcmToken: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type SubscribesUncheckedCreateWithoutAccountsInput = {
    id?: number
    fcmToken: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type SubscribesCreateOrConnectWithoutAccountsInput = {
    where: SubscribesWhereUniqueInput
    create: XOR<SubscribesCreateWithoutAccountsInput, SubscribesUncheckedCreateWithoutAccountsInput>
  }

  export type SubscribesCreateManyAccountsInputEnvelope = {
    data: Enumerable<SubscribesCreateManyAccountsInput>
    skipDuplicates?: boolean
  }

  export type TaskDetailResourcesCreateWithoutAccountsInput = {
    content?: string | null
    type?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    group?: string | null
    TaskDetails?: TaskDetailsCreateNestedOneWithoutTaskDetailResourcesInput
  }

  export type TaskDetailResourcesUncheckedCreateWithoutAccountsInput = {
    id?: number
    content?: string | null
    type?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    TaskDetailId?: number | null
    group?: string | null
  }

  export type TaskDetailResourcesCreateOrConnectWithoutAccountsInput = {
    where: TaskDetailResourcesWhereUniqueInput
    create: XOR<TaskDetailResourcesCreateWithoutAccountsInput, TaskDetailResourcesUncheckedCreateWithoutAccountsInput>
  }

  export type TaskDetailResourcesCreateManyAccountsInputEnvelope = {
    data: Enumerable<TaskDetailResourcesCreateManyAccountsInput>
    skipDuplicates?: boolean
  }

  export type TaskDetailsCreateWithoutAccountsInput = {
    type?: string | null
    address?: string | null
    villageName?: string | null
    pushUser?: string | null
    category?: string | null
    etc?: string | null
    status?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    assignedDays?: number | null
    assignedUser?: string | null
    y?: string | null
    x?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    pushPhone?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    memo?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    Tasks?: TasksCreateNestedOneWithoutTaskDetailsInput
    Teams?: TeamsCreateNestedOneWithoutTaskDetailsInput
    TaskDetailResources?: TaskDetailResourcesCreateNestedManyWithoutTaskDetailsInput
  }

  export type TaskDetailsUncheckedCreateWithoutAccountsInput = {
    id?: number
    TaskId?: number | null
    type?: string | null
    address?: string | null
    villageName?: string | null
    pushUser?: string | null
    category?: string | null
    etc?: string | null
    status?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    assignedDays?: number | null
    assignedUser?: string | null
    TeamId?: number | null
    y?: string | null
    x?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    pushPhone?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    memo?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    TaskDetailResources?: TaskDetailResourcesUncheckedCreateNestedManyWithoutTaskDetailsInput
  }

  export type TaskDetailsCreateOrConnectWithoutAccountsInput = {
    where: TaskDetailsWhereUniqueInput
    create: XOR<TaskDetailsCreateWithoutAccountsInput, TaskDetailsUncheckedCreateWithoutAccountsInput>
  }

  export type TaskDetailsCreateManyAccountsInputEnvelope = {
    data: Enumerable<TaskDetailsCreateManyAccountsInput>
    skipDuplicates?: boolean
  }

  export type TaskGroupsCreateWithoutAccountsInput = {
    path?: string | null
    name?: string | null
    status?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    area?: Decimal | DecimalJsLike | number | string | null
    createType?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    Tasks?: TasksCreateNestedManyWithoutTaskGroupsInput
  }

  export type TaskGroupsUncheckedCreateWithoutAccountsInput = {
    id?: number
    path?: string | null
    name?: string | null
    status?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    area?: Decimal | DecimalJsLike | number | string | null
    createType?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    Tasks?: TasksUncheckedCreateNestedManyWithoutTaskGroupsInput
  }

  export type TaskGroupsCreateOrConnectWithoutAccountsInput = {
    where: TaskGroupsWhereUniqueInput
    create: XOR<TaskGroupsCreateWithoutAccountsInput, TaskGroupsUncheckedCreateWithoutAccountsInput>
  }

  export type TaskGroupsCreateManyAccountsInputEnvelope = {
    data: Enumerable<TaskGroupsCreateManyAccountsInput>
    skipDuplicates?: boolean
  }

  export type TasksCreateWithoutAccountsInput = {
    name?: string | null
    status?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    workingDays?: number | null
    workingTeamsCnt?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    area?: Decimal | DecimalJsLike | number | string | null
    isPaid?: boolean | null
    createType?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: Decimal | DecimalJsLike | number | string | null
    TaskGroups?: TaskGroupsCreateNestedOneWithoutTasksInput
    Reports?: ReportsCreateNestedManyWithoutTasksInput
    Statistics?: StatisticsCreateNestedManyWithoutTasksInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutTasksInput
    Teams?: TeamsCreateNestedManyWithoutTasksInput
  }

  export type TasksUncheckedCreateWithoutAccountsInput = {
    id?: number
    name?: string | null
    status?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    workingDays?: number | null
    workingTeamsCnt?: number | null
    TaskGroupId?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    area?: Decimal | DecimalJsLike | number | string | null
    isPaid?: boolean | null
    createType?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: Decimal | DecimalJsLike | number | string | null
    Reports?: ReportsUncheckedCreateNestedManyWithoutTasksInput
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutTasksInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutTasksInput
    Teams?: TeamsUncheckedCreateNestedManyWithoutTasksInput
  }

  export type TasksCreateOrConnectWithoutAccountsInput = {
    where: TasksWhereUniqueInput
    create: XOR<TasksCreateWithoutAccountsInput, TasksUncheckedCreateWithoutAccountsInput>
  }

  export type TasksCreateManyAccountsInputEnvelope = {
    data: Enumerable<TasksCreateManyAccountsInput>
    skipDuplicates?: boolean
  }

  export type TeamAgentsCreateWithoutAccountsInput = {
    isActive?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    Teams: TeamsCreateNestedOneWithoutTeamAgentsInput
  }

  export type TeamAgentsUncheckedCreateWithoutAccountsInput = {
    TeamId: number
    isActive?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TeamAgentsCreateOrConnectWithoutAccountsInput = {
    where: TeamAgentsWhereUniqueInput
    create: XOR<TeamAgentsCreateWithoutAccountsInput, TeamAgentsUncheckedCreateWithoutAccountsInput>
  }

  export type TeamAgentsCreateManyAccountsInputEnvelope = {
    data: Enumerable<TeamAgentsCreateManyAccountsInput>
    skipDuplicates?: boolean
  }

  export type TeamsCreateWithoutAccounts_AccountsToTeams_AccountIdInput = {
    name?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    status?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    alias?: string | null
    Accounts_AccountsToTeams_AgentId?: AccountsCreateNestedOneWithoutTeams_AccountsToTeams_AgentIdInput
    Tasks?: TasksCreateNestedOneWithoutTeamsInput
    Statistics?: StatisticsCreateNestedManyWithoutTeamsInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutTeamsInput
    TeamAgents?: TeamAgentsCreateNestedManyWithoutTeamsInput
  }

  export type TeamsUncheckedCreateWithoutAccounts_AccountsToTeams_AccountIdInput = {
    id?: number
    name?: string | null
    AgentId?: number | null
    TaskId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    status?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    alias?: string | null
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutTeamsInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutTeamsInput
    TeamAgents?: TeamAgentsUncheckedCreateNestedManyWithoutTeamsInput
  }

  export type TeamsCreateOrConnectWithoutAccounts_AccountsToTeams_AccountIdInput = {
    where: TeamsWhereUniqueInput
    create: XOR<TeamsCreateWithoutAccounts_AccountsToTeams_AccountIdInput, TeamsUncheckedCreateWithoutAccounts_AccountsToTeams_AccountIdInput>
  }

  export type TeamsCreateManyAccounts_AccountsToTeams_AccountIdInputEnvelope = {
    data: Enumerable<TeamsCreateManyAccounts_AccountsToTeams_AccountIdInput>
    skipDuplicates?: boolean
  }

  export type TeamsCreateWithoutAccounts_AccountsToTeams_AgentIdInput = {
    name?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    status?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    alias?: string | null
    Accounts_AccountsToTeams_AccountId?: AccountsCreateNestedOneWithoutTeams_AccountsToTeams_AccountIdInput
    Tasks?: TasksCreateNestedOneWithoutTeamsInput
    Statistics?: StatisticsCreateNestedManyWithoutTeamsInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutTeamsInput
    TeamAgents?: TeamAgentsCreateNestedManyWithoutTeamsInput
  }

  export type TeamsUncheckedCreateWithoutAccounts_AccountsToTeams_AgentIdInput = {
    id?: number
    name?: string | null
    AccountId?: number | null
    TaskId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    status?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    alias?: string | null
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutTeamsInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutTeamsInput
    TeamAgents?: TeamAgentsUncheckedCreateNestedManyWithoutTeamsInput
  }

  export type TeamsCreateOrConnectWithoutAccounts_AccountsToTeams_AgentIdInput = {
    where: TeamsWhereUniqueInput
    create: XOR<TeamsCreateWithoutAccounts_AccountsToTeams_AgentIdInput, TeamsUncheckedCreateWithoutAccounts_AccountsToTeams_AgentIdInput>
  }

  export type TeamsCreateManyAccounts_AccountsToTeams_AgentIdInputEnvelope = {
    data: Enumerable<TeamsCreateManyAccounts_AccountsToTeams_AgentIdInput>
    skipDuplicates?: boolean
  }

  export type ServicesUpsertWithoutAccountsInput = {
    update: XOR<ServicesUpdateWithoutAccountsInput, ServicesUncheckedUpdateWithoutAccountsInput>
    create: XOR<ServicesCreateWithoutAccountsInput, ServicesUncheckedCreateWithoutAccountsInput>
  }

  export type ServicesUpdateWithoutAccountsInput = {
    key?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesUncheckedUpdateWithoutAccountsInput = {
    key?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertsUpsertWithWhereUniqueWithoutAccountsInput = {
    where: AlertsWhereUniqueInput
    update: XOR<AlertsUpdateWithoutAccountsInput, AlertsUncheckedUpdateWithoutAccountsInput>
    create: XOR<AlertsCreateWithoutAccountsInput, AlertsUncheckedCreateWithoutAccountsInput>
  }

  export type AlertsUpdateWithWhereUniqueWithoutAccountsInput = {
    where: AlertsWhereUniqueInput
    data: XOR<AlertsUpdateWithoutAccountsInput, AlertsUncheckedUpdateWithoutAccountsInput>
  }

  export type AlertsUpdateManyWithWhereWithoutAccountsInput = {
    where: AlertsScalarWhereInput
    data: XOR<AlertsUpdateManyMutationInput, AlertsUncheckedUpdateManyWithoutAlertsInput>
  }

  export type AlertsScalarWhereInput = {
    AND?: Enumerable<AlertsScalarWhereInput>
    OR?: Enumerable<AlertsScalarWhereInput>
    NOT?: Enumerable<AlertsScalarWhereInput>
    id?: BigIntFilter | bigint | number
    title?: StringNullableFilter | string | null
    type?: StringFilter | string
    category?: StringFilter | string
    AccountId?: IntNullableFilter | number | null
    ReferenceId?: IntFilter | number
    isRead?: BoolNullableFilter | boolean | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    data?: JsonNullableFilter
  }

  export type CareersUpsertWithWhereUniqueWithoutAccountsInput = {
    where: CareersWhereUniqueInput
    update: XOR<CareersUpdateWithoutAccountsInput, CareersUncheckedUpdateWithoutAccountsInput>
    create: XOR<CareersCreateWithoutAccountsInput, CareersUncheckedCreateWithoutAccountsInput>
  }

  export type CareersUpdateWithWhereUniqueWithoutAccountsInput = {
    where: CareersWhereUniqueInput
    data: XOR<CareersUpdateWithoutAccountsInput, CareersUncheckedUpdateWithoutAccountsInput>
  }

  export type CareersUpdateManyWithWhereWithoutAccountsInput = {
    where: CareersScalarWhereInput
    data: XOR<CareersUpdateManyMutationInput, CareersUncheckedUpdateManyWithoutCareersInput>
  }

  export type CareersScalarWhereInput = {
    AND?: Enumerable<CareersScalarWhereInput>
    OR?: Enumerable<CareersScalarWhereInput>
    NOT?: Enumerable<CareersScalarWhereInput>
    id?: IntFilter | number
    AccountId?: IntNullableFilter | number | null
    title?: StringNullableFilter | string | null
    startDate?: DateTimeNullableFilter | Date | string | null
    endDate?: DateTimeNullableFilter | Date | string | null
    content?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CustomerTaskDetailsUpsertWithWhereUniqueWithoutAccountsInput = {
    where: CustomerTaskDetailsWhereUniqueInput
    update: XOR<CustomerTaskDetailsUpdateWithoutAccountsInput, CustomerTaskDetailsUncheckedUpdateWithoutAccountsInput>
    create: XOR<CustomerTaskDetailsCreateWithoutAccountsInput, CustomerTaskDetailsUncheckedCreateWithoutAccountsInput>
  }

  export type CustomerTaskDetailsUpdateWithWhereUniqueWithoutAccountsInput = {
    where: CustomerTaskDetailsWhereUniqueInput
    data: XOR<CustomerTaskDetailsUpdateWithoutAccountsInput, CustomerTaskDetailsUncheckedUpdateWithoutAccountsInput>
  }

  export type CustomerTaskDetailsUpdateManyWithWhereWithoutAccountsInput = {
    where: CustomerTaskDetailsScalarWhereInput
    data: XOR<CustomerTaskDetailsUpdateManyMutationInput, CustomerTaskDetailsUncheckedUpdateManyWithoutCustomerTaskDetailsInput>
  }

  export type CustomerTaskDetailsScalarWhereInput = {
    AND?: Enumerable<CustomerTaskDetailsScalarWhereInput>
    OR?: Enumerable<CustomerTaskDetailsScalarWhereInput>
    NOT?: Enumerable<CustomerTaskDetailsScalarWhereInput>
    id?: IntFilter | number
    AccountId?: IntNullableFilter | number | null
    CustomerId?: IntNullableFilter | number | null
    type?: StringNullableFilter | string | null
    address?: StringNullableFilter | string | null
    villageName?: StringNullableFilter | string | null
    category?: StringNullableFilter | string | null
    etc?: StringNullableFilter | string | null
    geometry?: JsonNullableFilter
    x?: StringNullableFilter | string | null
    y?: StringNullableFilter | string | null
    area?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CustomersUpsertWithWhereUniqueWithoutAccountsInput = {
    where: CustomersWhereUniqueInput
    update: XOR<CustomersUpdateWithoutAccountsInput, CustomersUncheckedUpdateWithoutAccountsInput>
    create: XOR<CustomersCreateWithoutAccountsInput, CustomersUncheckedCreateWithoutAccountsInput>
  }

  export type CustomersUpdateWithWhereUniqueWithoutAccountsInput = {
    where: CustomersWhereUniqueInput
    data: XOR<CustomersUpdateWithoutAccountsInput, CustomersUncheckedUpdateWithoutAccountsInput>
  }

  export type CustomersUpdateManyWithWhereWithoutAccountsInput = {
    where: CustomersScalarWhereInput
    data: XOR<CustomersUpdateManyMutationInput, CustomersUncheckedUpdateManyWithoutCustomersInput>
  }

  export type CustomersScalarWhereInput = {
    AND?: Enumerable<CustomersScalarWhereInput>
    OR?: Enumerable<CustomersScalarWhereInput>
    NOT?: Enumerable<CustomersScalarWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    crops?: StringNullableListFilter
    AccountId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type DiscountsUpsertWithWhereUniqueWithoutAccountsInput = {
    where: DiscountsWhereUniqueInput
    update: XOR<DiscountsUpdateWithoutAccountsInput, DiscountsUncheckedUpdateWithoutAccountsInput>
    create: XOR<DiscountsCreateWithoutAccountsInput, DiscountsUncheckedCreateWithoutAccountsInput>
  }

  export type DiscountsUpdateWithWhereUniqueWithoutAccountsInput = {
    where: DiscountsWhereUniqueInput
    data: XOR<DiscountsUpdateWithoutAccountsInput, DiscountsUncheckedUpdateWithoutAccountsInput>
  }

  export type DiscountsUpdateManyWithWhereWithoutAccountsInput = {
    where: DiscountsScalarWhereInput
    data: XOR<DiscountsUpdateManyMutationInput, DiscountsUncheckedUpdateManyWithoutDiscountsInput>
  }

  export type DiscountsScalarWhereInput = {
    AND?: Enumerable<DiscountsScalarWhereInput>
    OR?: Enumerable<DiscountsScalarWhereInput>
    NOT?: Enumerable<DiscountsScalarWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    price?: FloatNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    AccountId?: IntNullableFilter | number | null
    OrderId?: IntNullableFilter | number | null
    CouponId?: IntNullableFilter | number | null
    ProductId?: IntNullableFilter | number | null
    filters?: JsonNullableFilter
  }

  export type LandsUpsertWithWhereUniqueWithoutAccountsInput = {
    where: LandsWhereUniqueInput
    update: XOR<LandsUpdateWithoutAccountsInput, LandsUncheckedUpdateWithoutAccountsInput>
    create: XOR<LandsCreateWithoutAccountsInput, LandsUncheckedCreateWithoutAccountsInput>
  }

  export type LandsUpdateWithWhereUniqueWithoutAccountsInput = {
    where: LandsWhereUniqueInput
    data: XOR<LandsUpdateWithoutAccountsInput, LandsUncheckedUpdateWithoutAccountsInput>
  }

  export type LandsUpdateManyWithWhereWithoutAccountsInput = {
    where: LandsScalarWhereInput
    data: XOR<LandsUpdateManyMutationInput, LandsUncheckedUpdateManyWithoutLandsInput>
  }

  export type LandsScalarWhereInput = {
    AND?: Enumerable<LandsScalarWhereInput>
    OR?: Enumerable<LandsScalarWhereInput>
    NOT?: Enumerable<LandsScalarWhereInput>
    id?: BigIntFilter | bigint | number
    AccountId?: IntFilter | number
    is_active?: BoolNullableFilter | boolean | null
    type?: StringNullableFilter | string | null
    villageName?: StringNullableFilter | string | null
    status?: StringNullableFilter | string | null
    geometry?: JsonNullableFilter
    x?: StringNullableFilter | string | null
    y?: StringNullableFilter | string | null
    area?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    extra?: JsonNullableFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type NotificationsUpsertWithWhereUniqueWithoutAccountsInput = {
    where: NotificationsWhereUniqueInput
    update: XOR<NotificationsUpdateWithoutAccountsInput, NotificationsUncheckedUpdateWithoutAccountsInput>
    create: XOR<NotificationsCreateWithoutAccountsInput, NotificationsUncheckedCreateWithoutAccountsInput>
  }

  export type NotificationsUpdateWithWhereUniqueWithoutAccountsInput = {
    where: NotificationsWhereUniqueInput
    data: XOR<NotificationsUpdateWithoutAccountsInput, NotificationsUncheckedUpdateWithoutAccountsInput>
  }

  export type NotificationsUpdateManyWithWhereWithoutAccountsInput = {
    where: NotificationsScalarWhereInput
    data: XOR<NotificationsUpdateManyMutationInput, NotificationsUncheckedUpdateManyWithoutNotificationsInput>
  }

  export type NotificationsScalarWhereInput = {
    AND?: Enumerable<NotificationsScalarWhereInput>
    OR?: Enumerable<NotificationsScalarWhereInput>
    NOT?: Enumerable<NotificationsScalarWhereInput>
    id?: BigIntFilter | bigint | number
    AccountId?: IntFilter | number
    fcmToken?: StringFilter | string
    sendedAt?: DateTimeNullableFilter | Date | string | null
    isSuccess?: BoolNullableFilter | boolean | null
    failReason?: StringNullableFilter | string | null
    eventCode?: StringFilter | string
    sendCode?: StringFilter | string
    reservationCode?: StringFilter | string
    sendCycleCode?: StringFilter | string
    title?: StringFilter | string
    message?: StringFilter | string
    image?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type OrderHistoriesUpsertWithWhereUniqueWithoutAccountsInput = {
    where: OrderHistoriesWhereUniqueInput
    update: XOR<OrderHistoriesUpdateWithoutAccountsInput, OrderHistoriesUncheckedUpdateWithoutAccountsInput>
    create: XOR<OrderHistoriesCreateWithoutAccountsInput, OrderHistoriesUncheckedCreateWithoutAccountsInput>
  }

  export type OrderHistoriesUpdateWithWhereUniqueWithoutAccountsInput = {
    where: OrderHistoriesWhereUniqueInput
    data: XOR<OrderHistoriesUpdateWithoutAccountsInput, OrderHistoriesUncheckedUpdateWithoutAccountsInput>
  }

  export type OrderHistoriesUpdateManyWithWhereWithoutAccountsInput = {
    where: OrderHistoriesScalarWhereInput
    data: XOR<OrderHistoriesUpdateManyMutationInput, OrderHistoriesUncheckedUpdateManyWithoutOrderHistoriesInput>
  }

  export type OrderHistoriesScalarWhereInput = {
    AND?: Enumerable<OrderHistoriesScalarWhereInput>
    OR?: Enumerable<OrderHistoriesScalarWhereInput>
    NOT?: Enumerable<OrderHistoriesScalarWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    payment?: StringNullableFilter | string | null
    paymentMethod?: StringNullableFilter | string | null
    externalUid?: StringNullableFilter | string | null
    customerUid?: StringNullableFilter | string | null
    merchantUid?: StringNullableFilter | string | null
    reqAmount?: IntNullableFilter | number | null
    paidAmount?: IntNullableFilter | number | null
    status?: StringNullableFilter | string | null
    extra?: JsonNullableFilter
    AccountId?: IntNullableFilter | number | null
    ProductId?: IntNullableFilter | number | null
    OrderId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type OrdersUpsertWithWhereUniqueWithoutAccountsInput = {
    where: OrdersWhereUniqueInput
    update: XOR<OrdersUpdateWithoutAccountsInput, OrdersUncheckedUpdateWithoutAccountsInput>
    create: XOR<OrdersCreateWithoutAccountsInput, OrdersUncheckedCreateWithoutAccountsInput>
  }

  export type OrdersUpdateWithWhereUniqueWithoutAccountsInput = {
    where: OrdersWhereUniqueInput
    data: XOR<OrdersUpdateWithoutAccountsInput, OrdersUncheckedUpdateWithoutAccountsInput>
  }

  export type OrdersUpdateManyWithWhereWithoutAccountsInput = {
    where: OrdersScalarWhereInput
    data: XOR<OrdersUpdateManyMutationInput, OrdersUncheckedUpdateManyWithoutOrdersInput>
  }

  export type OrdersScalarWhereInput = {
    AND?: Enumerable<OrdersScalarWhereInput>
    OR?: Enumerable<OrdersScalarWhereInput>
    NOT?: Enumerable<OrdersScalarWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    payment?: StringNullableFilter | string | null
    paymentMethod?: StringNullableFilter | string | null
    externalUid?: StringNullableFilter | string | null
    customerUid?: StringNullableFilter | string | null
    merchantUid?: StringNullableFilter | string | null
    reqAmount?: IntNullableFilter | number | null
    paidAmount?: IntNullableFilter | number | null
    status?: StringNullableFilter | string | null
    extra?: JsonNullableFilter
    AccountId?: IntNullableFilter | number | null
    ProductId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    expiredAt?: DateTimeNullableFilter | Date | string | null
    isSubscribe?: BoolNullableFilter | boolean | null
    issuedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type PermissionsUpsertWithWhereUniqueWithoutAccountsInput = {
    where: PermissionsWhereUniqueInput
    update: XOR<PermissionsUpdateWithoutAccountsInput, PermissionsUncheckedUpdateWithoutAccountsInput>
    create: XOR<PermissionsCreateWithoutAccountsInput, PermissionsUncheckedCreateWithoutAccountsInput>
  }

  export type PermissionsUpdateWithWhereUniqueWithoutAccountsInput = {
    where: PermissionsWhereUniqueInput
    data: XOR<PermissionsUpdateWithoutAccountsInput, PermissionsUncheckedUpdateWithoutAccountsInput>
  }

  export type PermissionsUpdateManyWithWhereWithoutAccountsInput = {
    where: PermissionsScalarWhereInput
    data: XOR<PermissionsUpdateManyMutationInput, PermissionsUncheckedUpdateManyWithoutPermissionsInput>
  }

  export type PermissionsScalarWhereInput = {
    AND?: Enumerable<PermissionsScalarWhereInput>
    OR?: Enumerable<PermissionsScalarWhereInput>
    NOT?: Enumerable<PermissionsScalarWhereInput>
    id?: IntFilter | number
    resource?: StringFilter | string
    key?: Enumenum_Permissions_keyFilter | enum_Permissions_key
    resourceId?: IntFilter | number
    AccountId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PostAccountsUpsertWithWhereUniqueWithoutAccountsInput = {
    where: PostAccountsWhereUniqueInput
    update: XOR<PostAccountsUpdateWithoutAccountsInput, PostAccountsUncheckedUpdateWithoutAccountsInput>
    create: XOR<PostAccountsCreateWithoutAccountsInput, PostAccountsUncheckedCreateWithoutAccountsInput>
  }

  export type PostAccountsUpdateWithWhereUniqueWithoutAccountsInput = {
    where: PostAccountsWhereUniqueInput
    data: XOR<PostAccountsUpdateWithoutAccountsInput, PostAccountsUncheckedUpdateWithoutAccountsInput>
  }

  export type PostAccountsUpdateManyWithWhereWithoutAccountsInput = {
    where: PostAccountsScalarWhereInput
    data: XOR<PostAccountsUpdateManyMutationInput, PostAccountsUncheckedUpdateManyWithoutPostAccountsInput>
  }

  export type PostAccountsScalarWhereInput = {
    AND?: Enumerable<PostAccountsScalarWhereInput>
    OR?: Enumerable<PostAccountsScalarWhereInput>
    NOT?: Enumerable<PostAccountsScalarWhereInput>
    id?: IntFilter | number
    AccountId?: IntNullableFilter | number | null
    PostId?: IntNullableFilter | number | null
    type?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PostsUpsertWithWhereUniqueWithoutAccountsInput = {
    where: PostsWhereUniqueInput
    update: XOR<PostsUpdateWithoutAccountsInput, PostsUncheckedUpdateWithoutAccountsInput>
    create: XOR<PostsCreateWithoutAccountsInput, PostsUncheckedCreateWithoutAccountsInput>
  }

  export type PostsUpdateWithWhereUniqueWithoutAccountsInput = {
    where: PostsWhereUniqueInput
    data: XOR<PostsUpdateWithoutAccountsInput, PostsUncheckedUpdateWithoutAccountsInput>
  }

  export type PostsUpdateManyWithWhereWithoutAccountsInput = {
    where: PostsScalarWhereInput
    data: XOR<PostsUpdateManyMutationInput, PostsUncheckedUpdateManyWithoutPostsInput>
  }

  export type PostsScalarWhereInput = {
    AND?: Enumerable<PostsScalarWhereInput>
    OR?: Enumerable<PostsScalarWhereInput>
    NOT?: Enumerable<PostsScalarWhereInput>
    id?: IntFilter | number
    category?: StringNullableFilter | string | null
    type?: StringNullableListFilter
    content?: StringNullableFilter | string | null
    unit?: StringNullableFilter | string | null
    price?: IntNullableFilter | number | null
    location?: StringNullableListFilter
    area?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    title?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    startDate?: DateTimeNullableFilter | Date | string | null
    endDate?: DateTimeNullableFilter | Date | string | null
    status?: StringNullableFilter | string | null
    viewCount?: IntNullableFilter | number | null
    AccountId?: IntNullableFilter | number | null
    contactName?: StringNullableFilter | string | null
    contactPhone?: StringNullableFilter | string | null
    contactEmail?: StringNullableFilter | string | null
    qualifications?: StringNullableListFilter
  }

  export type ReportsUpsertWithWhereUniqueWithoutAccountsInput = {
    where: ReportsWhereUniqueInput
    update: XOR<ReportsUpdateWithoutAccountsInput, ReportsUncheckedUpdateWithoutAccountsInput>
    create: XOR<ReportsCreateWithoutAccountsInput, ReportsUncheckedCreateWithoutAccountsInput>
  }

  export type ReportsUpdateWithWhereUniqueWithoutAccountsInput = {
    where: ReportsWhereUniqueInput
    data: XOR<ReportsUpdateWithoutAccountsInput, ReportsUncheckedUpdateWithoutAccountsInput>
  }

  export type ReportsUpdateManyWithWhereWithoutAccountsInput = {
    where: ReportsScalarWhereInput
    data: XOR<ReportsUpdateManyMutationInput, ReportsUncheckedUpdateManyWithoutReportsInput>
  }

  export type ReportsScalarWhereInput = {
    AND?: Enumerable<ReportsScalarWhereInput>
    OR?: Enumerable<ReportsScalarWhereInput>
    NOT?: Enumerable<ReportsScalarWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    isActive?: BoolNullableFilter | boolean | null
    isPrivate?: BoolNullableFilter | boolean | null
    password?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    TaskId?: IntNullableFilter | number | null
    AccountId?: IntNullableFilter | number | null
  }

  export type StatisticsUpsertWithWhereUniqueWithoutAccountsInput = {
    where: StatisticsWhereUniqueInput
    update: XOR<StatisticsUpdateWithoutAccountsInput, StatisticsUncheckedUpdateWithoutAccountsInput>
    create: XOR<StatisticsCreateWithoutAccountsInput, StatisticsUncheckedCreateWithoutAccountsInput>
  }

  export type StatisticsUpdateWithWhereUniqueWithoutAccountsInput = {
    where: StatisticsWhereUniqueInput
    data: XOR<StatisticsUpdateWithoutAccountsInput, StatisticsUncheckedUpdateWithoutAccountsInput>
  }

  export type StatisticsUpdateManyWithWhereWithoutAccountsInput = {
    where: StatisticsScalarWhereInput
    data: XOR<StatisticsUpdateManyMutationInput, StatisticsUncheckedUpdateManyWithoutStatisticsInput>
  }

  export type StatisticsScalarWhereInput = {
    AND?: Enumerable<StatisticsScalarWhereInput>
    OR?: Enumerable<StatisticsScalarWhereInput>
    NOT?: Enumerable<StatisticsScalarWhereInput>
    id?: IntFilter | number
    AgentId?: IntNullableFilter | number | null
    TeamId?: IntNullableFilter | number | null
    TaskId?: IntNullableFilter | number | null
    dailyWorkload?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    completedByOwner?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    completedBySelf?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SubscribesUpsertWithWhereUniqueWithoutAccountsInput = {
    where: SubscribesWhereUniqueInput
    update: XOR<SubscribesUpdateWithoutAccountsInput, SubscribesUncheckedUpdateWithoutAccountsInput>
    create: XOR<SubscribesCreateWithoutAccountsInput, SubscribesUncheckedCreateWithoutAccountsInput>
  }

  export type SubscribesUpdateWithWhereUniqueWithoutAccountsInput = {
    where: SubscribesWhereUniqueInput
    data: XOR<SubscribesUpdateWithoutAccountsInput, SubscribesUncheckedUpdateWithoutAccountsInput>
  }

  export type SubscribesUpdateManyWithWhereWithoutAccountsInput = {
    where: SubscribesScalarWhereInput
    data: XOR<SubscribesUpdateManyMutationInput, SubscribesUncheckedUpdateManyWithoutSubscribesInput>
  }

  export type SubscribesScalarWhereInput = {
    AND?: Enumerable<SubscribesScalarWhereInput>
    OR?: Enumerable<SubscribesScalarWhereInput>
    NOT?: Enumerable<SubscribesScalarWhereInput>
    id?: IntFilter | number
    AccountId?: IntFilter | number
    fcmToken?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TaskDetailResourcesUpsertWithWhereUniqueWithoutAccountsInput = {
    where: TaskDetailResourcesWhereUniqueInput
    update: XOR<TaskDetailResourcesUpdateWithoutAccountsInput, TaskDetailResourcesUncheckedUpdateWithoutAccountsInput>
    create: XOR<TaskDetailResourcesCreateWithoutAccountsInput, TaskDetailResourcesUncheckedCreateWithoutAccountsInput>
  }

  export type TaskDetailResourcesUpdateWithWhereUniqueWithoutAccountsInput = {
    where: TaskDetailResourcesWhereUniqueInput
    data: XOR<TaskDetailResourcesUpdateWithoutAccountsInput, TaskDetailResourcesUncheckedUpdateWithoutAccountsInput>
  }

  export type TaskDetailResourcesUpdateManyWithWhereWithoutAccountsInput = {
    where: TaskDetailResourcesScalarWhereInput
    data: XOR<TaskDetailResourcesUpdateManyMutationInput, TaskDetailResourcesUncheckedUpdateManyWithoutTaskDetailResourcesInput>
  }

  export type TaskDetailResourcesScalarWhereInput = {
    AND?: Enumerable<TaskDetailResourcesScalarWhereInput>
    OR?: Enumerable<TaskDetailResourcesScalarWhereInput>
    NOT?: Enumerable<TaskDetailResourcesScalarWhereInput>
    id?: IntFilter | number
    content?: StringNullableFilter | string | null
    type?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    TaskDetailId?: IntNullableFilter | number | null
    AccountId?: IntNullableFilter | number | null
    group?: StringNullableFilter | string | null
  }

  export type TaskDetailsUpsertWithWhereUniqueWithoutAccountsInput = {
    where: TaskDetailsWhereUniqueInput
    update: XOR<TaskDetailsUpdateWithoutAccountsInput, TaskDetailsUncheckedUpdateWithoutAccountsInput>
    create: XOR<TaskDetailsCreateWithoutAccountsInput, TaskDetailsUncheckedCreateWithoutAccountsInput>
  }

  export type TaskDetailsUpdateWithWhereUniqueWithoutAccountsInput = {
    where: TaskDetailsWhereUniqueInput
    data: XOR<TaskDetailsUpdateWithoutAccountsInput, TaskDetailsUncheckedUpdateWithoutAccountsInput>
  }

  export type TaskDetailsUpdateManyWithWhereWithoutAccountsInput = {
    where: TaskDetailsScalarWhereInput
    data: XOR<TaskDetailsUpdateManyMutationInput, TaskDetailsUncheckedUpdateManyWithoutTaskDetailsInput>
  }

  export type TaskDetailsScalarWhereInput = {
    AND?: Enumerable<TaskDetailsScalarWhereInput>
    OR?: Enumerable<TaskDetailsScalarWhereInput>
    NOT?: Enumerable<TaskDetailsScalarWhereInput>
    id?: IntFilter | number
    AccountId?: IntNullableFilter | number | null
    TaskId?: IntNullableFilter | number | null
    type?: StringNullableFilter | string | null
    address?: StringNullableFilter | string | null
    villageName?: StringNullableFilter | string | null
    pushUser?: StringNullableFilter | string | null
    category?: StringNullableFilter | string | null
    etc?: StringNullableFilter | string | null
    status?: StringNullableFilter | string | null
    geometry?: JsonNullableFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    assignedDays?: IntNullableFilter | number | null
    assignedUser?: StringNullableFilter | string | null
    TeamId?: IntNullableFilter | number | null
    y?: StringNullableFilter | string | null
    x?: StringNullableFilter | string | null
    area?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    pushPhone?: StringNullableFilter | string | null
    startedAt?: DateTimeNullableFilter | Date | string | null
    endedAt?: DateTimeNullableFilter | Date | string | null
    memo?: StringNullableFilter | string | null
    extra?: JsonNullableFilter
  }

  export type TaskGroupsUpsertWithWhereUniqueWithoutAccountsInput = {
    where: TaskGroupsWhereUniqueInput
    update: XOR<TaskGroupsUpdateWithoutAccountsInput, TaskGroupsUncheckedUpdateWithoutAccountsInput>
    create: XOR<TaskGroupsCreateWithoutAccountsInput, TaskGroupsUncheckedCreateWithoutAccountsInput>
  }

  export type TaskGroupsUpdateWithWhereUniqueWithoutAccountsInput = {
    where: TaskGroupsWhereUniqueInput
    data: XOR<TaskGroupsUpdateWithoutAccountsInput, TaskGroupsUncheckedUpdateWithoutAccountsInput>
  }

  export type TaskGroupsUpdateManyWithWhereWithoutAccountsInput = {
    where: TaskGroupsScalarWhereInput
    data: XOR<TaskGroupsUpdateManyMutationInput, TaskGroupsUncheckedUpdateManyWithoutTaskGroupsInput>
  }

  export type TaskGroupsScalarWhereInput = {
    AND?: Enumerable<TaskGroupsScalarWhereInput>
    OR?: Enumerable<TaskGroupsScalarWhereInput>
    NOT?: Enumerable<TaskGroupsScalarWhereInput>
    id?: IntFilter | number
    path?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    status?: StringNullableFilter | string | null
    AccountId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    area?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    createType?: StringNullableFilter | string | null
    extra?: JsonNullableFilter
  }

  export type TasksUpsertWithWhereUniqueWithoutAccountsInput = {
    where: TasksWhereUniqueInput
    update: XOR<TasksUpdateWithoutAccountsInput, TasksUncheckedUpdateWithoutAccountsInput>
    create: XOR<TasksCreateWithoutAccountsInput, TasksUncheckedCreateWithoutAccountsInput>
  }

  export type TasksUpdateWithWhereUniqueWithoutAccountsInput = {
    where: TasksWhereUniqueInput
    data: XOR<TasksUpdateWithoutAccountsInput, TasksUncheckedUpdateWithoutAccountsInput>
  }

  export type TasksUpdateManyWithWhereWithoutAccountsInput = {
    where: TasksScalarWhereInput
    data: XOR<TasksUpdateManyMutationInput, TasksUncheckedUpdateManyWithoutTasksInput>
  }

  export type TasksScalarWhereInput = {
    AND?: Enumerable<TasksScalarWhereInput>
    OR?: Enumerable<TasksScalarWhereInput>
    NOT?: Enumerable<TasksScalarWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    status?: StringNullableFilter | string | null
    AccountId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    workingDays?: IntNullableFilter | number | null
    workingTeamsCnt?: IntNullableFilter | number | null
    TaskGroupId?: IntNullableFilter | number | null
    startDate?: DateTimeNullableFilter | Date | string | null
    endDate?: DateTimeNullableFilter | Date | string | null
    area?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    isPaid?: BoolNullableFilter | boolean | null
    createType?: StringNullableFilter | string | null
    extra?: JsonNullableFilter
    real_area?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type TeamAgentsUpsertWithWhereUniqueWithoutAccountsInput = {
    where: TeamAgentsWhereUniqueInput
    update: XOR<TeamAgentsUpdateWithoutAccountsInput, TeamAgentsUncheckedUpdateWithoutAccountsInput>
    create: XOR<TeamAgentsCreateWithoutAccountsInput, TeamAgentsUncheckedCreateWithoutAccountsInput>
  }

  export type TeamAgentsUpdateWithWhereUniqueWithoutAccountsInput = {
    where: TeamAgentsWhereUniqueInput
    data: XOR<TeamAgentsUpdateWithoutAccountsInput, TeamAgentsUncheckedUpdateWithoutAccountsInput>
  }

  export type TeamAgentsUpdateManyWithWhereWithoutAccountsInput = {
    where: TeamAgentsScalarWhereInput
    data: XOR<TeamAgentsUpdateManyMutationInput, TeamAgentsUncheckedUpdateManyWithoutTeamAgentsInput>
  }

  export type TeamAgentsScalarWhereInput = {
    AND?: Enumerable<TeamAgentsScalarWhereInput>
    OR?: Enumerable<TeamAgentsScalarWhereInput>
    NOT?: Enumerable<TeamAgentsScalarWhereInput>
    AgentId?: IntFilter | number
    TeamId?: IntFilter | number
    isActive?: BoolNullableFilter | boolean | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TeamsUpsertWithWhereUniqueWithoutAccounts_AccountsToTeams_AccountIdInput = {
    where: TeamsWhereUniqueInput
    update: XOR<TeamsUpdateWithoutAccounts_AccountsToTeams_AccountIdInput, TeamsUncheckedUpdateWithoutAccounts_AccountsToTeams_AccountIdInput>
    create: XOR<TeamsCreateWithoutAccounts_AccountsToTeams_AccountIdInput, TeamsUncheckedCreateWithoutAccounts_AccountsToTeams_AccountIdInput>
  }

  export type TeamsUpdateWithWhereUniqueWithoutAccounts_AccountsToTeams_AccountIdInput = {
    where: TeamsWhereUniqueInput
    data: XOR<TeamsUpdateWithoutAccounts_AccountsToTeams_AccountIdInput, TeamsUncheckedUpdateWithoutAccounts_AccountsToTeams_AccountIdInput>
  }

  export type TeamsUpdateManyWithWhereWithoutAccounts_AccountsToTeams_AccountIdInput = {
    where: TeamsScalarWhereInput
    data: XOR<TeamsUpdateManyMutationInput, TeamsUncheckedUpdateManyWithoutTeams_AccountsToTeams_AccountIdInput>
  }

  export type TeamsScalarWhereInput = {
    AND?: Enumerable<TeamsScalarWhereInput>
    OR?: Enumerable<TeamsScalarWhereInput>
    NOT?: Enumerable<TeamsScalarWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    AccountId?: IntNullableFilter | number | null
    AgentId?: IntNullableFilter | number | null
    TaskId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    status?: StringNullableFilter | string | null
    area?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    alias?: StringNullableFilter | string | null
  }

  export type TeamsUpsertWithWhereUniqueWithoutAccounts_AccountsToTeams_AgentIdInput = {
    where: TeamsWhereUniqueInput
    update: XOR<TeamsUpdateWithoutAccounts_AccountsToTeams_AgentIdInput, TeamsUncheckedUpdateWithoutAccounts_AccountsToTeams_AgentIdInput>
    create: XOR<TeamsCreateWithoutAccounts_AccountsToTeams_AgentIdInput, TeamsUncheckedCreateWithoutAccounts_AccountsToTeams_AgentIdInput>
  }

  export type TeamsUpdateWithWhereUniqueWithoutAccounts_AccountsToTeams_AgentIdInput = {
    where: TeamsWhereUniqueInput
    data: XOR<TeamsUpdateWithoutAccounts_AccountsToTeams_AgentIdInput, TeamsUncheckedUpdateWithoutAccounts_AccountsToTeams_AgentIdInput>
  }

  export type TeamsUpdateManyWithWhereWithoutAccounts_AccountsToTeams_AgentIdInput = {
    where: TeamsScalarWhereInput
    data: XOR<TeamsUpdateManyMutationInput, TeamsUncheckedUpdateManyWithoutTeams_AccountsToTeams_AgentIdInput>
  }

  export type AccountsCreateWithoutAlertsInput = {
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    Services?: ServicesCreateNestedOneWithoutAccountsInput
    Careers?: CareersCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsCreateNestedManyWithoutAccountsInput
    Customers?: CustomersCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsCreateNestedManyWithoutAccountsInput
    Lands?: LandsCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutAccountsInput
    Orders?: OrdersCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsCreateNestedManyWithoutAccountsInput
    Posts?: PostsCreateNestedManyWithoutAccountsInput
    Reports?: ReportsCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsCreateNestedManyWithoutAccountsInput
    Tasks?: TasksCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsUncheckedCreateWithoutAlertsInput = {
    id?: number
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    ServiceKey?: string | null
    Careers?: CareersUncheckedCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutAccountsInput
    Lands?: LandsUncheckedCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutAccountsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsUncheckedCreateNestedManyWithoutAccountsInput
    Posts?: PostsUncheckedCreateNestedManyWithoutAccountsInput
    Reports?: ReportsUncheckedCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsUncheckedCreateNestedManyWithoutAccountsInput
    Tasks?: TasksUncheckedCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsUncheckedCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsCreateOrConnectWithoutAlertsInput = {
    where: AccountsWhereUniqueInput
    create: XOR<AccountsCreateWithoutAlertsInput, AccountsUncheckedCreateWithoutAlertsInput>
  }

  export type AccountsUpsertWithoutAlertsInput = {
    update: XOR<AccountsUpdateWithoutAlertsInput, AccountsUncheckedUpdateWithoutAlertsInput>
    create: XOR<AccountsCreateWithoutAlertsInput, AccountsUncheckedCreateWithoutAlertsInput>
  }

  export type AccountsUpdateWithoutAlertsInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Services?: ServicesUpdateOneWithoutAccountsNestedInput
    Careers?: CareersUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsUncheckedUpdateWithoutAlertsInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ServiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    Careers?: CareersUncheckedUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUncheckedUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUncheckedUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUncheckedUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUncheckedUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUncheckedUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUncheckedUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUncheckedUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUncheckedUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUncheckedUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsCreateWithoutCareersInput = {
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    Services?: ServicesCreateNestedOneWithoutAccountsInput
    Alerts?: AlertsCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsCreateNestedManyWithoutAccountsInput
    Customers?: CustomersCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsCreateNestedManyWithoutAccountsInput
    Lands?: LandsCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutAccountsInput
    Orders?: OrdersCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsCreateNestedManyWithoutAccountsInput
    Posts?: PostsCreateNestedManyWithoutAccountsInput
    Reports?: ReportsCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsCreateNestedManyWithoutAccountsInput
    Tasks?: TasksCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsUncheckedCreateWithoutCareersInput = {
    id?: number
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    ServiceKey?: string | null
    Alerts?: AlertsUncheckedCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutAccountsInput
    Lands?: LandsUncheckedCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutAccountsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsUncheckedCreateNestedManyWithoutAccountsInput
    Posts?: PostsUncheckedCreateNestedManyWithoutAccountsInput
    Reports?: ReportsUncheckedCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsUncheckedCreateNestedManyWithoutAccountsInput
    Tasks?: TasksUncheckedCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsUncheckedCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsCreateOrConnectWithoutCareersInput = {
    where: AccountsWhereUniqueInput
    create: XOR<AccountsCreateWithoutCareersInput, AccountsUncheckedCreateWithoutCareersInput>
  }

  export type AccountsUpsertWithoutCareersInput = {
    update: XOR<AccountsUpdateWithoutCareersInput, AccountsUncheckedUpdateWithoutCareersInput>
    create: XOR<AccountsCreateWithoutCareersInput, AccountsUncheckedCreateWithoutCareersInput>
  }

  export type AccountsUpdateWithoutCareersInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Services?: ServicesUpdateOneWithoutAccountsNestedInput
    Alerts?: AlertsUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsUncheckedUpdateWithoutCareersInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ServiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    Alerts?: AlertsUncheckedUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUncheckedUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUncheckedUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUncheckedUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUncheckedUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUncheckedUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUncheckedUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUncheckedUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUncheckedUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUncheckedUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type DiscountsCreateWithoutCouponsInput = {
    name?: string | null
    price?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    Accounts?: AccountsCreateNestedOneWithoutDiscountsInput
    Orders?: OrdersCreateNestedOneWithoutDiscountsInput
    Products?: ProductsCreateNestedOneWithoutDiscountsInput
  }

  export type DiscountsUncheckedCreateWithoutCouponsInput = {
    id?: number
    name?: string | null
    price?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    AccountId?: number | null
    OrderId?: number | null
    ProductId?: number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DiscountsCreateOrConnectWithoutCouponsInput = {
    where: DiscountsWhereUniqueInput
    create: XOR<DiscountsCreateWithoutCouponsInput, DiscountsUncheckedCreateWithoutCouponsInput>
  }

  export type DiscountsCreateManyCouponsInputEnvelope = {
    data: Enumerable<DiscountsCreateManyCouponsInput>
    skipDuplicates?: boolean
  }

  export type DiscountsUpsertWithWhereUniqueWithoutCouponsInput = {
    where: DiscountsWhereUniqueInput
    update: XOR<DiscountsUpdateWithoutCouponsInput, DiscountsUncheckedUpdateWithoutCouponsInput>
    create: XOR<DiscountsCreateWithoutCouponsInput, DiscountsUncheckedCreateWithoutCouponsInput>
  }

  export type DiscountsUpdateWithWhereUniqueWithoutCouponsInput = {
    where: DiscountsWhereUniqueInput
    data: XOR<DiscountsUpdateWithoutCouponsInput, DiscountsUncheckedUpdateWithoutCouponsInput>
  }

  export type DiscountsUpdateManyWithWhereWithoutCouponsInput = {
    where: DiscountsScalarWhereInput
    data: XOR<DiscountsUpdateManyMutationInput, DiscountsUncheckedUpdateManyWithoutDiscountsInput>
  }

  export type AccountsCreateWithoutCustomerTaskDetailsInput = {
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    Services?: ServicesCreateNestedOneWithoutAccountsInput
    Alerts?: AlertsCreateNestedManyWithoutAccountsInput
    Careers?: CareersCreateNestedManyWithoutAccountsInput
    Customers?: CustomersCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsCreateNestedManyWithoutAccountsInput
    Lands?: LandsCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutAccountsInput
    Orders?: OrdersCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsCreateNestedManyWithoutAccountsInput
    Posts?: PostsCreateNestedManyWithoutAccountsInput
    Reports?: ReportsCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsCreateNestedManyWithoutAccountsInput
    Tasks?: TasksCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsUncheckedCreateWithoutCustomerTaskDetailsInput = {
    id?: number
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    ServiceKey?: string | null
    Alerts?: AlertsUncheckedCreateNestedManyWithoutAccountsInput
    Careers?: CareersUncheckedCreateNestedManyWithoutAccountsInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutAccountsInput
    Lands?: LandsUncheckedCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutAccountsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsUncheckedCreateNestedManyWithoutAccountsInput
    Posts?: PostsUncheckedCreateNestedManyWithoutAccountsInput
    Reports?: ReportsUncheckedCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsUncheckedCreateNestedManyWithoutAccountsInput
    Tasks?: TasksUncheckedCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsUncheckedCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsCreateOrConnectWithoutCustomerTaskDetailsInput = {
    where: AccountsWhereUniqueInput
    create: XOR<AccountsCreateWithoutCustomerTaskDetailsInput, AccountsUncheckedCreateWithoutCustomerTaskDetailsInput>
  }

  export type CustomersCreateWithoutCustomerTaskDetailsInput = {
    name?: string | null
    email?: string | null
    phone?: string | null
    crops?: CustomersCreatecropsInput | Enumerable<string>
    createdAt: Date | string
    updatedAt: Date | string
    Accounts?: AccountsCreateNestedOneWithoutCustomersInput
  }

  export type CustomersUncheckedCreateWithoutCustomerTaskDetailsInput = {
    id?: number
    name?: string | null
    email?: string | null
    phone?: string | null
    crops?: CustomersCreatecropsInput | Enumerable<string>
    AccountId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CustomersCreateOrConnectWithoutCustomerTaskDetailsInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutCustomerTaskDetailsInput, CustomersUncheckedCreateWithoutCustomerTaskDetailsInput>
  }

  export type AccountsUpsertWithoutCustomerTaskDetailsInput = {
    update: XOR<AccountsUpdateWithoutCustomerTaskDetailsInput, AccountsUncheckedUpdateWithoutCustomerTaskDetailsInput>
    create: XOR<AccountsCreateWithoutCustomerTaskDetailsInput, AccountsUncheckedCreateWithoutCustomerTaskDetailsInput>
  }

  export type AccountsUpdateWithoutCustomerTaskDetailsInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Services?: ServicesUpdateOneWithoutAccountsNestedInput
    Alerts?: AlertsUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsUncheckedUpdateWithoutCustomerTaskDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ServiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    Alerts?: AlertsUncheckedUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUncheckedUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUncheckedUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUncheckedUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUncheckedUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUncheckedUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUncheckedUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUncheckedUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUncheckedUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUncheckedUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUncheckedUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type CustomersUpsertWithoutCustomerTaskDetailsInput = {
    update: XOR<CustomersUpdateWithoutCustomerTaskDetailsInput, CustomersUncheckedUpdateWithoutCustomerTaskDetailsInput>
    create: XOR<CustomersCreateWithoutCustomerTaskDetailsInput, CustomersUncheckedCreateWithoutCustomerTaskDetailsInput>
  }

  export type CustomersUpdateWithoutCustomerTaskDetailsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    crops?: CustomersUpdatecropsInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Accounts?: AccountsUpdateOneWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateWithoutCustomerTaskDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    crops?: CustomersUpdatecropsInput | Enumerable<string>
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountsCreateWithoutCustomersInput = {
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    Services?: ServicesCreateNestedOneWithoutAccountsInput
    Alerts?: AlertsCreateNestedManyWithoutAccountsInput
    Careers?: CareersCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsCreateNestedManyWithoutAccountsInput
    Lands?: LandsCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutAccountsInput
    Orders?: OrdersCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsCreateNestedManyWithoutAccountsInput
    Posts?: PostsCreateNestedManyWithoutAccountsInput
    Reports?: ReportsCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsCreateNestedManyWithoutAccountsInput
    Tasks?: TasksCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsUncheckedCreateWithoutCustomersInput = {
    id?: number
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    ServiceKey?: string | null
    Alerts?: AlertsUncheckedCreateNestedManyWithoutAccountsInput
    Careers?: CareersUncheckedCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutAccountsInput
    Lands?: LandsUncheckedCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutAccountsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsUncheckedCreateNestedManyWithoutAccountsInput
    Posts?: PostsUncheckedCreateNestedManyWithoutAccountsInput
    Reports?: ReportsUncheckedCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsUncheckedCreateNestedManyWithoutAccountsInput
    Tasks?: TasksUncheckedCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsUncheckedCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsCreateOrConnectWithoutCustomersInput = {
    where: AccountsWhereUniqueInput
    create: XOR<AccountsCreateWithoutCustomersInput, AccountsUncheckedCreateWithoutCustomersInput>
  }

  export type CustomerTaskDetailsCreateWithoutCustomersInput = {
    type?: string | null
    address?: string | null
    villageName?: string | null
    category?: string | null
    etc?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: string | null
    y?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    createdAt: Date | string
    updatedAt: Date | string
    Accounts?: AccountsCreateNestedOneWithoutCustomerTaskDetailsInput
  }

  export type CustomerTaskDetailsUncheckedCreateWithoutCustomersInput = {
    id?: number
    AccountId?: number | null
    type?: string | null
    address?: string | null
    villageName?: string | null
    category?: string | null
    etc?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: string | null
    y?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CustomerTaskDetailsCreateOrConnectWithoutCustomersInput = {
    where: CustomerTaskDetailsWhereUniqueInput
    create: XOR<CustomerTaskDetailsCreateWithoutCustomersInput, CustomerTaskDetailsUncheckedCreateWithoutCustomersInput>
  }

  export type CustomerTaskDetailsCreateManyCustomersInputEnvelope = {
    data: Enumerable<CustomerTaskDetailsCreateManyCustomersInput>
    skipDuplicates?: boolean
  }

  export type AccountsUpsertWithoutCustomersInput = {
    update: XOR<AccountsUpdateWithoutCustomersInput, AccountsUncheckedUpdateWithoutCustomersInput>
    create: XOR<AccountsCreateWithoutCustomersInput, AccountsUncheckedCreateWithoutCustomersInput>
  }

  export type AccountsUpdateWithoutCustomersInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Services?: ServicesUpdateOneWithoutAccountsNestedInput
    Alerts?: AlertsUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ServiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    Alerts?: AlertsUncheckedUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUncheckedUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUncheckedUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUncheckedUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUncheckedUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUncheckedUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUncheckedUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUncheckedUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUncheckedUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUncheckedUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUncheckedUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type CustomerTaskDetailsUpsertWithWhereUniqueWithoutCustomersInput = {
    where: CustomerTaskDetailsWhereUniqueInput
    update: XOR<CustomerTaskDetailsUpdateWithoutCustomersInput, CustomerTaskDetailsUncheckedUpdateWithoutCustomersInput>
    create: XOR<CustomerTaskDetailsCreateWithoutCustomersInput, CustomerTaskDetailsUncheckedCreateWithoutCustomersInput>
  }

  export type CustomerTaskDetailsUpdateWithWhereUniqueWithoutCustomersInput = {
    where: CustomerTaskDetailsWhereUniqueInput
    data: XOR<CustomerTaskDetailsUpdateWithoutCustomersInput, CustomerTaskDetailsUncheckedUpdateWithoutCustomersInput>
  }

  export type CustomerTaskDetailsUpdateManyWithWhereWithoutCustomersInput = {
    where: CustomerTaskDetailsScalarWhereInput
    data: XOR<CustomerTaskDetailsUpdateManyMutationInput, CustomerTaskDetailsUncheckedUpdateManyWithoutCustomerTaskDetailsInput>
  }

  export type AccountsCreateWithoutDiscountsInput = {
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    Services?: ServicesCreateNestedOneWithoutAccountsInput
    Alerts?: AlertsCreateNestedManyWithoutAccountsInput
    Careers?: CareersCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsCreateNestedManyWithoutAccountsInput
    Customers?: CustomersCreateNestedManyWithoutAccountsInput
    Lands?: LandsCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutAccountsInput
    Orders?: OrdersCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsCreateNestedManyWithoutAccountsInput
    Posts?: PostsCreateNestedManyWithoutAccountsInput
    Reports?: ReportsCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsCreateNestedManyWithoutAccountsInput
    Tasks?: TasksCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsUncheckedCreateWithoutDiscountsInput = {
    id?: number
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    ServiceKey?: string | null
    Alerts?: AlertsUncheckedCreateNestedManyWithoutAccountsInput
    Careers?: CareersUncheckedCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutAccountsInput
    Lands?: LandsUncheckedCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutAccountsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsUncheckedCreateNestedManyWithoutAccountsInput
    Posts?: PostsUncheckedCreateNestedManyWithoutAccountsInput
    Reports?: ReportsUncheckedCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsUncheckedCreateNestedManyWithoutAccountsInput
    Tasks?: TasksUncheckedCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsUncheckedCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsCreateOrConnectWithoutDiscountsInput = {
    where: AccountsWhereUniqueInput
    create: XOR<AccountsCreateWithoutDiscountsInput, AccountsUncheckedCreateWithoutDiscountsInput>
  }

  export type CouponsCreateWithoutDiscountsInput = {
    name?: string | null
    code?: string | null
    quantity?: number | null
    maxRetry?: number | null
    unit?: string | null
    value?: number | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt: Date | string
    extra?: NullableJsonNullValueInput | InputJsonValue
    updatedAt: Date | string
  }

  export type CouponsUncheckedCreateWithoutDiscountsInput = {
    id?: number
    name?: string | null
    code?: string | null
    quantity?: number | null
    maxRetry?: number | null
    unit?: string | null
    value?: number | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt: Date | string
    extra?: NullableJsonNullValueInput | InputJsonValue
    updatedAt: Date | string
  }

  export type CouponsCreateOrConnectWithoutDiscountsInput = {
    where: CouponsWhereUniqueInput
    create: XOR<CouponsCreateWithoutDiscountsInput, CouponsUncheckedCreateWithoutDiscountsInput>
  }

  export type OrdersCreateWithoutDiscountsInput = {
    name?: string | null
    payment?: string | null
    paymentMethod?: string | null
    externalUid?: string | null
    customerUid?: string | null
    merchantUid?: string | null
    reqAmount?: number | null
    paidAmount?: number | null
    status?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    expiredAt?: Date | string | null
    isSubscribe?: boolean | null
    issuedAt?: Date | string | null
    Accounts?: AccountsCreateNestedOneWithoutOrdersInput
    Products?: ProductsCreateNestedOneWithoutOrdersInput
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutOrdersInput
  }

  export type OrdersUncheckedCreateWithoutDiscountsInput = {
    id?: number
    name?: string | null
    payment?: string | null
    paymentMethod?: string | null
    externalUid?: string | null
    customerUid?: string | null
    merchantUid?: string | null
    reqAmount?: number | null
    paidAmount?: number | null
    status?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    AccountId?: number | null
    ProductId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    expiredAt?: Date | string | null
    isSubscribe?: boolean | null
    issuedAt?: Date | string | null
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type OrdersCreateOrConnectWithoutDiscountsInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutDiscountsInput, OrdersUncheckedCreateWithoutDiscountsInput>
  }

  export type ProductsCreateWithoutDiscountsInput = {
    name?: string | null
    description?: string | null
    price?: number | null
    duration?: number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    isSubscribe?: boolean | null
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutProductsInput
    Orders?: OrdersCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutDiscountsInput = {
    id?: number
    name?: string | null
    description?: string | null
    price?: number | null
    duration?: number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    isSubscribe?: boolean | null
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutProductsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutDiscountsInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutDiscountsInput, ProductsUncheckedCreateWithoutDiscountsInput>
  }

  export type AccountsUpsertWithoutDiscountsInput = {
    update: XOR<AccountsUpdateWithoutDiscountsInput, AccountsUncheckedUpdateWithoutDiscountsInput>
    create: XOR<AccountsCreateWithoutDiscountsInput, AccountsUncheckedCreateWithoutDiscountsInput>
  }

  export type AccountsUpdateWithoutDiscountsInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Services?: ServicesUpdateOneWithoutAccountsNestedInput
    Alerts?: AlertsUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsUncheckedUpdateWithoutDiscountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ServiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    Alerts?: AlertsUncheckedUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUncheckedUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUncheckedUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUncheckedUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUncheckedUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUncheckedUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUncheckedUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUncheckedUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUncheckedUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUncheckedUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type CouponsUpsertWithoutDiscountsInput = {
    update: XOR<CouponsUpdateWithoutDiscountsInput, CouponsUncheckedUpdateWithoutDiscountsInput>
    create: XOR<CouponsCreateWithoutDiscountsInput, CouponsUncheckedCreateWithoutDiscountsInput>
  }

  export type CouponsUpdateWithoutDiscountsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxRetry?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extra?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponsUncheckedUpdateWithoutDiscountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxRetry?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extra?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrdersUpsertWithoutDiscountsInput = {
    update: XOR<OrdersUpdateWithoutDiscountsInput, OrdersUncheckedUpdateWithoutDiscountsInput>
    create: XOR<OrdersCreateWithoutDiscountsInput, OrdersUncheckedCreateWithoutDiscountsInput>
  }

  export type OrdersUpdateWithoutDiscountsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    externalUid?: NullableStringFieldUpdateOperationsInput | string | null
    customerUid?: NullableStringFieldUpdateOperationsInput | string | null
    merchantUid?: NullableStringFieldUpdateOperationsInput | string | null
    reqAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Accounts?: AccountsUpdateOneWithoutOrdersNestedInput
    Products?: ProductsUpdateOneWithoutOrdersNestedInput
    OrderHistories?: OrderHistoriesUpdateManyWithoutOrdersNestedInput
  }

  export type OrdersUncheckedUpdateWithoutDiscountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    externalUid?: NullableStringFieldUpdateOperationsInput | string | null
    customerUid?: NullableStringFieldUpdateOperationsInput | string | null
    merchantUid?: NullableStringFieldUpdateOperationsInput | string | null
    reqAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    ProductId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type ProductsUpsertWithoutDiscountsInput = {
    update: XOR<ProductsUpdateWithoutDiscountsInput, ProductsUncheckedUpdateWithoutDiscountsInput>
    create: XOR<ProductsCreateWithoutDiscountsInput, ProductsUncheckedCreateWithoutDiscountsInput>
  }

  export type ProductsUpdateWithoutDiscountsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSubscribe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    OrderHistories?: OrderHistoriesUpdateManyWithoutProductsNestedInput
    Orders?: OrdersUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateWithoutDiscountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSubscribe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutProductsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type AccountsCreateWithoutLandsInput = {
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    Services?: ServicesCreateNestedOneWithoutAccountsInput
    Alerts?: AlertsCreateNestedManyWithoutAccountsInput
    Careers?: CareersCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsCreateNestedManyWithoutAccountsInput
    Customers?: CustomersCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutAccountsInput
    Orders?: OrdersCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsCreateNestedManyWithoutAccountsInput
    Posts?: PostsCreateNestedManyWithoutAccountsInput
    Reports?: ReportsCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsCreateNestedManyWithoutAccountsInput
    Tasks?: TasksCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsUncheckedCreateWithoutLandsInput = {
    id?: number
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    ServiceKey?: string | null
    Alerts?: AlertsUncheckedCreateNestedManyWithoutAccountsInput
    Careers?: CareersUncheckedCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutAccountsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsUncheckedCreateNestedManyWithoutAccountsInput
    Posts?: PostsUncheckedCreateNestedManyWithoutAccountsInput
    Reports?: ReportsUncheckedCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsUncheckedCreateNestedManyWithoutAccountsInput
    Tasks?: TasksUncheckedCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsUncheckedCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsCreateOrConnectWithoutLandsInput = {
    where: AccountsWhereUniqueInput
    create: XOR<AccountsCreateWithoutLandsInput, AccountsUncheckedCreateWithoutLandsInput>
  }

  export type AccountsUpsertWithoutLandsInput = {
    update: XOR<AccountsUpdateWithoutLandsInput, AccountsUncheckedUpdateWithoutLandsInput>
    create: XOR<AccountsCreateWithoutLandsInput, AccountsUncheckedCreateWithoutLandsInput>
  }

  export type AccountsUpdateWithoutLandsInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Services?: ServicesUpdateOneWithoutAccountsNestedInput
    Alerts?: AlertsUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsUncheckedUpdateWithoutLandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ServiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    Alerts?: AlertsUncheckedUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUncheckedUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUncheckedUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUncheckedUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUncheckedUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUncheckedUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUncheckedUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUncheckedUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUncheckedUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUncheckedUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsCreateWithoutNotificationsInput = {
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    Services?: ServicesCreateNestedOneWithoutAccountsInput
    Alerts?: AlertsCreateNestedManyWithoutAccountsInput
    Careers?: CareersCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsCreateNestedManyWithoutAccountsInput
    Customers?: CustomersCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsCreateNestedManyWithoutAccountsInput
    Lands?: LandsCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutAccountsInput
    Orders?: OrdersCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsCreateNestedManyWithoutAccountsInput
    Posts?: PostsCreateNestedManyWithoutAccountsInput
    Reports?: ReportsCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsCreateNestedManyWithoutAccountsInput
    Tasks?: TasksCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsUncheckedCreateWithoutNotificationsInput = {
    id?: number
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    ServiceKey?: string | null
    Alerts?: AlertsUncheckedCreateNestedManyWithoutAccountsInput
    Careers?: CareersUncheckedCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutAccountsInput
    Lands?: LandsUncheckedCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutAccountsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsUncheckedCreateNestedManyWithoutAccountsInput
    Posts?: PostsUncheckedCreateNestedManyWithoutAccountsInput
    Reports?: ReportsUncheckedCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsUncheckedCreateNestedManyWithoutAccountsInput
    Tasks?: TasksUncheckedCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsUncheckedCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsCreateOrConnectWithoutNotificationsInput = {
    where: AccountsWhereUniqueInput
    create: XOR<AccountsCreateWithoutNotificationsInput, AccountsUncheckedCreateWithoutNotificationsInput>
  }

  export type AccountsUpsertWithoutNotificationsInput = {
    update: XOR<AccountsUpdateWithoutNotificationsInput, AccountsUncheckedUpdateWithoutNotificationsInput>
    create: XOR<AccountsCreateWithoutNotificationsInput, AccountsUncheckedCreateWithoutNotificationsInput>
  }

  export type AccountsUpdateWithoutNotificationsInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Services?: ServicesUpdateOneWithoutAccountsNestedInput
    Alerts?: AlertsUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ServiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    Alerts?: AlertsUncheckedUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUncheckedUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUncheckedUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUncheckedUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUncheckedUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUncheckedUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUncheckedUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUncheckedUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUncheckedUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUncheckedUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUncheckedUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsCreateWithoutOrderHistoriesInput = {
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    Services?: ServicesCreateNestedOneWithoutAccountsInput
    Alerts?: AlertsCreateNestedManyWithoutAccountsInput
    Careers?: CareersCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsCreateNestedManyWithoutAccountsInput
    Customers?: CustomersCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsCreateNestedManyWithoutAccountsInput
    Lands?: LandsCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsCreateNestedManyWithoutAccountsInput
    Orders?: OrdersCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsCreateNestedManyWithoutAccountsInput
    Posts?: PostsCreateNestedManyWithoutAccountsInput
    Reports?: ReportsCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsCreateNestedManyWithoutAccountsInput
    Tasks?: TasksCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsUncheckedCreateWithoutOrderHistoriesInput = {
    id?: number
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    ServiceKey?: string | null
    Alerts?: AlertsUncheckedCreateNestedManyWithoutAccountsInput
    Careers?: CareersUncheckedCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutAccountsInput
    Lands?: LandsUncheckedCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutAccountsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsUncheckedCreateNestedManyWithoutAccountsInput
    Posts?: PostsUncheckedCreateNestedManyWithoutAccountsInput
    Reports?: ReportsUncheckedCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsUncheckedCreateNestedManyWithoutAccountsInput
    Tasks?: TasksUncheckedCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsUncheckedCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsCreateOrConnectWithoutOrderHistoriesInput = {
    where: AccountsWhereUniqueInput
    create: XOR<AccountsCreateWithoutOrderHistoriesInput, AccountsUncheckedCreateWithoutOrderHistoriesInput>
  }

  export type OrdersCreateWithoutOrderHistoriesInput = {
    name?: string | null
    payment?: string | null
    paymentMethod?: string | null
    externalUid?: string | null
    customerUid?: string | null
    merchantUid?: string | null
    reqAmount?: number | null
    paidAmount?: number | null
    status?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    expiredAt?: Date | string | null
    isSubscribe?: boolean | null
    issuedAt?: Date | string | null
    Accounts?: AccountsCreateNestedOneWithoutOrdersInput
    Products?: ProductsCreateNestedOneWithoutOrdersInput
    Discounts?: DiscountsCreateNestedManyWithoutOrdersInput
  }

  export type OrdersUncheckedCreateWithoutOrderHistoriesInput = {
    id?: number
    name?: string | null
    payment?: string | null
    paymentMethod?: string | null
    externalUid?: string | null
    customerUid?: string | null
    merchantUid?: string | null
    reqAmount?: number | null
    paidAmount?: number | null
    status?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    AccountId?: number | null
    ProductId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    expiredAt?: Date | string | null
    isSubscribe?: boolean | null
    issuedAt?: Date | string | null
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type OrdersCreateOrConnectWithoutOrderHistoriesInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutOrderHistoriesInput, OrdersUncheckedCreateWithoutOrderHistoriesInput>
  }

  export type ProductsCreateWithoutOrderHistoriesInput = {
    name?: string | null
    description?: string | null
    price?: number | null
    duration?: number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    isSubscribe?: boolean | null
    Discounts?: DiscountsCreateNestedManyWithoutProductsInput
    Orders?: OrdersCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutOrderHistoriesInput = {
    id?: number
    name?: string | null
    description?: string | null
    price?: number | null
    duration?: number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    isSubscribe?: boolean | null
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutProductsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutOrderHistoriesInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutOrderHistoriesInput, ProductsUncheckedCreateWithoutOrderHistoriesInput>
  }

  export type AccountsUpsertWithoutOrderHistoriesInput = {
    update: XOR<AccountsUpdateWithoutOrderHistoriesInput, AccountsUncheckedUpdateWithoutOrderHistoriesInput>
    create: XOR<AccountsCreateWithoutOrderHistoriesInput, AccountsUncheckedCreateWithoutOrderHistoriesInput>
  }

  export type AccountsUpdateWithoutOrderHistoriesInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Services?: ServicesUpdateOneWithoutAccountsNestedInput
    Alerts?: AlertsUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsUncheckedUpdateWithoutOrderHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ServiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    Alerts?: AlertsUncheckedUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUncheckedUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUncheckedUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUncheckedUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUncheckedUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUncheckedUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUncheckedUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUncheckedUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUncheckedUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUncheckedUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUncheckedUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type OrdersUpsertWithoutOrderHistoriesInput = {
    update: XOR<OrdersUpdateWithoutOrderHistoriesInput, OrdersUncheckedUpdateWithoutOrderHistoriesInput>
    create: XOR<OrdersCreateWithoutOrderHistoriesInput, OrdersUncheckedCreateWithoutOrderHistoriesInput>
  }

  export type OrdersUpdateWithoutOrderHistoriesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    externalUid?: NullableStringFieldUpdateOperationsInput | string | null
    customerUid?: NullableStringFieldUpdateOperationsInput | string | null
    merchantUid?: NullableStringFieldUpdateOperationsInput | string | null
    reqAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Accounts?: AccountsUpdateOneWithoutOrdersNestedInput
    Products?: ProductsUpdateOneWithoutOrdersNestedInput
    Discounts?: DiscountsUpdateManyWithoutOrdersNestedInput
  }

  export type OrdersUncheckedUpdateWithoutOrderHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    externalUid?: NullableStringFieldUpdateOperationsInput | string | null
    customerUid?: NullableStringFieldUpdateOperationsInput | string | null
    merchantUid?: NullableStringFieldUpdateOperationsInput | string | null
    reqAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    ProductId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Discounts?: DiscountsUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type ProductsUpsertWithoutOrderHistoriesInput = {
    update: XOR<ProductsUpdateWithoutOrderHistoriesInput, ProductsUncheckedUpdateWithoutOrderHistoriesInput>
    create: XOR<ProductsCreateWithoutOrderHistoriesInput, ProductsUncheckedCreateWithoutOrderHistoriesInput>
  }

  export type ProductsUpdateWithoutOrderHistoriesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSubscribe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Discounts?: DiscountsUpdateManyWithoutProductsNestedInput
    Orders?: OrdersUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateWithoutOrderHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSubscribe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Discounts?: DiscountsUncheckedUpdateManyWithoutProductsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type AccountsCreateWithoutOrdersInput = {
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    Services?: ServicesCreateNestedOneWithoutAccountsInput
    Alerts?: AlertsCreateNestedManyWithoutAccountsInput
    Careers?: CareersCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsCreateNestedManyWithoutAccountsInput
    Customers?: CustomersCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsCreateNestedManyWithoutAccountsInput
    Lands?: LandsCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsCreateNestedManyWithoutAccountsInput
    Posts?: PostsCreateNestedManyWithoutAccountsInput
    Reports?: ReportsCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsCreateNestedManyWithoutAccountsInput
    Tasks?: TasksCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsUncheckedCreateWithoutOrdersInput = {
    id?: number
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    ServiceKey?: string | null
    Alerts?: AlertsUncheckedCreateNestedManyWithoutAccountsInput
    Careers?: CareersUncheckedCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutAccountsInput
    Lands?: LandsUncheckedCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsUncheckedCreateNestedManyWithoutAccountsInput
    Posts?: PostsUncheckedCreateNestedManyWithoutAccountsInput
    Reports?: ReportsUncheckedCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsUncheckedCreateNestedManyWithoutAccountsInput
    Tasks?: TasksUncheckedCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsUncheckedCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsCreateOrConnectWithoutOrdersInput = {
    where: AccountsWhereUniqueInput
    create: XOR<AccountsCreateWithoutOrdersInput, AccountsUncheckedCreateWithoutOrdersInput>
  }

  export type ProductsCreateWithoutOrdersInput = {
    name?: string | null
    description?: string | null
    price?: number | null
    duration?: number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    isSubscribe?: boolean | null
    Discounts?: DiscountsCreateNestedManyWithoutProductsInput
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutOrdersInput = {
    id?: number
    name?: string | null
    description?: string | null
    price?: number | null
    duration?: number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    isSubscribe?: boolean | null
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutProductsInput
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutOrdersInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutOrdersInput, ProductsUncheckedCreateWithoutOrdersInput>
  }

  export type DiscountsCreateWithoutOrdersInput = {
    name?: string | null
    price?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    Accounts?: AccountsCreateNestedOneWithoutDiscountsInput
    Coupons?: CouponsCreateNestedOneWithoutDiscountsInput
    Products?: ProductsCreateNestedOneWithoutDiscountsInput
  }

  export type DiscountsUncheckedCreateWithoutOrdersInput = {
    id?: number
    name?: string | null
    price?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    AccountId?: number | null
    CouponId?: number | null
    ProductId?: number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DiscountsCreateOrConnectWithoutOrdersInput = {
    where: DiscountsWhereUniqueInput
    create: XOR<DiscountsCreateWithoutOrdersInput, DiscountsUncheckedCreateWithoutOrdersInput>
  }

  export type DiscountsCreateManyOrdersInputEnvelope = {
    data: Enumerable<DiscountsCreateManyOrdersInput>
    skipDuplicates?: boolean
  }

  export type OrderHistoriesCreateWithoutOrdersInput = {
    name?: string | null
    payment?: string | null
    paymentMethod?: string | null
    externalUid?: string | null
    customerUid?: string | null
    merchantUid?: string | null
    reqAmount?: number | null
    paidAmount?: number | null
    status?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    Accounts?: AccountsCreateNestedOneWithoutOrderHistoriesInput
    Products?: ProductsCreateNestedOneWithoutOrderHistoriesInput
  }

  export type OrderHistoriesUncheckedCreateWithoutOrdersInput = {
    id?: number
    name?: string | null
    payment?: string | null
    paymentMethod?: string | null
    externalUid?: string | null
    customerUid?: string | null
    merchantUid?: string | null
    reqAmount?: number | null
    paidAmount?: number | null
    status?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    AccountId?: number | null
    ProductId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type OrderHistoriesCreateOrConnectWithoutOrdersInput = {
    where: OrderHistoriesWhereUniqueInput
    create: XOR<OrderHistoriesCreateWithoutOrdersInput, OrderHistoriesUncheckedCreateWithoutOrdersInput>
  }

  export type OrderHistoriesCreateManyOrdersInputEnvelope = {
    data: Enumerable<OrderHistoriesCreateManyOrdersInput>
    skipDuplicates?: boolean
  }

  export type AccountsUpsertWithoutOrdersInput = {
    update: XOR<AccountsUpdateWithoutOrdersInput, AccountsUncheckedUpdateWithoutOrdersInput>
    create: XOR<AccountsCreateWithoutOrdersInput, AccountsUncheckedCreateWithoutOrdersInput>
  }

  export type AccountsUpdateWithoutOrdersInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Services?: ServicesUpdateOneWithoutAccountsNestedInput
    Alerts?: AlertsUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ServiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    Alerts?: AlertsUncheckedUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUncheckedUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUncheckedUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUncheckedUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUncheckedUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUncheckedUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUncheckedUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUncheckedUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUncheckedUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUncheckedUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUncheckedUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type ProductsUpsertWithoutOrdersInput = {
    update: XOR<ProductsUpdateWithoutOrdersInput, ProductsUncheckedUpdateWithoutOrdersInput>
    create: XOR<ProductsCreateWithoutOrdersInput, ProductsUncheckedCreateWithoutOrdersInput>
  }

  export type ProductsUpdateWithoutOrdersInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSubscribe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Discounts?: DiscountsUpdateManyWithoutProductsNestedInput
    OrderHistories?: OrderHistoriesUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSubscribe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Discounts?: DiscountsUncheckedUpdateManyWithoutProductsNestedInput
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type DiscountsUpsertWithWhereUniqueWithoutOrdersInput = {
    where: DiscountsWhereUniqueInput
    update: XOR<DiscountsUpdateWithoutOrdersInput, DiscountsUncheckedUpdateWithoutOrdersInput>
    create: XOR<DiscountsCreateWithoutOrdersInput, DiscountsUncheckedCreateWithoutOrdersInput>
  }

  export type DiscountsUpdateWithWhereUniqueWithoutOrdersInput = {
    where: DiscountsWhereUniqueInput
    data: XOR<DiscountsUpdateWithoutOrdersInput, DiscountsUncheckedUpdateWithoutOrdersInput>
  }

  export type DiscountsUpdateManyWithWhereWithoutOrdersInput = {
    where: DiscountsScalarWhereInput
    data: XOR<DiscountsUpdateManyMutationInput, DiscountsUncheckedUpdateManyWithoutDiscountsInput>
  }

  export type OrderHistoriesUpsertWithWhereUniqueWithoutOrdersInput = {
    where: OrderHistoriesWhereUniqueInput
    update: XOR<OrderHistoriesUpdateWithoutOrdersInput, OrderHistoriesUncheckedUpdateWithoutOrdersInput>
    create: XOR<OrderHistoriesCreateWithoutOrdersInput, OrderHistoriesUncheckedCreateWithoutOrdersInput>
  }

  export type OrderHistoriesUpdateWithWhereUniqueWithoutOrdersInput = {
    where: OrderHistoriesWhereUniqueInput
    data: XOR<OrderHistoriesUpdateWithoutOrdersInput, OrderHistoriesUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderHistoriesUpdateManyWithWhereWithoutOrdersInput = {
    where: OrderHistoriesScalarWhereInput
    data: XOR<OrderHistoriesUpdateManyMutationInput, OrderHistoriesUncheckedUpdateManyWithoutOrderHistoriesInput>
  }

  export type AccountsCreateWithoutPermissionsInput = {
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    Services?: ServicesCreateNestedOneWithoutAccountsInput
    Alerts?: AlertsCreateNestedManyWithoutAccountsInput
    Careers?: CareersCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsCreateNestedManyWithoutAccountsInput
    Customers?: CustomersCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsCreateNestedManyWithoutAccountsInput
    Lands?: LandsCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutAccountsInput
    Orders?: OrdersCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsCreateNestedManyWithoutAccountsInput
    Posts?: PostsCreateNestedManyWithoutAccountsInput
    Reports?: ReportsCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsCreateNestedManyWithoutAccountsInput
    Tasks?: TasksCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsUncheckedCreateWithoutPermissionsInput = {
    id?: number
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    ServiceKey?: string | null
    Alerts?: AlertsUncheckedCreateNestedManyWithoutAccountsInput
    Careers?: CareersUncheckedCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutAccountsInput
    Lands?: LandsUncheckedCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutAccountsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsUncheckedCreateNestedManyWithoutAccountsInput
    Posts?: PostsUncheckedCreateNestedManyWithoutAccountsInput
    Reports?: ReportsUncheckedCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsUncheckedCreateNestedManyWithoutAccountsInput
    Tasks?: TasksUncheckedCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsUncheckedCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsCreateOrConnectWithoutPermissionsInput = {
    where: AccountsWhereUniqueInput
    create: XOR<AccountsCreateWithoutPermissionsInput, AccountsUncheckedCreateWithoutPermissionsInput>
  }

  export type AccountsUpsertWithoutPermissionsInput = {
    update: XOR<AccountsUpdateWithoutPermissionsInput, AccountsUncheckedUpdateWithoutPermissionsInput>
    create: XOR<AccountsCreateWithoutPermissionsInput, AccountsUncheckedCreateWithoutPermissionsInput>
  }

  export type AccountsUpdateWithoutPermissionsInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Services?: ServicesUpdateOneWithoutAccountsNestedInput
    Alerts?: AlertsUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsUncheckedUpdateWithoutPermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ServiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    Alerts?: AlertsUncheckedUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUncheckedUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUncheckedUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUncheckedUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUncheckedUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUncheckedUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUncheckedUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUncheckedUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUncheckedUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUncheckedUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUncheckedUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsCreateWithoutPostAccountsInput = {
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    Services?: ServicesCreateNestedOneWithoutAccountsInput
    Alerts?: AlertsCreateNestedManyWithoutAccountsInput
    Careers?: CareersCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsCreateNestedManyWithoutAccountsInput
    Customers?: CustomersCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsCreateNestedManyWithoutAccountsInput
    Lands?: LandsCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutAccountsInput
    Orders?: OrdersCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutAccountsInput
    Posts?: PostsCreateNestedManyWithoutAccountsInput
    Reports?: ReportsCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsCreateNestedManyWithoutAccountsInput
    Tasks?: TasksCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsUncheckedCreateWithoutPostAccountsInput = {
    id?: number
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    ServiceKey?: string | null
    Alerts?: AlertsUncheckedCreateNestedManyWithoutAccountsInput
    Careers?: CareersUncheckedCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutAccountsInput
    Lands?: LandsUncheckedCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutAccountsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutAccountsInput
    Posts?: PostsUncheckedCreateNestedManyWithoutAccountsInput
    Reports?: ReportsUncheckedCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsUncheckedCreateNestedManyWithoutAccountsInput
    Tasks?: TasksUncheckedCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsUncheckedCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsCreateOrConnectWithoutPostAccountsInput = {
    where: AccountsWhereUniqueInput
    create: XOR<AccountsCreateWithoutPostAccountsInput, AccountsUncheckedCreateWithoutPostAccountsInput>
  }

  export type PostsCreateWithoutPostAccountsInput = {
    category?: string | null
    type?: PostsCreatetypeInput | Enumerable<string>
    content?: string | null
    unit?: string | null
    price?: number | null
    location?: PostsCreatelocationInput | Enumerable<string>
    area?: Decimal | DecimalJsLike | number | string | null
    title?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: string | null
    viewCount?: number | null
    contactName?: string | null
    contactPhone?: string | null
    contactEmail?: string | null
    qualifications?: PostsCreatequalificationsInput | Enumerable<string>
    Accounts?: AccountsCreateNestedOneWithoutPostsInput
  }

  export type PostsUncheckedCreateWithoutPostAccountsInput = {
    id?: number
    category?: string | null
    type?: PostsCreatetypeInput | Enumerable<string>
    content?: string | null
    unit?: string | null
    price?: number | null
    location?: PostsCreatelocationInput | Enumerable<string>
    area?: Decimal | DecimalJsLike | number | string | null
    title?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: string | null
    viewCount?: number | null
    AccountId?: number | null
    contactName?: string | null
    contactPhone?: string | null
    contactEmail?: string | null
    qualifications?: PostsCreatequalificationsInput | Enumerable<string>
  }

  export type PostsCreateOrConnectWithoutPostAccountsInput = {
    where: PostsWhereUniqueInput
    create: XOR<PostsCreateWithoutPostAccountsInput, PostsUncheckedCreateWithoutPostAccountsInput>
  }

  export type AccountsUpsertWithoutPostAccountsInput = {
    update: XOR<AccountsUpdateWithoutPostAccountsInput, AccountsUncheckedUpdateWithoutPostAccountsInput>
    create: XOR<AccountsCreateWithoutPostAccountsInput, AccountsUncheckedCreateWithoutPostAccountsInput>
  }

  export type AccountsUpdateWithoutPostAccountsInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Services?: ServicesUpdateOneWithoutAccountsNestedInput
    Alerts?: AlertsUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsUncheckedUpdateWithoutPostAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ServiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    Alerts?: AlertsUncheckedUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUncheckedUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUncheckedUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUncheckedUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUncheckedUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUncheckedUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUncheckedUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUncheckedUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUncheckedUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUncheckedUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type PostsUpsertWithoutPostAccountsInput = {
    update: XOR<PostsUpdateWithoutPostAccountsInput, PostsUncheckedUpdateWithoutPostAccountsInput>
    create: XOR<PostsCreateWithoutPostAccountsInput, PostsUncheckedCreateWithoutPostAccountsInput>
  }

  export type PostsUpdateWithoutPostAccountsInput = {
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: PostsUpdatetypeInput | Enumerable<string>
    content?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    location?: PostsUpdatelocationInput | Enumerable<string>
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: PostsUpdatequalificationsInput | Enumerable<string>
    Accounts?: AccountsUpdateOneWithoutPostsNestedInput
  }

  export type PostsUncheckedUpdateWithoutPostAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: PostsUpdatetypeInput | Enumerable<string>
    content?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    location?: PostsUpdatelocationInput | Enumerable<string>
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: PostsUpdatequalificationsInput | Enumerable<string>
  }

  export type AccountsCreateWithoutPostsInput = {
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    Services?: ServicesCreateNestedOneWithoutAccountsInput
    Alerts?: AlertsCreateNestedManyWithoutAccountsInput
    Careers?: CareersCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsCreateNestedManyWithoutAccountsInput
    Customers?: CustomersCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsCreateNestedManyWithoutAccountsInput
    Lands?: LandsCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutAccountsInput
    Orders?: OrdersCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsCreateNestedManyWithoutAccountsInput
    Reports?: ReportsCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsCreateNestedManyWithoutAccountsInput
    Tasks?: TasksCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsUncheckedCreateWithoutPostsInput = {
    id?: number
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    ServiceKey?: string | null
    Alerts?: AlertsUncheckedCreateNestedManyWithoutAccountsInput
    Careers?: CareersUncheckedCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutAccountsInput
    Lands?: LandsUncheckedCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutAccountsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsUncheckedCreateNestedManyWithoutAccountsInput
    Reports?: ReportsUncheckedCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsUncheckedCreateNestedManyWithoutAccountsInput
    Tasks?: TasksUncheckedCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsUncheckedCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsCreateOrConnectWithoutPostsInput = {
    where: AccountsWhereUniqueInput
    create: XOR<AccountsCreateWithoutPostsInput, AccountsUncheckedCreateWithoutPostsInput>
  }

  export type PostAccountsCreateWithoutPostsInput = {
    type?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    Accounts?: AccountsCreateNestedOneWithoutPostAccountsInput
  }

  export type PostAccountsUncheckedCreateWithoutPostsInput = {
    id?: number
    AccountId?: number | null
    type?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type PostAccountsCreateOrConnectWithoutPostsInput = {
    where: PostAccountsWhereUniqueInput
    create: XOR<PostAccountsCreateWithoutPostsInput, PostAccountsUncheckedCreateWithoutPostsInput>
  }

  export type PostAccountsCreateManyPostsInputEnvelope = {
    data: Enumerable<PostAccountsCreateManyPostsInput>
    skipDuplicates?: boolean
  }

  export type AccountsUpsertWithoutPostsInput = {
    update: XOR<AccountsUpdateWithoutPostsInput, AccountsUncheckedUpdateWithoutPostsInput>
    create: XOR<AccountsCreateWithoutPostsInput, AccountsUncheckedCreateWithoutPostsInput>
  }

  export type AccountsUpdateWithoutPostsInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Services?: ServicesUpdateOneWithoutAccountsNestedInput
    Alerts?: AlertsUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ServiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    Alerts?: AlertsUncheckedUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUncheckedUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUncheckedUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUncheckedUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUncheckedUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUncheckedUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUncheckedUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUncheckedUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUncheckedUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUncheckedUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type PostAccountsUpsertWithWhereUniqueWithoutPostsInput = {
    where: PostAccountsWhereUniqueInput
    update: XOR<PostAccountsUpdateWithoutPostsInput, PostAccountsUncheckedUpdateWithoutPostsInput>
    create: XOR<PostAccountsCreateWithoutPostsInput, PostAccountsUncheckedCreateWithoutPostsInput>
  }

  export type PostAccountsUpdateWithWhereUniqueWithoutPostsInput = {
    where: PostAccountsWhereUniqueInput
    data: XOR<PostAccountsUpdateWithoutPostsInput, PostAccountsUncheckedUpdateWithoutPostsInput>
  }

  export type PostAccountsUpdateManyWithWhereWithoutPostsInput = {
    where: PostAccountsScalarWhereInput
    data: XOR<PostAccountsUpdateManyMutationInput, PostAccountsUncheckedUpdateManyWithoutPostAccountsInput>
  }

  export type DiscountsCreateWithoutProductsInput = {
    name?: string | null
    price?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    Accounts?: AccountsCreateNestedOneWithoutDiscountsInput
    Coupons?: CouponsCreateNestedOneWithoutDiscountsInput
    Orders?: OrdersCreateNestedOneWithoutDiscountsInput
  }

  export type DiscountsUncheckedCreateWithoutProductsInput = {
    id?: number
    name?: string | null
    price?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    AccountId?: number | null
    OrderId?: number | null
    CouponId?: number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DiscountsCreateOrConnectWithoutProductsInput = {
    where: DiscountsWhereUniqueInput
    create: XOR<DiscountsCreateWithoutProductsInput, DiscountsUncheckedCreateWithoutProductsInput>
  }

  export type DiscountsCreateManyProductsInputEnvelope = {
    data: Enumerable<DiscountsCreateManyProductsInput>
    skipDuplicates?: boolean
  }

  export type OrderHistoriesCreateWithoutProductsInput = {
    name?: string | null
    payment?: string | null
    paymentMethod?: string | null
    externalUid?: string | null
    customerUid?: string | null
    merchantUid?: string | null
    reqAmount?: number | null
    paidAmount?: number | null
    status?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    Accounts?: AccountsCreateNestedOneWithoutOrderHistoriesInput
    Orders?: OrdersCreateNestedOneWithoutOrderHistoriesInput
  }

  export type OrderHistoriesUncheckedCreateWithoutProductsInput = {
    id?: number
    name?: string | null
    payment?: string | null
    paymentMethod?: string | null
    externalUid?: string | null
    customerUid?: string | null
    merchantUid?: string | null
    reqAmount?: number | null
    paidAmount?: number | null
    status?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    AccountId?: number | null
    OrderId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type OrderHistoriesCreateOrConnectWithoutProductsInput = {
    where: OrderHistoriesWhereUniqueInput
    create: XOR<OrderHistoriesCreateWithoutProductsInput, OrderHistoriesUncheckedCreateWithoutProductsInput>
  }

  export type OrderHistoriesCreateManyProductsInputEnvelope = {
    data: Enumerable<OrderHistoriesCreateManyProductsInput>
    skipDuplicates?: boolean
  }

  export type OrdersCreateWithoutProductsInput = {
    name?: string | null
    payment?: string | null
    paymentMethod?: string | null
    externalUid?: string | null
    customerUid?: string | null
    merchantUid?: string | null
    reqAmount?: number | null
    paidAmount?: number | null
    status?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    expiredAt?: Date | string | null
    isSubscribe?: boolean | null
    issuedAt?: Date | string | null
    Accounts?: AccountsCreateNestedOneWithoutOrdersInput
    Discounts?: DiscountsCreateNestedManyWithoutOrdersInput
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutOrdersInput
  }

  export type OrdersUncheckedCreateWithoutProductsInput = {
    id?: number
    name?: string | null
    payment?: string | null
    paymentMethod?: string | null
    externalUid?: string | null
    customerUid?: string | null
    merchantUid?: string | null
    reqAmount?: number | null
    paidAmount?: number | null
    status?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    AccountId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    expiredAt?: Date | string | null
    isSubscribe?: boolean | null
    issuedAt?: Date | string | null
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutOrdersInput
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type OrdersCreateOrConnectWithoutProductsInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutProductsInput, OrdersUncheckedCreateWithoutProductsInput>
  }

  export type OrdersCreateManyProductsInputEnvelope = {
    data: Enumerable<OrdersCreateManyProductsInput>
    skipDuplicates?: boolean
  }

  export type DiscountsUpsertWithWhereUniqueWithoutProductsInput = {
    where: DiscountsWhereUniqueInput
    update: XOR<DiscountsUpdateWithoutProductsInput, DiscountsUncheckedUpdateWithoutProductsInput>
    create: XOR<DiscountsCreateWithoutProductsInput, DiscountsUncheckedCreateWithoutProductsInput>
  }

  export type DiscountsUpdateWithWhereUniqueWithoutProductsInput = {
    where: DiscountsWhereUniqueInput
    data: XOR<DiscountsUpdateWithoutProductsInput, DiscountsUncheckedUpdateWithoutProductsInput>
  }

  export type DiscountsUpdateManyWithWhereWithoutProductsInput = {
    where: DiscountsScalarWhereInput
    data: XOR<DiscountsUpdateManyMutationInput, DiscountsUncheckedUpdateManyWithoutDiscountsInput>
  }

  export type OrderHistoriesUpsertWithWhereUniqueWithoutProductsInput = {
    where: OrderHistoriesWhereUniqueInput
    update: XOR<OrderHistoriesUpdateWithoutProductsInput, OrderHistoriesUncheckedUpdateWithoutProductsInput>
    create: XOR<OrderHistoriesCreateWithoutProductsInput, OrderHistoriesUncheckedCreateWithoutProductsInput>
  }

  export type OrderHistoriesUpdateWithWhereUniqueWithoutProductsInput = {
    where: OrderHistoriesWhereUniqueInput
    data: XOR<OrderHistoriesUpdateWithoutProductsInput, OrderHistoriesUncheckedUpdateWithoutProductsInput>
  }

  export type OrderHistoriesUpdateManyWithWhereWithoutProductsInput = {
    where: OrderHistoriesScalarWhereInput
    data: XOR<OrderHistoriesUpdateManyMutationInput, OrderHistoriesUncheckedUpdateManyWithoutOrderHistoriesInput>
  }

  export type OrdersUpsertWithWhereUniqueWithoutProductsInput = {
    where: OrdersWhereUniqueInput
    update: XOR<OrdersUpdateWithoutProductsInput, OrdersUncheckedUpdateWithoutProductsInput>
    create: XOR<OrdersCreateWithoutProductsInput, OrdersUncheckedCreateWithoutProductsInput>
  }

  export type OrdersUpdateWithWhereUniqueWithoutProductsInput = {
    where: OrdersWhereUniqueInput
    data: XOR<OrdersUpdateWithoutProductsInput, OrdersUncheckedUpdateWithoutProductsInput>
  }

  export type OrdersUpdateManyWithWhereWithoutProductsInput = {
    where: OrdersScalarWhereInput
    data: XOR<OrdersUpdateManyMutationInput, OrdersUncheckedUpdateManyWithoutOrdersInput>
  }

  export type AccountsCreateWithoutReportsInput = {
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    Services?: ServicesCreateNestedOneWithoutAccountsInput
    Alerts?: AlertsCreateNestedManyWithoutAccountsInput
    Careers?: CareersCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsCreateNestedManyWithoutAccountsInput
    Customers?: CustomersCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsCreateNestedManyWithoutAccountsInput
    Lands?: LandsCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutAccountsInput
    Orders?: OrdersCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsCreateNestedManyWithoutAccountsInput
    Posts?: PostsCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsCreateNestedManyWithoutAccountsInput
    Tasks?: TasksCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsUncheckedCreateWithoutReportsInput = {
    id?: number
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    ServiceKey?: string | null
    Alerts?: AlertsUncheckedCreateNestedManyWithoutAccountsInput
    Careers?: CareersUncheckedCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutAccountsInput
    Lands?: LandsUncheckedCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutAccountsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsUncheckedCreateNestedManyWithoutAccountsInput
    Posts?: PostsUncheckedCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsUncheckedCreateNestedManyWithoutAccountsInput
    Tasks?: TasksUncheckedCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsUncheckedCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsCreateOrConnectWithoutReportsInput = {
    where: AccountsWhereUniqueInput
    create: XOR<AccountsCreateWithoutReportsInput, AccountsUncheckedCreateWithoutReportsInput>
  }

  export type TasksCreateWithoutReportsInput = {
    name?: string | null
    status?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    workingDays?: number | null
    workingTeamsCnt?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    area?: Decimal | DecimalJsLike | number | string | null
    isPaid?: boolean | null
    createType?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: Decimal | DecimalJsLike | number | string | null
    Accounts?: AccountsCreateNestedOneWithoutTasksInput
    TaskGroups?: TaskGroupsCreateNestedOneWithoutTasksInput
    Statistics?: StatisticsCreateNestedManyWithoutTasksInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutTasksInput
    Teams?: TeamsCreateNestedManyWithoutTasksInput
  }

  export type TasksUncheckedCreateWithoutReportsInput = {
    id?: number
    name?: string | null
    status?: string | null
    AccountId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    workingDays?: number | null
    workingTeamsCnt?: number | null
    TaskGroupId?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    area?: Decimal | DecimalJsLike | number | string | null
    isPaid?: boolean | null
    createType?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: Decimal | DecimalJsLike | number | string | null
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutTasksInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutTasksInput
    Teams?: TeamsUncheckedCreateNestedManyWithoutTasksInput
  }

  export type TasksCreateOrConnectWithoutReportsInput = {
    where: TasksWhereUniqueInput
    create: XOR<TasksCreateWithoutReportsInput, TasksUncheckedCreateWithoutReportsInput>
  }

  export type AccountsUpsertWithoutReportsInput = {
    update: XOR<AccountsUpdateWithoutReportsInput, AccountsUncheckedUpdateWithoutReportsInput>
    create: XOR<AccountsCreateWithoutReportsInput, AccountsUncheckedCreateWithoutReportsInput>
  }

  export type AccountsUpdateWithoutReportsInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Services?: ServicesUpdateOneWithoutAccountsNestedInput
    Alerts?: AlertsUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsUncheckedUpdateWithoutReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ServiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    Alerts?: AlertsUncheckedUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUncheckedUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUncheckedUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUncheckedUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUncheckedUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUncheckedUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUncheckedUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUncheckedUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUncheckedUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUncheckedUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type TasksUpsertWithoutReportsInput = {
    update: XOR<TasksUpdateWithoutReportsInput, TasksUncheckedUpdateWithoutReportsInput>
    create: XOR<TasksCreateWithoutReportsInput, TasksUncheckedCreateWithoutReportsInput>
  }

  export type TasksUpdateWithoutReportsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: NullableIntFieldUpdateOperationsInput | number | null
    workingTeamsCnt?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createType?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Accounts?: AccountsUpdateOneWithoutTasksNestedInput
    TaskGroups?: TaskGroupsUpdateOneWithoutTasksNestedInput
    Statistics?: StatisticsUpdateManyWithoutTasksNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutTasksNestedInput
    Teams?: TeamsUpdateManyWithoutTasksNestedInput
  }

  export type TasksUncheckedUpdateWithoutReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: NullableIntFieldUpdateOperationsInput | number | null
    workingTeamsCnt?: NullableIntFieldUpdateOperationsInput | number | null
    TaskGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createType?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Statistics?: StatisticsUncheckedUpdateManyWithoutTasksNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutTasksNestedInput
    Teams?: TeamsUncheckedUpdateManyWithoutTasksNestedInput
  }

  export type AccountsCreateWithoutServicesInput = {
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    Alerts?: AlertsCreateNestedManyWithoutAccountsInput
    Careers?: CareersCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsCreateNestedManyWithoutAccountsInput
    Customers?: CustomersCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsCreateNestedManyWithoutAccountsInput
    Lands?: LandsCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutAccountsInput
    Orders?: OrdersCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsCreateNestedManyWithoutAccountsInput
    Posts?: PostsCreateNestedManyWithoutAccountsInput
    Reports?: ReportsCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsCreateNestedManyWithoutAccountsInput
    Tasks?: TasksCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsUncheckedCreateWithoutServicesInput = {
    id?: number
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    Alerts?: AlertsUncheckedCreateNestedManyWithoutAccountsInput
    Careers?: CareersUncheckedCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutAccountsInput
    Lands?: LandsUncheckedCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutAccountsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsUncheckedCreateNestedManyWithoutAccountsInput
    Posts?: PostsUncheckedCreateNestedManyWithoutAccountsInput
    Reports?: ReportsUncheckedCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsUncheckedCreateNestedManyWithoutAccountsInput
    Tasks?: TasksUncheckedCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsUncheckedCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsCreateOrConnectWithoutServicesInput = {
    where: AccountsWhereUniqueInput
    create: XOR<AccountsCreateWithoutServicesInput, AccountsUncheckedCreateWithoutServicesInput>
  }

  export type AccountsCreateManyServicesInputEnvelope = {
    data: Enumerable<AccountsCreateManyServicesInput>
    skipDuplicates?: boolean
  }

  export type AccountsUpsertWithWhereUniqueWithoutServicesInput = {
    where: AccountsWhereUniqueInput
    update: XOR<AccountsUpdateWithoutServicesInput, AccountsUncheckedUpdateWithoutServicesInput>
    create: XOR<AccountsCreateWithoutServicesInput, AccountsUncheckedCreateWithoutServicesInput>
  }

  export type AccountsUpdateWithWhereUniqueWithoutServicesInput = {
    where: AccountsWhereUniqueInput
    data: XOR<AccountsUpdateWithoutServicesInput, AccountsUncheckedUpdateWithoutServicesInput>
  }

  export type AccountsUpdateManyWithWhereWithoutServicesInput = {
    where: AccountsScalarWhereInput
    data: XOR<AccountsUpdateManyMutationInput, AccountsUncheckedUpdateManyWithoutAccountsInput>
  }

  export type AccountsScalarWhereInput = {
    AND?: Enumerable<AccountsScalarWhereInput>
    OR?: Enumerable<AccountsScalarWhereInput>
    NOT?: Enumerable<AccountsScalarWhereInput>
    id?: IntFilter | number
    phone?: StringNullableFilter | string | null
    verifyToken?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    profile?: JsonNullableFilter
    isAdmin?: BoolNullableFilter | boolean | null
    email?: StringNullableFilter | string | null
    password?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    isVerify?: BoolNullableFilter | boolean | null
    isApprove?: BoolNullableFilter | boolean | null
    ServiceKey?: StringNullableFilter | string | null
  }

  export type AccountsCreateWithoutStatisticsInput = {
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    Services?: ServicesCreateNestedOneWithoutAccountsInput
    Alerts?: AlertsCreateNestedManyWithoutAccountsInput
    Careers?: CareersCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsCreateNestedManyWithoutAccountsInput
    Customers?: CustomersCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsCreateNestedManyWithoutAccountsInput
    Lands?: LandsCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutAccountsInput
    Orders?: OrdersCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsCreateNestedManyWithoutAccountsInput
    Posts?: PostsCreateNestedManyWithoutAccountsInput
    Reports?: ReportsCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsCreateNestedManyWithoutAccountsInput
    Tasks?: TasksCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsUncheckedCreateWithoutStatisticsInput = {
    id?: number
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    ServiceKey?: string | null
    Alerts?: AlertsUncheckedCreateNestedManyWithoutAccountsInput
    Careers?: CareersUncheckedCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutAccountsInput
    Lands?: LandsUncheckedCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutAccountsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsUncheckedCreateNestedManyWithoutAccountsInput
    Posts?: PostsUncheckedCreateNestedManyWithoutAccountsInput
    Reports?: ReportsUncheckedCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsUncheckedCreateNestedManyWithoutAccountsInput
    Tasks?: TasksUncheckedCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsUncheckedCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsCreateOrConnectWithoutStatisticsInput = {
    where: AccountsWhereUniqueInput
    create: XOR<AccountsCreateWithoutStatisticsInput, AccountsUncheckedCreateWithoutStatisticsInput>
  }

  export type TasksCreateWithoutStatisticsInput = {
    name?: string | null
    status?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    workingDays?: number | null
    workingTeamsCnt?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    area?: Decimal | DecimalJsLike | number | string | null
    isPaid?: boolean | null
    createType?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: Decimal | DecimalJsLike | number | string | null
    Accounts?: AccountsCreateNestedOneWithoutTasksInput
    TaskGroups?: TaskGroupsCreateNestedOneWithoutTasksInput
    Reports?: ReportsCreateNestedManyWithoutTasksInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutTasksInput
    Teams?: TeamsCreateNestedManyWithoutTasksInput
  }

  export type TasksUncheckedCreateWithoutStatisticsInput = {
    id?: number
    name?: string | null
    status?: string | null
    AccountId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    workingDays?: number | null
    workingTeamsCnt?: number | null
    TaskGroupId?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    area?: Decimal | DecimalJsLike | number | string | null
    isPaid?: boolean | null
    createType?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: Decimal | DecimalJsLike | number | string | null
    Reports?: ReportsUncheckedCreateNestedManyWithoutTasksInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutTasksInput
    Teams?: TeamsUncheckedCreateNestedManyWithoutTasksInput
  }

  export type TasksCreateOrConnectWithoutStatisticsInput = {
    where: TasksWhereUniqueInput
    create: XOR<TasksCreateWithoutStatisticsInput, TasksUncheckedCreateWithoutStatisticsInput>
  }

  export type TeamsCreateWithoutStatisticsInput = {
    name?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    status?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    alias?: string | null
    Accounts_AccountsToTeams_AccountId?: AccountsCreateNestedOneWithoutTeams_AccountsToTeams_AccountIdInput
    Accounts_AccountsToTeams_AgentId?: AccountsCreateNestedOneWithoutTeams_AccountsToTeams_AgentIdInput
    Tasks?: TasksCreateNestedOneWithoutTeamsInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutTeamsInput
    TeamAgents?: TeamAgentsCreateNestedManyWithoutTeamsInput
  }

  export type TeamsUncheckedCreateWithoutStatisticsInput = {
    id?: number
    name?: string | null
    AccountId?: number | null
    AgentId?: number | null
    TaskId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    status?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    alias?: string | null
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutTeamsInput
    TeamAgents?: TeamAgentsUncheckedCreateNestedManyWithoutTeamsInput
  }

  export type TeamsCreateOrConnectWithoutStatisticsInput = {
    where: TeamsWhereUniqueInput
    create: XOR<TeamsCreateWithoutStatisticsInput, TeamsUncheckedCreateWithoutStatisticsInput>
  }

  export type AccountsUpsertWithoutStatisticsInput = {
    update: XOR<AccountsUpdateWithoutStatisticsInput, AccountsUncheckedUpdateWithoutStatisticsInput>
    create: XOR<AccountsCreateWithoutStatisticsInput, AccountsUncheckedCreateWithoutStatisticsInput>
  }

  export type AccountsUpdateWithoutStatisticsInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Services?: ServicesUpdateOneWithoutAccountsNestedInput
    Alerts?: AlertsUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsUncheckedUpdateWithoutStatisticsInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ServiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    Alerts?: AlertsUncheckedUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUncheckedUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUncheckedUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUncheckedUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUncheckedUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUncheckedUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUncheckedUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUncheckedUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUncheckedUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUncheckedUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type TasksUpsertWithoutStatisticsInput = {
    update: XOR<TasksUpdateWithoutStatisticsInput, TasksUncheckedUpdateWithoutStatisticsInput>
    create: XOR<TasksCreateWithoutStatisticsInput, TasksUncheckedCreateWithoutStatisticsInput>
  }

  export type TasksUpdateWithoutStatisticsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: NullableIntFieldUpdateOperationsInput | number | null
    workingTeamsCnt?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createType?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Accounts?: AccountsUpdateOneWithoutTasksNestedInput
    TaskGroups?: TaskGroupsUpdateOneWithoutTasksNestedInput
    Reports?: ReportsUpdateManyWithoutTasksNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutTasksNestedInput
    Teams?: TeamsUpdateManyWithoutTasksNestedInput
  }

  export type TasksUncheckedUpdateWithoutStatisticsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: NullableIntFieldUpdateOperationsInput | number | null
    workingTeamsCnt?: NullableIntFieldUpdateOperationsInput | number | null
    TaskGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createType?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Reports?: ReportsUncheckedUpdateManyWithoutTasksNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutTasksNestedInput
    Teams?: TeamsUncheckedUpdateManyWithoutTasksNestedInput
  }

  export type TeamsUpsertWithoutStatisticsInput = {
    update: XOR<TeamsUpdateWithoutStatisticsInput, TeamsUncheckedUpdateWithoutStatisticsInput>
    create: XOR<TeamsCreateWithoutStatisticsInput, TeamsUncheckedCreateWithoutStatisticsInput>
  }

  export type TeamsUpdateWithoutStatisticsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    Accounts_AccountsToTeams_AccountId?: AccountsUpdateOneWithoutTeams_AccountsToTeams_AccountIdNestedInput
    Accounts_AccountsToTeams_AgentId?: AccountsUpdateOneWithoutTeams_AccountsToTeams_AgentIdNestedInput
    Tasks?: TasksUpdateOneWithoutTeamsNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutTeamsNestedInput
    TeamAgents?: TeamAgentsUpdateManyWithoutTeamsNestedInput
  }

  export type TeamsUncheckedUpdateWithoutStatisticsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    AgentId?: NullableIntFieldUpdateOperationsInput | number | null
    TaskId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutTeamsNestedInput
    TeamAgents?: TeamAgentsUncheckedUpdateManyWithoutTeamsNestedInput
  }

  export type AccountsCreateWithoutSubscribesInput = {
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    Services?: ServicesCreateNestedOneWithoutAccountsInput
    Alerts?: AlertsCreateNestedManyWithoutAccountsInput
    Careers?: CareersCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsCreateNestedManyWithoutAccountsInput
    Customers?: CustomersCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsCreateNestedManyWithoutAccountsInput
    Lands?: LandsCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutAccountsInput
    Orders?: OrdersCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsCreateNestedManyWithoutAccountsInput
    Posts?: PostsCreateNestedManyWithoutAccountsInput
    Reports?: ReportsCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsCreateNestedManyWithoutAccountsInput
    Tasks?: TasksCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsUncheckedCreateWithoutSubscribesInput = {
    id?: number
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    ServiceKey?: string | null
    Alerts?: AlertsUncheckedCreateNestedManyWithoutAccountsInput
    Careers?: CareersUncheckedCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutAccountsInput
    Lands?: LandsUncheckedCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutAccountsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsUncheckedCreateNestedManyWithoutAccountsInput
    Posts?: PostsUncheckedCreateNestedManyWithoutAccountsInput
    Reports?: ReportsUncheckedCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsUncheckedCreateNestedManyWithoutAccountsInput
    Tasks?: TasksUncheckedCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsUncheckedCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsCreateOrConnectWithoutSubscribesInput = {
    where: AccountsWhereUniqueInput
    create: XOR<AccountsCreateWithoutSubscribesInput, AccountsUncheckedCreateWithoutSubscribesInput>
  }

  export type AccountsUpsertWithoutSubscribesInput = {
    update: XOR<AccountsUpdateWithoutSubscribesInput, AccountsUncheckedUpdateWithoutSubscribesInput>
    create: XOR<AccountsCreateWithoutSubscribesInput, AccountsUncheckedCreateWithoutSubscribesInput>
  }

  export type AccountsUpdateWithoutSubscribesInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Services?: ServicesUpdateOneWithoutAccountsNestedInput
    Alerts?: AlertsUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsUncheckedUpdateWithoutSubscribesInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ServiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    Alerts?: AlertsUncheckedUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUncheckedUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUncheckedUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUncheckedUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUncheckedUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUncheckedUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUncheckedUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUncheckedUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUncheckedUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUncheckedUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsCreateWithoutTaskDetailResourcesInput = {
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    Services?: ServicesCreateNestedOneWithoutAccountsInput
    Alerts?: AlertsCreateNestedManyWithoutAccountsInput
    Careers?: CareersCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsCreateNestedManyWithoutAccountsInput
    Customers?: CustomersCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsCreateNestedManyWithoutAccountsInput
    Lands?: LandsCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutAccountsInput
    Orders?: OrdersCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsCreateNestedManyWithoutAccountsInput
    Posts?: PostsCreateNestedManyWithoutAccountsInput
    Reports?: ReportsCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsCreateNestedManyWithoutAccountsInput
    Tasks?: TasksCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsUncheckedCreateWithoutTaskDetailResourcesInput = {
    id?: number
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    ServiceKey?: string | null
    Alerts?: AlertsUncheckedCreateNestedManyWithoutAccountsInput
    Careers?: CareersUncheckedCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutAccountsInput
    Lands?: LandsUncheckedCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutAccountsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsUncheckedCreateNestedManyWithoutAccountsInput
    Posts?: PostsUncheckedCreateNestedManyWithoutAccountsInput
    Reports?: ReportsUncheckedCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsUncheckedCreateNestedManyWithoutAccountsInput
    Tasks?: TasksUncheckedCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsUncheckedCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsCreateOrConnectWithoutTaskDetailResourcesInput = {
    where: AccountsWhereUniqueInput
    create: XOR<AccountsCreateWithoutTaskDetailResourcesInput, AccountsUncheckedCreateWithoutTaskDetailResourcesInput>
  }

  export type TaskDetailsCreateWithoutTaskDetailResourcesInput = {
    type?: string | null
    address?: string | null
    villageName?: string | null
    pushUser?: string | null
    category?: string | null
    etc?: string | null
    status?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    assignedDays?: number | null
    assignedUser?: string | null
    y?: string | null
    x?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    pushPhone?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    memo?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    Accounts?: AccountsCreateNestedOneWithoutTaskDetailsInput
    Tasks?: TasksCreateNestedOneWithoutTaskDetailsInput
    Teams?: TeamsCreateNestedOneWithoutTaskDetailsInput
  }

  export type TaskDetailsUncheckedCreateWithoutTaskDetailResourcesInput = {
    id?: number
    AccountId?: number | null
    TaskId?: number | null
    type?: string | null
    address?: string | null
    villageName?: string | null
    pushUser?: string | null
    category?: string | null
    etc?: string | null
    status?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    assignedDays?: number | null
    assignedUser?: string | null
    TeamId?: number | null
    y?: string | null
    x?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    pushPhone?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    memo?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TaskDetailsCreateOrConnectWithoutTaskDetailResourcesInput = {
    where: TaskDetailsWhereUniqueInput
    create: XOR<TaskDetailsCreateWithoutTaskDetailResourcesInput, TaskDetailsUncheckedCreateWithoutTaskDetailResourcesInput>
  }

  export type AccountsUpsertWithoutTaskDetailResourcesInput = {
    update: XOR<AccountsUpdateWithoutTaskDetailResourcesInput, AccountsUncheckedUpdateWithoutTaskDetailResourcesInput>
    create: XOR<AccountsCreateWithoutTaskDetailResourcesInput, AccountsUncheckedCreateWithoutTaskDetailResourcesInput>
  }

  export type AccountsUpdateWithoutTaskDetailResourcesInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Services?: ServicesUpdateOneWithoutAccountsNestedInput
    Alerts?: AlertsUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsUncheckedUpdateWithoutTaskDetailResourcesInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ServiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    Alerts?: AlertsUncheckedUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUncheckedUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUncheckedUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUncheckedUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUncheckedUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUncheckedUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUncheckedUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUncheckedUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUncheckedUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUncheckedUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUncheckedUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type TaskDetailsUpsertWithoutTaskDetailResourcesInput = {
    update: XOR<TaskDetailsUpdateWithoutTaskDetailResourcesInput, TaskDetailsUncheckedUpdateWithoutTaskDetailResourcesInput>
    create: XOR<TaskDetailsCreateWithoutTaskDetailResourcesInput, TaskDetailsUncheckedCreateWithoutTaskDetailResourcesInput>
  }

  export type TaskDetailsUpdateWithoutTaskDetailResourcesInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    villageName?: NullableStringFieldUpdateOperationsInput | string | null
    pushUser?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    etc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedDays?: NullableIntFieldUpdateOperationsInput | number | null
    assignedUser?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pushPhone?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    Accounts?: AccountsUpdateOneWithoutTaskDetailsNestedInput
    Tasks?: TasksUpdateOneWithoutTaskDetailsNestedInput
    Teams?: TeamsUpdateOneWithoutTaskDetailsNestedInput
  }

  export type TaskDetailsUncheckedUpdateWithoutTaskDetailResourcesInput = {
    id?: IntFieldUpdateOperationsInput | number
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    TaskId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    villageName?: NullableStringFieldUpdateOperationsInput | string | null
    pushUser?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    etc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedDays?: NullableIntFieldUpdateOperationsInput | number | null
    assignedUser?: NullableStringFieldUpdateOperationsInput | string | null
    TeamId?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pushPhone?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AccountsCreateWithoutTaskDetailsInput = {
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    Services?: ServicesCreateNestedOneWithoutAccountsInput
    Alerts?: AlertsCreateNestedManyWithoutAccountsInput
    Careers?: CareersCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsCreateNestedManyWithoutAccountsInput
    Customers?: CustomersCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsCreateNestedManyWithoutAccountsInput
    Lands?: LandsCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutAccountsInput
    Orders?: OrdersCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsCreateNestedManyWithoutAccountsInput
    Posts?: PostsCreateNestedManyWithoutAccountsInput
    Reports?: ReportsCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsCreateNestedManyWithoutAccountsInput
    Tasks?: TasksCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsUncheckedCreateWithoutTaskDetailsInput = {
    id?: number
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    ServiceKey?: string | null
    Alerts?: AlertsUncheckedCreateNestedManyWithoutAccountsInput
    Careers?: CareersUncheckedCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutAccountsInput
    Lands?: LandsUncheckedCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutAccountsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsUncheckedCreateNestedManyWithoutAccountsInput
    Posts?: PostsUncheckedCreateNestedManyWithoutAccountsInput
    Reports?: ReportsUncheckedCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesUncheckedCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsUncheckedCreateNestedManyWithoutAccountsInput
    Tasks?: TasksUncheckedCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsUncheckedCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsCreateOrConnectWithoutTaskDetailsInput = {
    where: AccountsWhereUniqueInput
    create: XOR<AccountsCreateWithoutTaskDetailsInput, AccountsUncheckedCreateWithoutTaskDetailsInput>
  }

  export type TasksCreateWithoutTaskDetailsInput = {
    name?: string | null
    status?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    workingDays?: number | null
    workingTeamsCnt?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    area?: Decimal | DecimalJsLike | number | string | null
    isPaid?: boolean | null
    createType?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: Decimal | DecimalJsLike | number | string | null
    Accounts?: AccountsCreateNestedOneWithoutTasksInput
    TaskGroups?: TaskGroupsCreateNestedOneWithoutTasksInput
    Reports?: ReportsCreateNestedManyWithoutTasksInput
    Statistics?: StatisticsCreateNestedManyWithoutTasksInput
    Teams?: TeamsCreateNestedManyWithoutTasksInput
  }

  export type TasksUncheckedCreateWithoutTaskDetailsInput = {
    id?: number
    name?: string | null
    status?: string | null
    AccountId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    workingDays?: number | null
    workingTeamsCnt?: number | null
    TaskGroupId?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    area?: Decimal | DecimalJsLike | number | string | null
    isPaid?: boolean | null
    createType?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: Decimal | DecimalJsLike | number | string | null
    Reports?: ReportsUncheckedCreateNestedManyWithoutTasksInput
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutTasksInput
    Teams?: TeamsUncheckedCreateNestedManyWithoutTasksInput
  }

  export type TasksCreateOrConnectWithoutTaskDetailsInput = {
    where: TasksWhereUniqueInput
    create: XOR<TasksCreateWithoutTaskDetailsInput, TasksUncheckedCreateWithoutTaskDetailsInput>
  }

  export type TeamsCreateWithoutTaskDetailsInput = {
    name?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    status?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    alias?: string | null
    Accounts_AccountsToTeams_AccountId?: AccountsCreateNestedOneWithoutTeams_AccountsToTeams_AccountIdInput
    Accounts_AccountsToTeams_AgentId?: AccountsCreateNestedOneWithoutTeams_AccountsToTeams_AgentIdInput
    Tasks?: TasksCreateNestedOneWithoutTeamsInput
    Statistics?: StatisticsCreateNestedManyWithoutTeamsInput
    TeamAgents?: TeamAgentsCreateNestedManyWithoutTeamsInput
  }

  export type TeamsUncheckedCreateWithoutTaskDetailsInput = {
    id?: number
    name?: string | null
    AccountId?: number | null
    AgentId?: number | null
    TaskId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    status?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    alias?: string | null
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutTeamsInput
    TeamAgents?: TeamAgentsUncheckedCreateNestedManyWithoutTeamsInput
  }

  export type TeamsCreateOrConnectWithoutTaskDetailsInput = {
    where: TeamsWhereUniqueInput
    create: XOR<TeamsCreateWithoutTaskDetailsInput, TeamsUncheckedCreateWithoutTaskDetailsInput>
  }

  export type TaskDetailResourcesCreateWithoutTaskDetailsInput = {
    content?: string | null
    type?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    group?: string | null
    Accounts?: AccountsCreateNestedOneWithoutTaskDetailResourcesInput
  }

  export type TaskDetailResourcesUncheckedCreateWithoutTaskDetailsInput = {
    id?: number
    content?: string | null
    type?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    AccountId?: number | null
    group?: string | null
  }

  export type TaskDetailResourcesCreateOrConnectWithoutTaskDetailsInput = {
    where: TaskDetailResourcesWhereUniqueInput
    create: XOR<TaskDetailResourcesCreateWithoutTaskDetailsInput, TaskDetailResourcesUncheckedCreateWithoutTaskDetailsInput>
  }

  export type TaskDetailResourcesCreateManyTaskDetailsInputEnvelope = {
    data: Enumerable<TaskDetailResourcesCreateManyTaskDetailsInput>
    skipDuplicates?: boolean
  }

  export type AccountsUpsertWithoutTaskDetailsInput = {
    update: XOR<AccountsUpdateWithoutTaskDetailsInput, AccountsUncheckedUpdateWithoutTaskDetailsInput>
    create: XOR<AccountsCreateWithoutTaskDetailsInput, AccountsUncheckedCreateWithoutTaskDetailsInput>
  }

  export type AccountsUpdateWithoutTaskDetailsInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Services?: ServicesUpdateOneWithoutAccountsNestedInput
    Alerts?: AlertsUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsUncheckedUpdateWithoutTaskDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ServiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    Alerts?: AlertsUncheckedUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUncheckedUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUncheckedUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUncheckedUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUncheckedUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUncheckedUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUncheckedUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUncheckedUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUncheckedUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUncheckedUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUncheckedUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type TasksUpsertWithoutTaskDetailsInput = {
    update: XOR<TasksUpdateWithoutTaskDetailsInput, TasksUncheckedUpdateWithoutTaskDetailsInput>
    create: XOR<TasksCreateWithoutTaskDetailsInput, TasksUncheckedCreateWithoutTaskDetailsInput>
  }

  export type TasksUpdateWithoutTaskDetailsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: NullableIntFieldUpdateOperationsInput | number | null
    workingTeamsCnt?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createType?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Accounts?: AccountsUpdateOneWithoutTasksNestedInput
    TaskGroups?: TaskGroupsUpdateOneWithoutTasksNestedInput
    Reports?: ReportsUpdateManyWithoutTasksNestedInput
    Statistics?: StatisticsUpdateManyWithoutTasksNestedInput
    Teams?: TeamsUpdateManyWithoutTasksNestedInput
  }

  export type TasksUncheckedUpdateWithoutTaskDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: NullableIntFieldUpdateOperationsInput | number | null
    workingTeamsCnt?: NullableIntFieldUpdateOperationsInput | number | null
    TaskGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createType?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Reports?: ReportsUncheckedUpdateManyWithoutTasksNestedInput
    Statistics?: StatisticsUncheckedUpdateManyWithoutTasksNestedInput
    Teams?: TeamsUncheckedUpdateManyWithoutTasksNestedInput
  }

  export type TeamsUpsertWithoutTaskDetailsInput = {
    update: XOR<TeamsUpdateWithoutTaskDetailsInput, TeamsUncheckedUpdateWithoutTaskDetailsInput>
    create: XOR<TeamsCreateWithoutTaskDetailsInput, TeamsUncheckedCreateWithoutTaskDetailsInput>
  }

  export type TeamsUpdateWithoutTaskDetailsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    Accounts_AccountsToTeams_AccountId?: AccountsUpdateOneWithoutTeams_AccountsToTeams_AccountIdNestedInput
    Accounts_AccountsToTeams_AgentId?: AccountsUpdateOneWithoutTeams_AccountsToTeams_AgentIdNestedInput
    Tasks?: TasksUpdateOneWithoutTeamsNestedInput
    Statistics?: StatisticsUpdateManyWithoutTeamsNestedInput
    TeamAgents?: TeamAgentsUpdateManyWithoutTeamsNestedInput
  }

  export type TeamsUncheckedUpdateWithoutTaskDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    AgentId?: NullableIntFieldUpdateOperationsInput | number | null
    TaskId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    Statistics?: StatisticsUncheckedUpdateManyWithoutTeamsNestedInput
    TeamAgents?: TeamAgentsUncheckedUpdateManyWithoutTeamsNestedInput
  }

  export type TaskDetailResourcesUpsertWithWhereUniqueWithoutTaskDetailsInput = {
    where: TaskDetailResourcesWhereUniqueInput
    update: XOR<TaskDetailResourcesUpdateWithoutTaskDetailsInput, TaskDetailResourcesUncheckedUpdateWithoutTaskDetailsInput>
    create: XOR<TaskDetailResourcesCreateWithoutTaskDetailsInput, TaskDetailResourcesUncheckedCreateWithoutTaskDetailsInput>
  }

  export type TaskDetailResourcesUpdateWithWhereUniqueWithoutTaskDetailsInput = {
    where: TaskDetailResourcesWhereUniqueInput
    data: XOR<TaskDetailResourcesUpdateWithoutTaskDetailsInput, TaskDetailResourcesUncheckedUpdateWithoutTaskDetailsInput>
  }

  export type TaskDetailResourcesUpdateManyWithWhereWithoutTaskDetailsInput = {
    where: TaskDetailResourcesScalarWhereInput
    data: XOR<TaskDetailResourcesUpdateManyMutationInput, TaskDetailResourcesUncheckedUpdateManyWithoutTaskDetailResourcesInput>
  }

  export type AccountsCreateWithoutTaskGroupsInput = {
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    Services?: ServicesCreateNestedOneWithoutAccountsInput
    Alerts?: AlertsCreateNestedManyWithoutAccountsInput
    Careers?: CareersCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsCreateNestedManyWithoutAccountsInput
    Customers?: CustomersCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsCreateNestedManyWithoutAccountsInput
    Lands?: LandsCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutAccountsInput
    Orders?: OrdersCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsCreateNestedManyWithoutAccountsInput
    Posts?: PostsCreateNestedManyWithoutAccountsInput
    Reports?: ReportsCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutAccountsInput
    Tasks?: TasksCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsUncheckedCreateWithoutTaskGroupsInput = {
    id?: number
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    ServiceKey?: string | null
    Alerts?: AlertsUncheckedCreateNestedManyWithoutAccountsInput
    Careers?: CareersUncheckedCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutAccountsInput
    Lands?: LandsUncheckedCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutAccountsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsUncheckedCreateNestedManyWithoutAccountsInput
    Posts?: PostsUncheckedCreateNestedManyWithoutAccountsInput
    Reports?: ReportsUncheckedCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    Tasks?: TasksUncheckedCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsUncheckedCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsCreateOrConnectWithoutTaskGroupsInput = {
    where: AccountsWhereUniqueInput
    create: XOR<AccountsCreateWithoutTaskGroupsInput, AccountsUncheckedCreateWithoutTaskGroupsInput>
  }

  export type TasksCreateWithoutTaskGroupsInput = {
    name?: string | null
    status?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    workingDays?: number | null
    workingTeamsCnt?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    area?: Decimal | DecimalJsLike | number | string | null
    isPaid?: boolean | null
    createType?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: Decimal | DecimalJsLike | number | string | null
    Accounts?: AccountsCreateNestedOneWithoutTasksInput
    Reports?: ReportsCreateNestedManyWithoutTasksInput
    Statistics?: StatisticsCreateNestedManyWithoutTasksInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutTasksInput
    Teams?: TeamsCreateNestedManyWithoutTasksInput
  }

  export type TasksUncheckedCreateWithoutTaskGroupsInput = {
    id?: number
    name?: string | null
    status?: string | null
    AccountId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    workingDays?: number | null
    workingTeamsCnt?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    area?: Decimal | DecimalJsLike | number | string | null
    isPaid?: boolean | null
    createType?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: Decimal | DecimalJsLike | number | string | null
    Reports?: ReportsUncheckedCreateNestedManyWithoutTasksInput
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutTasksInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutTasksInput
    Teams?: TeamsUncheckedCreateNestedManyWithoutTasksInput
  }

  export type TasksCreateOrConnectWithoutTaskGroupsInput = {
    where: TasksWhereUniqueInput
    create: XOR<TasksCreateWithoutTaskGroupsInput, TasksUncheckedCreateWithoutTaskGroupsInput>
  }

  export type TasksCreateManyTaskGroupsInputEnvelope = {
    data: Enumerable<TasksCreateManyTaskGroupsInput>
    skipDuplicates?: boolean
  }

  export type AccountsUpsertWithoutTaskGroupsInput = {
    update: XOR<AccountsUpdateWithoutTaskGroupsInput, AccountsUncheckedUpdateWithoutTaskGroupsInput>
    create: XOR<AccountsCreateWithoutTaskGroupsInput, AccountsUncheckedCreateWithoutTaskGroupsInput>
  }

  export type AccountsUpdateWithoutTaskGroupsInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Services?: ServicesUpdateOneWithoutAccountsNestedInput
    Alerts?: AlertsUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsUncheckedUpdateWithoutTaskGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ServiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    Alerts?: AlertsUncheckedUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUncheckedUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUncheckedUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUncheckedUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUncheckedUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUncheckedUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUncheckedUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUncheckedUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUncheckedUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUncheckedUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type TasksUpsertWithWhereUniqueWithoutTaskGroupsInput = {
    where: TasksWhereUniqueInput
    update: XOR<TasksUpdateWithoutTaskGroupsInput, TasksUncheckedUpdateWithoutTaskGroupsInput>
    create: XOR<TasksCreateWithoutTaskGroupsInput, TasksUncheckedCreateWithoutTaskGroupsInput>
  }

  export type TasksUpdateWithWhereUniqueWithoutTaskGroupsInput = {
    where: TasksWhereUniqueInput
    data: XOR<TasksUpdateWithoutTaskGroupsInput, TasksUncheckedUpdateWithoutTaskGroupsInput>
  }

  export type TasksUpdateManyWithWhereWithoutTaskGroupsInput = {
    where: TasksScalarWhereInput
    data: XOR<TasksUpdateManyMutationInput, TasksUncheckedUpdateManyWithoutTasksInput>
  }

  export type AccountsCreateWithoutTasksInput = {
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    Services?: ServicesCreateNestedOneWithoutAccountsInput
    Alerts?: AlertsCreateNestedManyWithoutAccountsInput
    Careers?: CareersCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsCreateNestedManyWithoutAccountsInput
    Customers?: CustomersCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsCreateNestedManyWithoutAccountsInput
    Lands?: LandsCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutAccountsInput
    Orders?: OrdersCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsCreateNestedManyWithoutAccountsInput
    Posts?: PostsCreateNestedManyWithoutAccountsInput
    Reports?: ReportsCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsUncheckedCreateWithoutTasksInput = {
    id?: number
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    ServiceKey?: string | null
    Alerts?: AlertsUncheckedCreateNestedManyWithoutAccountsInput
    Careers?: CareersUncheckedCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutAccountsInput
    Lands?: LandsUncheckedCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutAccountsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsUncheckedCreateNestedManyWithoutAccountsInput
    Posts?: PostsUncheckedCreateNestedManyWithoutAccountsInput
    Reports?: ReportsUncheckedCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsUncheckedCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsUncheckedCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsCreateOrConnectWithoutTasksInput = {
    where: AccountsWhereUniqueInput
    create: XOR<AccountsCreateWithoutTasksInput, AccountsUncheckedCreateWithoutTasksInput>
  }

  export type TaskGroupsCreateWithoutTasksInput = {
    path?: string | null
    name?: string | null
    status?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    area?: Decimal | DecimalJsLike | number | string | null
    createType?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    Accounts?: AccountsCreateNestedOneWithoutTaskGroupsInput
  }

  export type TaskGroupsUncheckedCreateWithoutTasksInput = {
    id?: number
    path?: string | null
    name?: string | null
    status?: string | null
    AccountId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    area?: Decimal | DecimalJsLike | number | string | null
    createType?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TaskGroupsCreateOrConnectWithoutTasksInput = {
    where: TaskGroupsWhereUniqueInput
    create: XOR<TaskGroupsCreateWithoutTasksInput, TaskGroupsUncheckedCreateWithoutTasksInput>
  }

  export type ReportsCreateWithoutTasksInput = {
    name?: string | null
    isActive?: boolean | null
    isPrivate?: boolean | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    Accounts?: AccountsCreateNestedOneWithoutReportsInput
  }

  export type ReportsUncheckedCreateWithoutTasksInput = {
    id?: number
    name?: string | null
    isActive?: boolean | null
    isPrivate?: boolean | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    AccountId?: number | null
  }

  export type ReportsCreateOrConnectWithoutTasksInput = {
    where: ReportsWhereUniqueInput
    create: XOR<ReportsCreateWithoutTasksInput, ReportsUncheckedCreateWithoutTasksInput>
  }

  export type ReportsCreateManyTasksInputEnvelope = {
    data: Enumerable<ReportsCreateManyTasksInput>
    skipDuplicates?: boolean
  }

  export type StatisticsCreateWithoutTasksInput = {
    dailyWorkload?: Decimal | DecimalJsLike | number | string | null
    completedByOwner?: Decimal | DecimalJsLike | number | string | null
    completedBySelf?: Decimal | DecimalJsLike | number | string | null
    createdAt: Date | string
    updatedAt: Date | string
    Accounts?: AccountsCreateNestedOneWithoutStatisticsInput
    Teams?: TeamsCreateNestedOneWithoutStatisticsInput
  }

  export type StatisticsUncheckedCreateWithoutTasksInput = {
    id?: number
    AgentId?: number | null
    TeamId?: number | null
    dailyWorkload?: Decimal | DecimalJsLike | number | string | null
    completedByOwner?: Decimal | DecimalJsLike | number | string | null
    completedBySelf?: Decimal | DecimalJsLike | number | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type StatisticsCreateOrConnectWithoutTasksInput = {
    where: StatisticsWhereUniqueInput
    create: XOR<StatisticsCreateWithoutTasksInput, StatisticsUncheckedCreateWithoutTasksInput>
  }

  export type StatisticsCreateManyTasksInputEnvelope = {
    data: Enumerable<StatisticsCreateManyTasksInput>
    skipDuplicates?: boolean
  }

  export type TaskDetailsCreateWithoutTasksInput = {
    type?: string | null
    address?: string | null
    villageName?: string | null
    pushUser?: string | null
    category?: string | null
    etc?: string | null
    status?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    assignedDays?: number | null
    assignedUser?: string | null
    y?: string | null
    x?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    pushPhone?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    memo?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    Accounts?: AccountsCreateNestedOneWithoutTaskDetailsInput
    Teams?: TeamsCreateNestedOneWithoutTaskDetailsInput
    TaskDetailResources?: TaskDetailResourcesCreateNestedManyWithoutTaskDetailsInput
  }

  export type TaskDetailsUncheckedCreateWithoutTasksInput = {
    id?: number
    AccountId?: number | null
    type?: string | null
    address?: string | null
    villageName?: string | null
    pushUser?: string | null
    category?: string | null
    etc?: string | null
    status?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    assignedDays?: number | null
    assignedUser?: string | null
    TeamId?: number | null
    y?: string | null
    x?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    pushPhone?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    memo?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    TaskDetailResources?: TaskDetailResourcesUncheckedCreateNestedManyWithoutTaskDetailsInput
  }

  export type TaskDetailsCreateOrConnectWithoutTasksInput = {
    where: TaskDetailsWhereUniqueInput
    create: XOR<TaskDetailsCreateWithoutTasksInput, TaskDetailsUncheckedCreateWithoutTasksInput>
  }

  export type TaskDetailsCreateManyTasksInputEnvelope = {
    data: Enumerable<TaskDetailsCreateManyTasksInput>
    skipDuplicates?: boolean
  }

  export type TeamsCreateWithoutTasksInput = {
    name?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    status?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    alias?: string | null
    Accounts_AccountsToTeams_AccountId?: AccountsCreateNestedOneWithoutTeams_AccountsToTeams_AccountIdInput
    Accounts_AccountsToTeams_AgentId?: AccountsCreateNestedOneWithoutTeams_AccountsToTeams_AgentIdInput
    Statistics?: StatisticsCreateNestedManyWithoutTeamsInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutTeamsInput
    TeamAgents?: TeamAgentsCreateNestedManyWithoutTeamsInput
  }

  export type TeamsUncheckedCreateWithoutTasksInput = {
    id?: number
    name?: string | null
    AccountId?: number | null
    AgentId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    status?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    alias?: string | null
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutTeamsInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutTeamsInput
    TeamAgents?: TeamAgentsUncheckedCreateNestedManyWithoutTeamsInput
  }

  export type TeamsCreateOrConnectWithoutTasksInput = {
    where: TeamsWhereUniqueInput
    create: XOR<TeamsCreateWithoutTasksInput, TeamsUncheckedCreateWithoutTasksInput>
  }

  export type TeamsCreateManyTasksInputEnvelope = {
    data: Enumerable<TeamsCreateManyTasksInput>
    skipDuplicates?: boolean
  }

  export type AccountsUpsertWithoutTasksInput = {
    update: XOR<AccountsUpdateWithoutTasksInput, AccountsUncheckedUpdateWithoutTasksInput>
    create: XOR<AccountsCreateWithoutTasksInput, AccountsUncheckedCreateWithoutTasksInput>
  }

  export type AccountsUpdateWithoutTasksInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Services?: ServicesUpdateOneWithoutAccountsNestedInput
    Alerts?: AlertsUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ServiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    Alerts?: AlertsUncheckedUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUncheckedUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUncheckedUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUncheckedUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUncheckedUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUncheckedUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUncheckedUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUncheckedUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUncheckedUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUncheckedUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type TaskGroupsUpsertWithoutTasksInput = {
    update: XOR<TaskGroupsUpdateWithoutTasksInput, TaskGroupsUncheckedUpdateWithoutTasksInput>
    create: XOR<TaskGroupsCreateWithoutTasksInput, TaskGroupsUncheckedCreateWithoutTasksInput>
  }

  export type TaskGroupsUpdateWithoutTasksInput = {
    path?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createType?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    Accounts?: AccountsUpdateOneWithoutTaskGroupsNestedInput
  }

  export type TaskGroupsUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createType?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ReportsUpsertWithWhereUniqueWithoutTasksInput = {
    where: ReportsWhereUniqueInput
    update: XOR<ReportsUpdateWithoutTasksInput, ReportsUncheckedUpdateWithoutTasksInput>
    create: XOR<ReportsCreateWithoutTasksInput, ReportsUncheckedCreateWithoutTasksInput>
  }

  export type ReportsUpdateWithWhereUniqueWithoutTasksInput = {
    where: ReportsWhereUniqueInput
    data: XOR<ReportsUpdateWithoutTasksInput, ReportsUncheckedUpdateWithoutTasksInput>
  }

  export type ReportsUpdateManyWithWhereWithoutTasksInput = {
    where: ReportsScalarWhereInput
    data: XOR<ReportsUpdateManyMutationInput, ReportsUncheckedUpdateManyWithoutReportsInput>
  }

  export type StatisticsUpsertWithWhereUniqueWithoutTasksInput = {
    where: StatisticsWhereUniqueInput
    update: XOR<StatisticsUpdateWithoutTasksInput, StatisticsUncheckedUpdateWithoutTasksInput>
    create: XOR<StatisticsCreateWithoutTasksInput, StatisticsUncheckedCreateWithoutTasksInput>
  }

  export type StatisticsUpdateWithWhereUniqueWithoutTasksInput = {
    where: StatisticsWhereUniqueInput
    data: XOR<StatisticsUpdateWithoutTasksInput, StatisticsUncheckedUpdateWithoutTasksInput>
  }

  export type StatisticsUpdateManyWithWhereWithoutTasksInput = {
    where: StatisticsScalarWhereInput
    data: XOR<StatisticsUpdateManyMutationInput, StatisticsUncheckedUpdateManyWithoutStatisticsInput>
  }

  export type TaskDetailsUpsertWithWhereUniqueWithoutTasksInput = {
    where: TaskDetailsWhereUniqueInput
    update: XOR<TaskDetailsUpdateWithoutTasksInput, TaskDetailsUncheckedUpdateWithoutTasksInput>
    create: XOR<TaskDetailsCreateWithoutTasksInput, TaskDetailsUncheckedCreateWithoutTasksInput>
  }

  export type TaskDetailsUpdateWithWhereUniqueWithoutTasksInput = {
    where: TaskDetailsWhereUniqueInput
    data: XOR<TaskDetailsUpdateWithoutTasksInput, TaskDetailsUncheckedUpdateWithoutTasksInput>
  }

  export type TaskDetailsUpdateManyWithWhereWithoutTasksInput = {
    where: TaskDetailsScalarWhereInput
    data: XOR<TaskDetailsUpdateManyMutationInput, TaskDetailsUncheckedUpdateManyWithoutTaskDetailsInput>
  }

  export type TeamsUpsertWithWhereUniqueWithoutTasksInput = {
    where: TeamsWhereUniqueInput
    update: XOR<TeamsUpdateWithoutTasksInput, TeamsUncheckedUpdateWithoutTasksInput>
    create: XOR<TeamsCreateWithoutTasksInput, TeamsUncheckedCreateWithoutTasksInput>
  }

  export type TeamsUpdateWithWhereUniqueWithoutTasksInput = {
    where: TeamsWhereUniqueInput
    data: XOR<TeamsUpdateWithoutTasksInput, TeamsUncheckedUpdateWithoutTasksInput>
  }

  export type TeamsUpdateManyWithWhereWithoutTasksInput = {
    where: TeamsScalarWhereInput
    data: XOR<TeamsUpdateManyMutationInput, TeamsUncheckedUpdateManyWithoutTeamsInput>
  }

  export type AccountsCreateWithoutTeamAgentsInput = {
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    Services?: ServicesCreateNestedOneWithoutAccountsInput
    Alerts?: AlertsCreateNestedManyWithoutAccountsInput
    Careers?: CareersCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsCreateNestedManyWithoutAccountsInput
    Customers?: CustomersCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsCreateNestedManyWithoutAccountsInput
    Lands?: LandsCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutAccountsInput
    Orders?: OrdersCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsCreateNestedManyWithoutAccountsInput
    Posts?: PostsCreateNestedManyWithoutAccountsInput
    Reports?: ReportsCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsCreateNestedManyWithoutAccountsInput
    Tasks?: TasksCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsUncheckedCreateWithoutTeamAgentsInput = {
    id?: number
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    ServiceKey?: string | null
    Alerts?: AlertsUncheckedCreateNestedManyWithoutAccountsInput
    Careers?: CareersUncheckedCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutAccountsInput
    Lands?: LandsUncheckedCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutAccountsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsUncheckedCreateNestedManyWithoutAccountsInput
    Posts?: PostsUncheckedCreateNestedManyWithoutAccountsInput
    Reports?: ReportsUncheckedCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsUncheckedCreateNestedManyWithoutAccountsInput
    Tasks?: TasksUncheckedCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsCreateOrConnectWithoutTeamAgentsInput = {
    where: AccountsWhereUniqueInput
    create: XOR<AccountsCreateWithoutTeamAgentsInput, AccountsUncheckedCreateWithoutTeamAgentsInput>
  }

  export type TeamsCreateWithoutTeamAgentsInput = {
    name?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    status?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    alias?: string | null
    Accounts_AccountsToTeams_AccountId?: AccountsCreateNestedOneWithoutTeams_AccountsToTeams_AccountIdInput
    Accounts_AccountsToTeams_AgentId?: AccountsCreateNestedOneWithoutTeams_AccountsToTeams_AgentIdInput
    Tasks?: TasksCreateNestedOneWithoutTeamsInput
    Statistics?: StatisticsCreateNestedManyWithoutTeamsInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutTeamsInput
  }

  export type TeamsUncheckedCreateWithoutTeamAgentsInput = {
    id?: number
    name?: string | null
    AccountId?: number | null
    AgentId?: number | null
    TaskId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    status?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    alias?: string | null
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutTeamsInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutTeamsInput
  }

  export type TeamsCreateOrConnectWithoutTeamAgentsInput = {
    where: TeamsWhereUniqueInput
    create: XOR<TeamsCreateWithoutTeamAgentsInput, TeamsUncheckedCreateWithoutTeamAgentsInput>
  }

  export type AccountsUpsertWithoutTeamAgentsInput = {
    update: XOR<AccountsUpdateWithoutTeamAgentsInput, AccountsUncheckedUpdateWithoutTeamAgentsInput>
    create: XOR<AccountsCreateWithoutTeamAgentsInput, AccountsUncheckedCreateWithoutTeamAgentsInput>
  }

  export type AccountsUpdateWithoutTeamAgentsInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Services?: ServicesUpdateOneWithoutAccountsNestedInput
    Alerts?: AlertsUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsUncheckedUpdateWithoutTeamAgentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ServiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    Alerts?: AlertsUncheckedUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUncheckedUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUncheckedUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUncheckedUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUncheckedUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUncheckedUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUncheckedUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUncheckedUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUncheckedUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUncheckedUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type TeamsUpsertWithoutTeamAgentsInput = {
    update: XOR<TeamsUpdateWithoutTeamAgentsInput, TeamsUncheckedUpdateWithoutTeamAgentsInput>
    create: XOR<TeamsCreateWithoutTeamAgentsInput, TeamsUncheckedCreateWithoutTeamAgentsInput>
  }

  export type TeamsUpdateWithoutTeamAgentsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    Accounts_AccountsToTeams_AccountId?: AccountsUpdateOneWithoutTeams_AccountsToTeams_AccountIdNestedInput
    Accounts_AccountsToTeams_AgentId?: AccountsUpdateOneWithoutTeams_AccountsToTeams_AgentIdNestedInput
    Tasks?: TasksUpdateOneWithoutTeamsNestedInput
    Statistics?: StatisticsUpdateManyWithoutTeamsNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutTeamsNestedInput
  }

  export type TeamsUncheckedUpdateWithoutTeamAgentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    AgentId?: NullableIntFieldUpdateOperationsInput | number | null
    TaskId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    Statistics?: StatisticsUncheckedUpdateManyWithoutTeamsNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutTeamsNestedInput
  }

  export type AccountsCreateWithoutTeams_AccountsToTeams_AccountIdInput = {
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    Services?: ServicesCreateNestedOneWithoutAccountsInput
    Alerts?: AlertsCreateNestedManyWithoutAccountsInput
    Careers?: CareersCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsCreateNestedManyWithoutAccountsInput
    Customers?: CustomersCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsCreateNestedManyWithoutAccountsInput
    Lands?: LandsCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutAccountsInput
    Orders?: OrdersCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsCreateNestedManyWithoutAccountsInput
    Posts?: PostsCreateNestedManyWithoutAccountsInput
    Reports?: ReportsCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsCreateNestedManyWithoutAccountsInput
    Tasks?: TasksCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AgentId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsUncheckedCreateWithoutTeams_AccountsToTeams_AccountIdInput = {
    id?: number
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    ServiceKey?: string | null
    Alerts?: AlertsUncheckedCreateNestedManyWithoutAccountsInput
    Careers?: CareersUncheckedCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutAccountsInput
    Lands?: LandsUncheckedCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutAccountsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsUncheckedCreateNestedManyWithoutAccountsInput
    Posts?: PostsUncheckedCreateNestedManyWithoutAccountsInput
    Reports?: ReportsUncheckedCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsUncheckedCreateNestedManyWithoutAccountsInput
    Tasks?: TasksUncheckedCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsUncheckedCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AgentIdInput
  }

  export type AccountsCreateOrConnectWithoutTeams_AccountsToTeams_AccountIdInput = {
    where: AccountsWhereUniqueInput
    create: XOR<AccountsCreateWithoutTeams_AccountsToTeams_AccountIdInput, AccountsUncheckedCreateWithoutTeams_AccountsToTeams_AccountIdInput>
  }

  export type AccountsCreateWithoutTeams_AccountsToTeams_AgentIdInput = {
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    Services?: ServicesCreateNestedOneWithoutAccountsInput
    Alerts?: AlertsCreateNestedManyWithoutAccountsInput
    Careers?: CareersCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsCreateNestedManyWithoutAccountsInput
    Customers?: CustomersCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsCreateNestedManyWithoutAccountsInput
    Lands?: LandsCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesCreateNestedManyWithoutAccountsInput
    Orders?: OrdersCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsCreateNestedManyWithoutAccountsInput
    Posts?: PostsCreateNestedManyWithoutAccountsInput
    Reports?: ReportsCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsCreateNestedManyWithoutAccountsInput
    Tasks?: TasksCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
  }

  export type AccountsUncheckedCreateWithoutTeams_AccountsToTeams_AgentIdInput = {
    id?: number
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
    ServiceKey?: string | null
    Alerts?: AlertsUncheckedCreateNestedManyWithoutAccountsInput
    Careers?: CareersUncheckedCreateNestedManyWithoutAccountsInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutAccountsInput
    Discounts?: DiscountsUncheckedCreateNestedManyWithoutAccountsInput
    Lands?: LandsUncheckedCreateNestedManyWithoutAccountsInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutAccountsInput
    OrderHistories?: OrderHistoriesUncheckedCreateNestedManyWithoutAccountsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutAccountsInput
    PostAccounts?: PostAccountsUncheckedCreateNestedManyWithoutAccountsInput
    Posts?: PostsUncheckedCreateNestedManyWithoutAccountsInput
    Reports?: ReportsUncheckedCreateNestedManyWithoutAccountsInput
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutAccountsInput
    Subscribes?: SubscribesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetailResources?: TaskDetailResourcesUncheckedCreateNestedManyWithoutAccountsInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutAccountsInput
    TaskGroups?: TaskGroupsUncheckedCreateNestedManyWithoutAccountsInput
    Tasks?: TasksUncheckedCreateNestedManyWithoutAccountsInput
    TeamAgents?: TeamAgentsUncheckedCreateNestedManyWithoutAccountsInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedCreateNestedManyWithoutAccounts_AccountsToTeams_AccountIdInput
  }

  export type AccountsCreateOrConnectWithoutTeams_AccountsToTeams_AgentIdInput = {
    where: AccountsWhereUniqueInput
    create: XOR<AccountsCreateWithoutTeams_AccountsToTeams_AgentIdInput, AccountsUncheckedCreateWithoutTeams_AccountsToTeams_AgentIdInput>
  }

  export type TasksCreateWithoutTeamsInput = {
    name?: string | null
    status?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    workingDays?: number | null
    workingTeamsCnt?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    area?: Decimal | DecimalJsLike | number | string | null
    isPaid?: boolean | null
    createType?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: Decimal | DecimalJsLike | number | string | null
    Accounts?: AccountsCreateNestedOneWithoutTasksInput
    TaskGroups?: TaskGroupsCreateNestedOneWithoutTasksInput
    Reports?: ReportsCreateNestedManyWithoutTasksInput
    Statistics?: StatisticsCreateNestedManyWithoutTasksInput
    TaskDetails?: TaskDetailsCreateNestedManyWithoutTasksInput
  }

  export type TasksUncheckedCreateWithoutTeamsInput = {
    id?: number
    name?: string | null
    status?: string | null
    AccountId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    workingDays?: number | null
    workingTeamsCnt?: number | null
    TaskGroupId?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    area?: Decimal | DecimalJsLike | number | string | null
    isPaid?: boolean | null
    createType?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: Decimal | DecimalJsLike | number | string | null
    Reports?: ReportsUncheckedCreateNestedManyWithoutTasksInput
    Statistics?: StatisticsUncheckedCreateNestedManyWithoutTasksInput
    TaskDetails?: TaskDetailsUncheckedCreateNestedManyWithoutTasksInput
  }

  export type TasksCreateOrConnectWithoutTeamsInput = {
    where: TasksWhereUniqueInput
    create: XOR<TasksCreateWithoutTeamsInput, TasksUncheckedCreateWithoutTeamsInput>
  }

  export type StatisticsCreateWithoutTeamsInput = {
    dailyWorkload?: Decimal | DecimalJsLike | number | string | null
    completedByOwner?: Decimal | DecimalJsLike | number | string | null
    completedBySelf?: Decimal | DecimalJsLike | number | string | null
    createdAt: Date | string
    updatedAt: Date | string
    Accounts?: AccountsCreateNestedOneWithoutStatisticsInput
    Tasks?: TasksCreateNestedOneWithoutStatisticsInput
  }

  export type StatisticsUncheckedCreateWithoutTeamsInput = {
    id?: number
    AgentId?: number | null
    TaskId?: number | null
    dailyWorkload?: Decimal | DecimalJsLike | number | string | null
    completedByOwner?: Decimal | DecimalJsLike | number | string | null
    completedBySelf?: Decimal | DecimalJsLike | number | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type StatisticsCreateOrConnectWithoutTeamsInput = {
    where: StatisticsWhereUniqueInput
    create: XOR<StatisticsCreateWithoutTeamsInput, StatisticsUncheckedCreateWithoutTeamsInput>
  }

  export type StatisticsCreateManyTeamsInputEnvelope = {
    data: Enumerable<StatisticsCreateManyTeamsInput>
    skipDuplicates?: boolean
  }

  export type TaskDetailsCreateWithoutTeamsInput = {
    type?: string | null
    address?: string | null
    villageName?: string | null
    pushUser?: string | null
    category?: string | null
    etc?: string | null
    status?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    assignedDays?: number | null
    assignedUser?: string | null
    y?: string | null
    x?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    pushPhone?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    memo?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    Accounts?: AccountsCreateNestedOneWithoutTaskDetailsInput
    Tasks?: TasksCreateNestedOneWithoutTaskDetailsInput
    TaskDetailResources?: TaskDetailResourcesCreateNestedManyWithoutTaskDetailsInput
  }

  export type TaskDetailsUncheckedCreateWithoutTeamsInput = {
    id?: number
    AccountId?: number | null
    TaskId?: number | null
    type?: string | null
    address?: string | null
    villageName?: string | null
    pushUser?: string | null
    category?: string | null
    etc?: string | null
    status?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    assignedDays?: number | null
    assignedUser?: string | null
    y?: string | null
    x?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    pushPhone?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    memo?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    TaskDetailResources?: TaskDetailResourcesUncheckedCreateNestedManyWithoutTaskDetailsInput
  }

  export type TaskDetailsCreateOrConnectWithoutTeamsInput = {
    where: TaskDetailsWhereUniqueInput
    create: XOR<TaskDetailsCreateWithoutTeamsInput, TaskDetailsUncheckedCreateWithoutTeamsInput>
  }

  export type TaskDetailsCreateManyTeamsInputEnvelope = {
    data: Enumerable<TaskDetailsCreateManyTeamsInput>
    skipDuplicates?: boolean
  }

  export type TeamAgentsCreateWithoutTeamsInput = {
    isActive?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    Accounts: AccountsCreateNestedOneWithoutTeamAgentsInput
  }

  export type TeamAgentsUncheckedCreateWithoutTeamsInput = {
    AgentId: number
    isActive?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TeamAgentsCreateOrConnectWithoutTeamsInput = {
    where: TeamAgentsWhereUniqueInput
    create: XOR<TeamAgentsCreateWithoutTeamsInput, TeamAgentsUncheckedCreateWithoutTeamsInput>
  }

  export type TeamAgentsCreateManyTeamsInputEnvelope = {
    data: Enumerable<TeamAgentsCreateManyTeamsInput>
    skipDuplicates?: boolean
  }

  export type AccountsUpsertWithoutTeams_AccountsToTeams_AccountIdInput = {
    update: XOR<AccountsUpdateWithoutTeams_AccountsToTeams_AccountIdInput, AccountsUncheckedUpdateWithoutTeams_AccountsToTeams_AccountIdInput>
    create: XOR<AccountsCreateWithoutTeams_AccountsToTeams_AccountIdInput, AccountsUncheckedCreateWithoutTeams_AccountsToTeams_AccountIdInput>
  }

  export type AccountsUpdateWithoutTeams_AccountsToTeams_AccountIdInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Services?: ServicesUpdateOneWithoutAccountsNestedInput
    Alerts?: AlertsUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsUncheckedUpdateWithoutTeams_AccountsToTeams_AccountIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ServiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    Alerts?: AlertsUncheckedUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUncheckedUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUncheckedUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUncheckedUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUncheckedUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUncheckedUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUncheckedUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUncheckedUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUncheckedUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUncheckedUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUncheckedUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsUpsertWithoutTeams_AccountsToTeams_AgentIdInput = {
    update: XOR<AccountsUpdateWithoutTeams_AccountsToTeams_AgentIdInput, AccountsUncheckedUpdateWithoutTeams_AccountsToTeams_AgentIdInput>
    create: XOR<AccountsCreateWithoutTeams_AccountsToTeams_AgentIdInput, AccountsUncheckedCreateWithoutTeams_AccountsToTeams_AgentIdInput>
  }

  export type AccountsUpdateWithoutTeams_AccountsToTeams_AgentIdInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Services?: ServicesUpdateOneWithoutAccountsNestedInput
    Alerts?: AlertsUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
  }

  export type AccountsUncheckedUpdateWithoutTeams_AccountsToTeams_AgentIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ServiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    Alerts?: AlertsUncheckedUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUncheckedUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUncheckedUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUncheckedUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUncheckedUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUncheckedUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUncheckedUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUncheckedUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUncheckedUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUncheckedUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUncheckedUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
  }

  export type TasksUpsertWithoutTeamsInput = {
    update: XOR<TasksUpdateWithoutTeamsInput, TasksUncheckedUpdateWithoutTeamsInput>
    create: XOR<TasksCreateWithoutTeamsInput, TasksUncheckedCreateWithoutTeamsInput>
  }

  export type TasksUpdateWithoutTeamsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: NullableIntFieldUpdateOperationsInput | number | null
    workingTeamsCnt?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createType?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Accounts?: AccountsUpdateOneWithoutTasksNestedInput
    TaskGroups?: TaskGroupsUpdateOneWithoutTasksNestedInput
    Reports?: ReportsUpdateManyWithoutTasksNestedInput
    Statistics?: StatisticsUpdateManyWithoutTasksNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutTasksNestedInput
  }

  export type TasksUncheckedUpdateWithoutTeamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: NullableIntFieldUpdateOperationsInput | number | null
    workingTeamsCnt?: NullableIntFieldUpdateOperationsInput | number | null
    TaskGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createType?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Reports?: ReportsUncheckedUpdateManyWithoutTasksNestedInput
    Statistics?: StatisticsUncheckedUpdateManyWithoutTasksNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutTasksNestedInput
  }

  export type StatisticsUpsertWithWhereUniqueWithoutTeamsInput = {
    where: StatisticsWhereUniqueInput
    update: XOR<StatisticsUpdateWithoutTeamsInput, StatisticsUncheckedUpdateWithoutTeamsInput>
    create: XOR<StatisticsCreateWithoutTeamsInput, StatisticsUncheckedCreateWithoutTeamsInput>
  }

  export type StatisticsUpdateWithWhereUniqueWithoutTeamsInput = {
    where: StatisticsWhereUniqueInput
    data: XOR<StatisticsUpdateWithoutTeamsInput, StatisticsUncheckedUpdateWithoutTeamsInput>
  }

  export type StatisticsUpdateManyWithWhereWithoutTeamsInput = {
    where: StatisticsScalarWhereInput
    data: XOR<StatisticsUpdateManyMutationInput, StatisticsUncheckedUpdateManyWithoutStatisticsInput>
  }

  export type TaskDetailsUpsertWithWhereUniqueWithoutTeamsInput = {
    where: TaskDetailsWhereUniqueInput
    update: XOR<TaskDetailsUpdateWithoutTeamsInput, TaskDetailsUncheckedUpdateWithoutTeamsInput>
    create: XOR<TaskDetailsCreateWithoutTeamsInput, TaskDetailsUncheckedCreateWithoutTeamsInput>
  }

  export type TaskDetailsUpdateWithWhereUniqueWithoutTeamsInput = {
    where: TaskDetailsWhereUniqueInput
    data: XOR<TaskDetailsUpdateWithoutTeamsInput, TaskDetailsUncheckedUpdateWithoutTeamsInput>
  }

  export type TaskDetailsUpdateManyWithWhereWithoutTeamsInput = {
    where: TaskDetailsScalarWhereInput
    data: XOR<TaskDetailsUpdateManyMutationInput, TaskDetailsUncheckedUpdateManyWithoutTaskDetailsInput>
  }

  export type TeamAgentsUpsertWithWhereUniqueWithoutTeamsInput = {
    where: TeamAgentsWhereUniqueInput
    update: XOR<TeamAgentsUpdateWithoutTeamsInput, TeamAgentsUncheckedUpdateWithoutTeamsInput>
    create: XOR<TeamAgentsCreateWithoutTeamsInput, TeamAgentsUncheckedCreateWithoutTeamsInput>
  }

  export type TeamAgentsUpdateWithWhereUniqueWithoutTeamsInput = {
    where: TeamAgentsWhereUniqueInput
    data: XOR<TeamAgentsUpdateWithoutTeamsInput, TeamAgentsUncheckedUpdateWithoutTeamsInput>
  }

  export type TeamAgentsUpdateManyWithWhereWithoutTeamsInput = {
    where: TeamAgentsScalarWhereInput
    data: XOR<TeamAgentsUpdateManyMutationInput, TeamAgentsUncheckedUpdateManyWithoutTeamAgentsInput>
  }

  export type AlertsCreateManyAccountsInput = {
    id?: bigint | number
    title?: string | null
    type: string
    category: string
    ReferenceId: number
    isRead?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CareersCreateManyAccountsInput = {
    id?: number
    title?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    content?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CustomerTaskDetailsCreateManyAccountsInput = {
    id?: number
    CustomerId?: number | null
    type?: string | null
    address?: string | null
    villageName?: string | null
    category?: string | null
    etc?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: string | null
    y?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CustomersCreateManyAccountsInput = {
    id?: number
    name?: string | null
    email?: string | null
    phone?: string | null
    crops?: CustomersCreatecropsInput | Enumerable<string>
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type DiscountsCreateManyAccountsInput = {
    id?: number
    name?: string | null
    price?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    OrderId?: number | null
    CouponId?: number | null
    ProductId?: number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LandsCreateManyAccountsInput = {
    id?: bigint | number
    is_active?: boolean | null
    type?: string | null
    villageName?: string | null
    status?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: string | null
    y?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type NotificationsCreateManyAccountsInput = {
    id?: bigint | number
    fcmToken: string
    sendedAt?: Date | string | null
    isSuccess?: boolean | null
    failReason?: string | null
    eventCode: string
    sendCode: string
    reservationCode: string
    sendCycleCode: string
    title: string
    message: string
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type OrderHistoriesCreateManyAccountsInput = {
    id?: number
    name?: string | null
    payment?: string | null
    paymentMethod?: string | null
    externalUid?: string | null
    customerUid?: string | null
    merchantUid?: string | null
    reqAmount?: number | null
    paidAmount?: number | null
    status?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    ProductId?: number | null
    OrderId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type OrdersCreateManyAccountsInput = {
    id?: number
    name?: string | null
    payment?: string | null
    paymentMethod?: string | null
    externalUid?: string | null
    customerUid?: string | null
    merchantUid?: string | null
    reqAmount?: number | null
    paidAmount?: number | null
    status?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    ProductId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    expiredAt?: Date | string | null
    isSubscribe?: boolean | null
    issuedAt?: Date | string | null
  }

  export type PermissionsCreateManyAccountsInput = {
    id?: number
    resource: string
    key: enum_Permissions_key
    resourceId: number
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type PostAccountsCreateManyAccountsInput = {
    id?: number
    PostId?: number | null
    type?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type PostsCreateManyAccountsInput = {
    id?: number
    category?: string | null
    type?: PostsCreatetypeInput | Enumerable<string>
    content?: string | null
    unit?: string | null
    price?: number | null
    location?: PostsCreatelocationInput | Enumerable<string>
    area?: Decimal | DecimalJsLike | number | string | null
    title?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: string | null
    viewCount?: number | null
    contactName?: string | null
    contactPhone?: string | null
    contactEmail?: string | null
    qualifications?: PostsCreatequalificationsInput | Enumerable<string>
  }

  export type ReportsCreateManyAccountsInput = {
    id?: number
    name?: string | null
    isActive?: boolean | null
    isPrivate?: boolean | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    TaskId?: number | null
  }

  export type StatisticsCreateManyAccountsInput = {
    id?: number
    TeamId?: number | null
    TaskId?: number | null
    dailyWorkload?: Decimal | DecimalJsLike | number | string | null
    completedByOwner?: Decimal | DecimalJsLike | number | string | null
    completedBySelf?: Decimal | DecimalJsLike | number | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type SubscribesCreateManyAccountsInput = {
    id?: number
    fcmToken: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TaskDetailResourcesCreateManyAccountsInput = {
    id?: number
    content?: string | null
    type?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    TaskDetailId?: number | null
    group?: string | null
  }

  export type TaskDetailsCreateManyAccountsInput = {
    id?: number
    TaskId?: number | null
    type?: string | null
    address?: string | null
    villageName?: string | null
    pushUser?: string | null
    category?: string | null
    etc?: string | null
    status?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    assignedDays?: number | null
    assignedUser?: string | null
    TeamId?: number | null
    y?: string | null
    x?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    pushPhone?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    memo?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TaskGroupsCreateManyAccountsInput = {
    id?: number
    path?: string | null
    name?: string | null
    status?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    area?: Decimal | DecimalJsLike | number | string | null
    createType?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TasksCreateManyAccountsInput = {
    id?: number
    name?: string | null
    status?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    workingDays?: number | null
    workingTeamsCnt?: number | null
    TaskGroupId?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    area?: Decimal | DecimalJsLike | number | string | null
    isPaid?: boolean | null
    createType?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: Decimal | DecimalJsLike | number | string | null
  }

  export type TeamAgentsCreateManyAccountsInput = {
    TeamId: number
    isActive?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TeamsCreateManyAccounts_AccountsToTeams_AccountIdInput = {
    id?: number
    name?: string | null
    AgentId?: number | null
    TaskId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    status?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    alias?: string | null
  }

  export type TeamsCreateManyAccounts_AccountsToTeams_AgentIdInput = {
    id?: number
    name?: string | null
    AccountId?: number | null
    TaskId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    status?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    alias?: string | null
  }

  export type AlertsUpdateWithoutAccountsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    ReferenceId?: IntFieldUpdateOperationsInput | number
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AlertsUncheckedUpdateWithoutAccountsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    ReferenceId?: IntFieldUpdateOperationsInput | number
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AlertsUncheckedUpdateManyWithoutAlertsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    ReferenceId?: IntFieldUpdateOperationsInput | number
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CareersUpdateWithoutAccountsInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareersUncheckedUpdateWithoutAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareersUncheckedUpdateManyWithoutCareersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerTaskDetailsUpdateWithoutAccountsInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    villageName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    etc?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Customers?: CustomersUpdateOneWithoutCustomerTaskDetailsNestedInput
  }

  export type CustomerTaskDetailsUncheckedUpdateWithoutAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    CustomerId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    villageName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    etc?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerTaskDetailsUncheckedUpdateManyWithoutCustomerTaskDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    CustomerId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    villageName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    etc?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomersUpdateWithoutAccountsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    crops?: CustomersUpdatecropsInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CustomerTaskDetails?: CustomerTaskDetailsUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateWithoutAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    crops?: CustomersUpdatecropsInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateManyWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    crops?: CustomersUpdatecropsInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountsUpdateWithoutAccountsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    Coupons?: CouponsUpdateOneWithoutDiscountsNestedInput
    Orders?: OrdersUpdateOneWithoutDiscountsNestedInput
    Products?: ProductsUpdateOneWithoutDiscountsNestedInput
  }

  export type DiscountsUncheckedUpdateWithoutAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    OrderId?: NullableIntFieldUpdateOperationsInput | number | null
    CouponId?: NullableIntFieldUpdateOperationsInput | number | null
    ProductId?: NullableIntFieldUpdateOperationsInput | number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DiscountsUncheckedUpdateManyWithoutDiscountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    OrderId?: NullableIntFieldUpdateOperationsInput | number | null
    CouponId?: NullableIntFieldUpdateOperationsInput | number | null
    ProductId?: NullableIntFieldUpdateOperationsInput | number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LandsUpdateWithoutAccountsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    villageName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandsUncheckedUpdateWithoutAccountsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    villageName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandsUncheckedUpdateManyWithoutLandsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    villageName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsUpdateWithoutAccountsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fcmToken?: StringFieldUpdateOperationsInput | string
    sendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSuccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    failReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventCode?: StringFieldUpdateOperationsInput | string
    sendCode?: StringFieldUpdateOperationsInput | string
    reservationCode?: StringFieldUpdateOperationsInput | string
    sendCycleCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsUncheckedUpdateWithoutAccountsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fcmToken?: StringFieldUpdateOperationsInput | string
    sendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSuccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    failReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventCode?: StringFieldUpdateOperationsInput | string
    sendCode?: StringFieldUpdateOperationsInput | string
    reservationCode?: StringFieldUpdateOperationsInput | string
    sendCycleCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsUncheckedUpdateManyWithoutNotificationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fcmToken?: StringFieldUpdateOperationsInput | string
    sendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSuccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    failReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventCode?: StringFieldUpdateOperationsInput | string
    sendCode?: StringFieldUpdateOperationsInput | string
    reservationCode?: StringFieldUpdateOperationsInput | string
    sendCycleCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderHistoriesUpdateWithoutAccountsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    externalUid?: NullableStringFieldUpdateOperationsInput | string | null
    customerUid?: NullableStringFieldUpdateOperationsInput | string | null
    merchantUid?: NullableStringFieldUpdateOperationsInput | string | null
    reqAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Orders?: OrdersUpdateOneWithoutOrderHistoriesNestedInput
    Products?: ProductsUpdateOneWithoutOrderHistoriesNestedInput
  }

  export type OrderHistoriesUncheckedUpdateWithoutAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    externalUid?: NullableStringFieldUpdateOperationsInput | string | null
    customerUid?: NullableStringFieldUpdateOperationsInput | string | null
    merchantUid?: NullableStringFieldUpdateOperationsInput | string | null
    reqAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    ProductId?: NullableIntFieldUpdateOperationsInput | number | null
    OrderId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderHistoriesUncheckedUpdateManyWithoutOrderHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    externalUid?: NullableStringFieldUpdateOperationsInput | string | null
    customerUid?: NullableStringFieldUpdateOperationsInput | string | null
    merchantUid?: NullableStringFieldUpdateOperationsInput | string | null
    reqAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    ProductId?: NullableIntFieldUpdateOperationsInput | number | null
    OrderId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrdersUpdateWithoutAccountsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    externalUid?: NullableStringFieldUpdateOperationsInput | string | null
    customerUid?: NullableStringFieldUpdateOperationsInput | string | null
    merchantUid?: NullableStringFieldUpdateOperationsInput | string | null
    reqAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Products?: ProductsUpdateOneWithoutOrdersNestedInput
    Discounts?: DiscountsUpdateManyWithoutOrdersNestedInput
    OrderHistories?: OrderHistoriesUpdateManyWithoutOrdersNestedInput
  }

  export type OrdersUncheckedUpdateWithoutAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    externalUid?: NullableStringFieldUpdateOperationsInput | string | null
    customerUid?: NullableStringFieldUpdateOperationsInput | string | null
    merchantUid?: NullableStringFieldUpdateOperationsInput | string | null
    reqAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    ProductId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Discounts?: DiscountsUncheckedUpdateManyWithoutOrdersNestedInput
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type OrdersUncheckedUpdateManyWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    externalUid?: NullableStringFieldUpdateOperationsInput | string | null
    customerUid?: NullableStringFieldUpdateOperationsInput | string | null
    merchantUid?: NullableStringFieldUpdateOperationsInput | string | null
    reqAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    ProductId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PermissionsUpdateWithoutAccountsInput = {
    resource?: StringFieldUpdateOperationsInput | string
    key?: Enumenum_Permissions_keyFieldUpdateOperationsInput | enum_Permissions_key
    resourceId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionsUncheckedUpdateWithoutAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    resource?: StringFieldUpdateOperationsInput | string
    key?: Enumenum_Permissions_keyFieldUpdateOperationsInput | enum_Permissions_key
    resourceId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionsUncheckedUpdateManyWithoutPermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    resource?: StringFieldUpdateOperationsInput | string
    key?: Enumenum_Permissions_keyFieldUpdateOperationsInput | enum_Permissions_key
    resourceId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAccountsUpdateWithoutAccountsInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Posts?: PostsUpdateOneWithoutPostAccountsNestedInput
  }

  export type PostAccountsUncheckedUpdateWithoutAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    PostId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAccountsUncheckedUpdateManyWithoutPostAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    PostId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostsUpdateWithoutAccountsInput = {
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: PostsUpdatetypeInput | Enumerable<string>
    content?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    location?: PostsUpdatelocationInput | Enumerable<string>
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: PostsUpdatequalificationsInput | Enumerable<string>
    PostAccounts?: PostAccountsUpdateManyWithoutPostsNestedInput
  }

  export type PostsUncheckedUpdateWithoutAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: PostsUpdatetypeInput | Enumerable<string>
    content?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    location?: PostsUpdatelocationInput | Enumerable<string>
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: PostsUpdatequalificationsInput | Enumerable<string>
    PostAccounts?: PostAccountsUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type PostsUncheckedUpdateManyWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: PostsUpdatetypeInput | Enumerable<string>
    content?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    location?: PostsUpdatelocationInput | Enumerable<string>
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: PostsUpdatequalificationsInput | Enumerable<string>
  }

  export type ReportsUpdateWithoutAccountsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPrivate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Tasks?: TasksUpdateOneWithoutReportsNestedInput
  }

  export type ReportsUncheckedUpdateWithoutAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPrivate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TaskId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReportsUncheckedUpdateManyWithoutReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPrivate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TaskId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StatisticsUpdateWithoutAccountsInput = {
    dailyWorkload?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedByOwner?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedBySelf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Tasks?: TasksUpdateOneWithoutStatisticsNestedInput
    Teams?: TeamsUpdateOneWithoutStatisticsNestedInput
  }

  export type StatisticsUncheckedUpdateWithoutAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    TeamId?: NullableIntFieldUpdateOperationsInput | number | null
    TaskId?: NullableIntFieldUpdateOperationsInput | number | null
    dailyWorkload?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedByOwner?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedBySelf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatisticsUncheckedUpdateManyWithoutStatisticsInput = {
    id?: IntFieldUpdateOperationsInput | number
    TeamId?: NullableIntFieldUpdateOperationsInput | number | null
    TaskId?: NullableIntFieldUpdateOperationsInput | number | null
    dailyWorkload?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedByOwner?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedBySelf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscribesUpdateWithoutAccountsInput = {
    fcmToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscribesUncheckedUpdateWithoutAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fcmToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscribesUncheckedUpdateManyWithoutSubscribesInput = {
    id?: IntFieldUpdateOperationsInput | number
    fcmToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskDetailResourcesUpdateWithoutAccountsInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    TaskDetails?: TaskDetailsUpdateOneWithoutTaskDetailResourcesNestedInput
  }

  export type TaskDetailResourcesUncheckedUpdateWithoutAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TaskDetailId?: NullableIntFieldUpdateOperationsInput | number | null
    group?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskDetailResourcesUncheckedUpdateManyWithoutTaskDetailResourcesInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TaskDetailId?: NullableIntFieldUpdateOperationsInput | number | null
    group?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskDetailsUpdateWithoutAccountsInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    villageName?: NullableStringFieldUpdateOperationsInput | string | null
    pushUser?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    etc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedDays?: NullableIntFieldUpdateOperationsInput | number | null
    assignedUser?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pushPhone?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    Tasks?: TasksUpdateOneWithoutTaskDetailsNestedInput
    Teams?: TeamsUpdateOneWithoutTaskDetailsNestedInput
    TaskDetailResources?: TaskDetailResourcesUpdateManyWithoutTaskDetailsNestedInput
  }

  export type TaskDetailsUncheckedUpdateWithoutAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    TaskId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    villageName?: NullableStringFieldUpdateOperationsInput | string | null
    pushUser?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    etc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedDays?: NullableIntFieldUpdateOperationsInput | number | null
    assignedUser?: NullableStringFieldUpdateOperationsInput | string | null
    TeamId?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pushPhone?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    TaskDetailResources?: TaskDetailResourcesUncheckedUpdateManyWithoutTaskDetailsNestedInput
  }

  export type TaskDetailsUncheckedUpdateManyWithoutTaskDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    TaskId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    villageName?: NullableStringFieldUpdateOperationsInput | string | null
    pushUser?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    etc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedDays?: NullableIntFieldUpdateOperationsInput | number | null
    assignedUser?: NullableStringFieldUpdateOperationsInput | string | null
    TeamId?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pushPhone?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TaskGroupsUpdateWithoutAccountsInput = {
    path?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createType?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    Tasks?: TasksUpdateManyWithoutTaskGroupsNestedInput
  }

  export type TaskGroupsUncheckedUpdateWithoutAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createType?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    Tasks?: TasksUncheckedUpdateManyWithoutTaskGroupsNestedInput
  }

  export type TaskGroupsUncheckedUpdateManyWithoutTaskGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createType?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TasksUpdateWithoutAccountsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: NullableIntFieldUpdateOperationsInput | number | null
    workingTeamsCnt?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createType?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    TaskGroups?: TaskGroupsUpdateOneWithoutTasksNestedInput
    Reports?: ReportsUpdateManyWithoutTasksNestedInput
    Statistics?: StatisticsUpdateManyWithoutTasksNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutTasksNestedInput
    Teams?: TeamsUpdateManyWithoutTasksNestedInput
  }

  export type TasksUncheckedUpdateWithoutAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: NullableIntFieldUpdateOperationsInput | number | null
    workingTeamsCnt?: NullableIntFieldUpdateOperationsInput | number | null
    TaskGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createType?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Reports?: ReportsUncheckedUpdateManyWithoutTasksNestedInput
    Statistics?: StatisticsUncheckedUpdateManyWithoutTasksNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutTasksNestedInput
    Teams?: TeamsUncheckedUpdateManyWithoutTasksNestedInput
  }

  export type TasksUncheckedUpdateManyWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: NullableIntFieldUpdateOperationsInput | number | null
    workingTeamsCnt?: NullableIntFieldUpdateOperationsInput | number | null
    TaskGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createType?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type TeamAgentsUpdateWithoutAccountsInput = {
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Teams?: TeamsUpdateOneRequiredWithoutTeamAgentsNestedInput
  }

  export type TeamAgentsUncheckedUpdateWithoutAccountsInput = {
    TeamId?: IntFieldUpdateOperationsInput | number
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamAgentsUncheckedUpdateManyWithoutTeamAgentsInput = {
    TeamId?: IntFieldUpdateOperationsInput | number
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamsUpdateWithoutAccounts_AccountsToTeams_AccountIdInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    Accounts_AccountsToTeams_AgentId?: AccountsUpdateOneWithoutTeams_AccountsToTeams_AgentIdNestedInput
    Tasks?: TasksUpdateOneWithoutTeamsNestedInput
    Statistics?: StatisticsUpdateManyWithoutTeamsNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutTeamsNestedInput
    TeamAgents?: TeamAgentsUpdateManyWithoutTeamsNestedInput
  }

  export type TeamsUncheckedUpdateWithoutAccounts_AccountsToTeams_AccountIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    AgentId?: NullableIntFieldUpdateOperationsInput | number | null
    TaskId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    Statistics?: StatisticsUncheckedUpdateManyWithoutTeamsNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutTeamsNestedInput
    TeamAgents?: TeamAgentsUncheckedUpdateManyWithoutTeamsNestedInput
  }

  export type TeamsUncheckedUpdateManyWithoutTeams_AccountsToTeams_AccountIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    AgentId?: NullableIntFieldUpdateOperationsInput | number | null
    TaskId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeamsUpdateWithoutAccounts_AccountsToTeams_AgentIdInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    Accounts_AccountsToTeams_AccountId?: AccountsUpdateOneWithoutTeams_AccountsToTeams_AccountIdNestedInput
    Tasks?: TasksUpdateOneWithoutTeamsNestedInput
    Statistics?: StatisticsUpdateManyWithoutTeamsNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutTeamsNestedInput
    TeamAgents?: TeamAgentsUpdateManyWithoutTeamsNestedInput
  }

  export type TeamsUncheckedUpdateWithoutAccounts_AccountsToTeams_AgentIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    TaskId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    Statistics?: StatisticsUncheckedUpdateManyWithoutTeamsNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutTeamsNestedInput
    TeamAgents?: TeamAgentsUncheckedUpdateManyWithoutTeamsNestedInput
  }

  export type TeamsUncheckedUpdateManyWithoutTeams_AccountsToTeams_AgentIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    TaskId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DiscountsCreateManyCouponsInput = {
    id?: number
    name?: string | null
    price?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    AccountId?: number | null
    OrderId?: number | null
    ProductId?: number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DiscountsUpdateWithoutCouponsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    Accounts?: AccountsUpdateOneWithoutDiscountsNestedInput
    Orders?: OrdersUpdateOneWithoutDiscountsNestedInput
    Products?: ProductsUpdateOneWithoutDiscountsNestedInput
  }

  export type DiscountsUncheckedUpdateWithoutCouponsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    OrderId?: NullableIntFieldUpdateOperationsInput | number | null
    ProductId?: NullableIntFieldUpdateOperationsInput | number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CustomerTaskDetailsCreateManyCustomersInput = {
    id?: number
    AccountId?: number | null
    type?: string | null
    address?: string | null
    villageName?: string | null
    category?: string | null
    etc?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: string | null
    y?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CustomerTaskDetailsUpdateWithoutCustomersInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    villageName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    etc?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Accounts?: AccountsUpdateOneWithoutCustomerTaskDetailsNestedInput
  }

  export type CustomerTaskDetailsUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    villageName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    etc?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountsCreateManyOrdersInput = {
    id?: number
    name?: string | null
    price?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    AccountId?: number | null
    CouponId?: number | null
    ProductId?: number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OrderHistoriesCreateManyOrdersInput = {
    id?: number
    name?: string | null
    payment?: string | null
    paymentMethod?: string | null
    externalUid?: string | null
    customerUid?: string | null
    merchantUid?: string | null
    reqAmount?: number | null
    paidAmount?: number | null
    status?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    AccountId?: number | null
    ProductId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type DiscountsUpdateWithoutOrdersInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    Accounts?: AccountsUpdateOneWithoutDiscountsNestedInput
    Coupons?: CouponsUpdateOneWithoutDiscountsNestedInput
    Products?: ProductsUpdateOneWithoutDiscountsNestedInput
  }

  export type DiscountsUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    CouponId?: NullableIntFieldUpdateOperationsInput | number | null
    ProductId?: NullableIntFieldUpdateOperationsInput | number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OrderHistoriesUpdateWithoutOrdersInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    externalUid?: NullableStringFieldUpdateOperationsInput | string | null
    customerUid?: NullableStringFieldUpdateOperationsInput | string | null
    merchantUid?: NullableStringFieldUpdateOperationsInput | string | null
    reqAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Accounts?: AccountsUpdateOneWithoutOrderHistoriesNestedInput
    Products?: ProductsUpdateOneWithoutOrderHistoriesNestedInput
  }

  export type OrderHistoriesUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    externalUid?: NullableStringFieldUpdateOperationsInput | string | null
    customerUid?: NullableStringFieldUpdateOperationsInput | string | null
    merchantUid?: NullableStringFieldUpdateOperationsInput | string | null
    reqAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    ProductId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAccountsCreateManyPostsInput = {
    id?: number
    AccountId?: number | null
    type?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type PostAccountsUpdateWithoutPostsInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Accounts?: AccountsUpdateOneWithoutPostAccountsNestedInput
  }

  export type PostAccountsUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountsCreateManyProductsInput = {
    id?: number
    name?: string | null
    price?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    AccountId?: number | null
    OrderId?: number | null
    CouponId?: number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OrderHistoriesCreateManyProductsInput = {
    id?: number
    name?: string | null
    payment?: string | null
    paymentMethod?: string | null
    externalUid?: string | null
    customerUid?: string | null
    merchantUid?: string | null
    reqAmount?: number | null
    paidAmount?: number | null
    status?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    AccountId?: number | null
    OrderId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type OrdersCreateManyProductsInput = {
    id?: number
    name?: string | null
    payment?: string | null
    paymentMethod?: string | null
    externalUid?: string | null
    customerUid?: string | null
    merchantUid?: string | null
    reqAmount?: number | null
    paidAmount?: number | null
    status?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    AccountId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    expiredAt?: Date | string | null
    isSubscribe?: boolean | null
    issuedAt?: Date | string | null
  }

  export type DiscountsUpdateWithoutProductsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    Accounts?: AccountsUpdateOneWithoutDiscountsNestedInput
    Coupons?: CouponsUpdateOneWithoutDiscountsNestedInput
    Orders?: OrdersUpdateOneWithoutDiscountsNestedInput
  }

  export type DiscountsUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    OrderId?: NullableIntFieldUpdateOperationsInput | number | null
    CouponId?: NullableIntFieldUpdateOperationsInput | number | null
    filters?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OrderHistoriesUpdateWithoutProductsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    externalUid?: NullableStringFieldUpdateOperationsInput | string | null
    customerUid?: NullableStringFieldUpdateOperationsInput | string | null
    merchantUid?: NullableStringFieldUpdateOperationsInput | string | null
    reqAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Accounts?: AccountsUpdateOneWithoutOrderHistoriesNestedInput
    Orders?: OrdersUpdateOneWithoutOrderHistoriesNestedInput
  }

  export type OrderHistoriesUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    externalUid?: NullableStringFieldUpdateOperationsInput | string | null
    customerUid?: NullableStringFieldUpdateOperationsInput | string | null
    merchantUid?: NullableStringFieldUpdateOperationsInput | string | null
    reqAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    OrderId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrdersUpdateWithoutProductsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    externalUid?: NullableStringFieldUpdateOperationsInput | string | null
    customerUid?: NullableStringFieldUpdateOperationsInput | string | null
    merchantUid?: NullableStringFieldUpdateOperationsInput | string | null
    reqAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Accounts?: AccountsUpdateOneWithoutOrdersNestedInput
    Discounts?: DiscountsUpdateManyWithoutOrdersNestedInput
    OrderHistories?: OrderHistoriesUpdateManyWithoutOrdersNestedInput
  }

  export type OrdersUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    externalUid?: NullableStringFieldUpdateOperationsInput | string | null
    customerUid?: NullableStringFieldUpdateOperationsInput | string | null
    merchantUid?: NullableStringFieldUpdateOperationsInput | string | null
    reqAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Discounts?: DiscountsUncheckedUpdateManyWithoutOrdersNestedInput
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type AccountsCreateManyServicesInput = {
    id?: number
    phone?: string | null
    verifyToken?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: boolean | null
    email?: string | null
    password?: string | null
    name?: string | null
    isVerify?: boolean | null
    isApprove?: boolean | null
  }

  export type AccountsUpdateWithoutServicesInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Alerts?: AlertsUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsUncheckedUpdateWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Alerts?: AlertsUncheckedUpdateManyWithoutAccountsNestedInput
    Careers?: CareersUncheckedUpdateManyWithoutAccountsNestedInput
    CustomerTaskDetails?: CustomerTaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutAccountsNestedInput
    Discounts?: DiscountsUncheckedUpdateManyWithoutAccountsNestedInput
    Lands?: LandsUncheckedUpdateManyWithoutAccountsNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutAccountsNestedInput
    OrderHistories?: OrderHistoriesUncheckedUpdateManyWithoutAccountsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutAccountsNestedInput
    PostAccounts?: PostAccountsUncheckedUpdateManyWithoutAccountsNestedInput
    Posts?: PostsUncheckedUpdateManyWithoutAccountsNestedInput
    Reports?: ReportsUncheckedUpdateManyWithoutAccountsNestedInput
    Statistics?: StatisticsUncheckedUpdateManyWithoutAccountsNestedInput
    Subscribes?: SubscribesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetailResources?: TaskDetailResourcesUncheckedUpdateManyWithoutAccountsNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutAccountsNestedInput
    TaskGroups?: TaskGroupsUncheckedUpdateManyWithoutAccountsNestedInput
    Tasks?: TasksUncheckedUpdateManyWithoutAccountsNestedInput
    TeamAgents?: TeamAgentsUncheckedUpdateManyWithoutAccountsNestedInput
    Teams_AccountsToTeams_AccountId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AccountIdNestedInput
    Teams_AccountsToTeams_AgentId?: TeamsUncheckedUpdateManyWithoutAccounts_AccountsToTeams_AgentIdNestedInput
  }

  export type AccountsUncheckedUpdateManyWithoutAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    verifyToken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: NullableJsonNullValueInput | InputJsonValue
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isVerify?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isApprove?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TaskDetailResourcesCreateManyTaskDetailsInput = {
    id?: number
    content?: string | null
    type?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    AccountId?: number | null
    group?: string | null
  }

  export type TaskDetailResourcesUpdateWithoutTaskDetailsInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    Accounts?: AccountsUpdateOneWithoutTaskDetailResourcesNestedInput
  }

  export type TaskDetailResourcesUncheckedUpdateWithoutTaskDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    group?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TasksCreateManyTaskGroupsInput = {
    id?: number
    name?: string | null
    status?: string | null
    AccountId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    workingDays?: number | null
    workingTeamsCnt?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    area?: Decimal | DecimalJsLike | number | string | null
    isPaid?: boolean | null
    createType?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: Decimal | DecimalJsLike | number | string | null
  }

  export type TasksUpdateWithoutTaskGroupsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: NullableIntFieldUpdateOperationsInput | number | null
    workingTeamsCnt?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createType?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Accounts?: AccountsUpdateOneWithoutTasksNestedInput
    Reports?: ReportsUpdateManyWithoutTasksNestedInput
    Statistics?: StatisticsUpdateManyWithoutTasksNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutTasksNestedInput
    Teams?: TeamsUpdateManyWithoutTasksNestedInput
  }

  export type TasksUncheckedUpdateWithoutTaskGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: NullableIntFieldUpdateOperationsInput | number | null
    workingTeamsCnt?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createType?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    real_area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Reports?: ReportsUncheckedUpdateManyWithoutTasksNestedInput
    Statistics?: StatisticsUncheckedUpdateManyWithoutTasksNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutTasksNestedInput
    Teams?: TeamsUncheckedUpdateManyWithoutTasksNestedInput
  }

  export type ReportsCreateManyTasksInput = {
    id?: number
    name?: string | null
    isActive?: boolean | null
    isPrivate?: boolean | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    AccountId?: number | null
  }

  export type StatisticsCreateManyTasksInput = {
    id?: number
    AgentId?: number | null
    TeamId?: number | null
    dailyWorkload?: Decimal | DecimalJsLike | number | string | null
    completedByOwner?: Decimal | DecimalJsLike | number | string | null
    completedBySelf?: Decimal | DecimalJsLike | number | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TaskDetailsCreateManyTasksInput = {
    id?: number
    AccountId?: number | null
    type?: string | null
    address?: string | null
    villageName?: string | null
    pushUser?: string | null
    category?: string | null
    etc?: string | null
    status?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    assignedDays?: number | null
    assignedUser?: string | null
    TeamId?: number | null
    y?: string | null
    x?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    pushPhone?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    memo?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TeamsCreateManyTasksInput = {
    id?: number
    name?: string | null
    AccountId?: number | null
    AgentId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    status?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    alias?: string | null
  }

  export type ReportsUpdateWithoutTasksInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPrivate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Accounts?: AccountsUpdateOneWithoutReportsNestedInput
  }

  export type ReportsUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPrivate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StatisticsUpdateWithoutTasksInput = {
    dailyWorkload?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedByOwner?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedBySelf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Accounts?: AccountsUpdateOneWithoutStatisticsNestedInput
    Teams?: TeamsUpdateOneWithoutStatisticsNestedInput
  }

  export type StatisticsUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    AgentId?: NullableIntFieldUpdateOperationsInput | number | null
    TeamId?: NullableIntFieldUpdateOperationsInput | number | null
    dailyWorkload?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedByOwner?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedBySelf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskDetailsUpdateWithoutTasksInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    villageName?: NullableStringFieldUpdateOperationsInput | string | null
    pushUser?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    etc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedDays?: NullableIntFieldUpdateOperationsInput | number | null
    assignedUser?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pushPhone?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    Accounts?: AccountsUpdateOneWithoutTaskDetailsNestedInput
    Teams?: TeamsUpdateOneWithoutTaskDetailsNestedInput
    TaskDetailResources?: TaskDetailResourcesUpdateManyWithoutTaskDetailsNestedInput
  }

  export type TaskDetailsUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    villageName?: NullableStringFieldUpdateOperationsInput | string | null
    pushUser?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    etc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedDays?: NullableIntFieldUpdateOperationsInput | number | null
    assignedUser?: NullableStringFieldUpdateOperationsInput | string | null
    TeamId?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pushPhone?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    TaskDetailResources?: TaskDetailResourcesUncheckedUpdateManyWithoutTaskDetailsNestedInput
  }

  export type TeamsUpdateWithoutTasksInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    Accounts_AccountsToTeams_AccountId?: AccountsUpdateOneWithoutTeams_AccountsToTeams_AccountIdNestedInput
    Accounts_AccountsToTeams_AgentId?: AccountsUpdateOneWithoutTeams_AccountsToTeams_AgentIdNestedInput
    Statistics?: StatisticsUpdateManyWithoutTeamsNestedInput
    TaskDetails?: TaskDetailsUpdateManyWithoutTeamsNestedInput
    TeamAgents?: TeamAgentsUpdateManyWithoutTeamsNestedInput
  }

  export type TeamsUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    AgentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    Statistics?: StatisticsUncheckedUpdateManyWithoutTeamsNestedInput
    TaskDetails?: TaskDetailsUncheckedUpdateManyWithoutTeamsNestedInput
    TeamAgents?: TeamAgentsUncheckedUpdateManyWithoutTeamsNestedInput
  }

  export type TeamsUncheckedUpdateManyWithoutTeamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    AgentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StatisticsCreateManyTeamsInput = {
    id?: number
    AgentId?: number | null
    TaskId?: number | null
    dailyWorkload?: Decimal | DecimalJsLike | number | string | null
    completedByOwner?: Decimal | DecimalJsLike | number | string | null
    completedBySelf?: Decimal | DecimalJsLike | number | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TaskDetailsCreateManyTeamsInput = {
    id?: number
    AccountId?: number | null
    TaskId?: number | null
    type?: string | null
    address?: string | null
    villageName?: string | null
    pushUser?: string | null
    category?: string | null
    etc?: string | null
    status?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    assignedDays?: number | null
    assignedUser?: string | null
    y?: string | null
    x?: string | null
    area?: Decimal | DecimalJsLike | number | string | null
    pushPhone?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    memo?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TeamAgentsCreateManyTeamsInput = {
    AgentId: number
    isActive?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type StatisticsUpdateWithoutTeamsInput = {
    dailyWorkload?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedByOwner?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedBySelf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Accounts?: AccountsUpdateOneWithoutStatisticsNestedInput
    Tasks?: TasksUpdateOneWithoutStatisticsNestedInput
  }

  export type StatisticsUncheckedUpdateWithoutTeamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    AgentId?: NullableIntFieldUpdateOperationsInput | number | null
    TaskId?: NullableIntFieldUpdateOperationsInput | number | null
    dailyWorkload?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedByOwner?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedBySelf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskDetailsUpdateWithoutTeamsInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    villageName?: NullableStringFieldUpdateOperationsInput | string | null
    pushUser?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    etc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedDays?: NullableIntFieldUpdateOperationsInput | number | null
    assignedUser?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pushPhone?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    Accounts?: AccountsUpdateOneWithoutTaskDetailsNestedInput
    Tasks?: TasksUpdateOneWithoutTaskDetailsNestedInput
    TaskDetailResources?: TaskDetailResourcesUpdateManyWithoutTaskDetailsNestedInput
  }

  export type TaskDetailsUncheckedUpdateWithoutTeamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    AccountId?: NullableIntFieldUpdateOperationsInput | number | null
    TaskId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    villageName?: NullableStringFieldUpdateOperationsInput | string | null
    pushUser?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    etc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedDays?: NullableIntFieldUpdateOperationsInput | number | null
    assignedUser?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pushPhone?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    TaskDetailResources?: TaskDetailResourcesUncheckedUpdateManyWithoutTaskDetailsNestedInput
  }

  export type TeamAgentsUpdateWithoutTeamsInput = {
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Accounts?: AccountsUpdateOneRequiredWithoutTeamAgentsNestedInput
  }

  export type TeamAgentsUncheckedUpdateWithoutTeamsInput = {
    AgentId?: IntFieldUpdateOperationsInput | number
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}